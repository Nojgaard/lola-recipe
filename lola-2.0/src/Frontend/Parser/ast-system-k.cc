/* translation of file(s)
	"Frontend/Parser/formula_abstract.k"
	"Frontend/Parser/formula_rewrite.k"
	"Frontend/Parser/formula_unparse.k"
 */
/* generated by:
 *  @(#)$Author: Kimwitu++ version 2.3.13 (C) 1998-2008 Humboldt-Universitaet zu Berlin $
 */
#define KC_TYPES

#include "ast-system-k.h"
#include <stdio.h>
#include <ctype.h>
#include <string>
#include <sys/types.h>
#include <stdlib.h>

#ifdef _MSC_VER
#pragma warning( disable : 4786 )
#endif
#include <new>
#include <set>
#include <list>
#include <algorithm>

#if !defined(USE_HASHSET) && (defined(__GNUC__) || defined(__ICC) || defined(__ECC)) \
&& !defined(DONT_USE_HASHSET)
#  define USE_HASHSET
#endif
#ifdef USE_HASHSET
#  if defined(__GNUC__) && __GNUC__>2
#    include <ext/hash_set>
#  else
#    include <hash_set>
#  endif
#endif

using namespace std;

namespace kc {

inline bool
ht_less(casestring p1, casestring p2){
    return kc_strcmp(p1->name, p2->name)<0;
}

inline bool
ht_less(nocasestring p1, nocasestring p2){
    return kc_strcasecmp(p1->name, p2->name)<0;
}

inline bool
ht_less(real p1, real p2){
    return p1->value < p2->value;
}

inline bool
ht_less(integer p1, integer p2){
    return p1->value < p2->value;
}

inline bool
ht_less(voidptr p1, voidptr p2){
    return p1->pointer < p2->pointer;
}

bool
ht_less(abstract_phylum p1, abstract_phylum p2)
{
    enum_operators prod_sel=p1->prod_sel();
    enum_operators prod_sel2=p2->prod_sel();
    if(prod_sel<prod_sel2)
	return true;
    if(prod_sel>prod_sel2)
	return false;
    switch(prod_sel) {
	case sel_NoCaseStr:
	    return ht_less(static_cast<nocasestring>(p1),static_cast<nocasestring>(p2));
	case sel__Str:
	    return ht_less(static_cast<casestring>(p1),static_cast<casestring>(p2));
	case sel__Real:
	    return ht_less(static_cast<real>(p1),static_cast<real>(p2));
	case sel__Int:
	    return ht_less(static_cast<integer>(p1),static_cast<integer>(p2));
	case sel__VoidPtr:
	    return ht_less(static_cast<voidptr>(p1),static_cast<voidptr>(p2));
	default: {
	    int i=0;
	    bool still_unique = kc_storageclass_still_uniq[phylum_info[p1->phylum()].uniq_stored];
	    abstract_phylum sub1=0;
	    do {
		sub1=p1->subphylum(i);
		abstract_phylum sub2=p2->subphylum(i);
		if(still_unique) {
		    if(sub1<sub2)
			return true;
		    if(sub2<sub1)
			return false;
		}
		else {
		    if(ht_less(sub1, sub2))
			return true;
		    if(ht_less(sub2, sub1))
			return false;
		}
		++i;
	    } while(sub1);
	}
    }
    return false;
}

template<typename T>
class phylum_less : std::binary_function<T, T, bool>
{
    public:
    bool operator()(const T& X, const T& Y) const
	{ return ht_less(X,Y); }
};

inline void deletefun(c_abstract_phylum t){
    delete const_cast<abstract_phylum>(t);
}


#ifdef USE_HASHSET
struct hashitem {
    size_t hashvalue;
    casestring contents;
    hashitem(casestring cs): contents(cs) {
	unsigned long h = 0;
	kc_char_t const *s = cs->name;
	for ( ; *s; ++s)
	    h = 5*h + *s;
	hashvalue=(size_t)h;
    }
};

inline void deletefunhashitem(hashitem t) {
    delete t.contents;
}

#  ifdef __GNUC__
struct eq_hashitem { bool operator()(hashitem hi1, hashitem hi2) const {
	return kc_strcmp(hi1.contents->name, hi2.contents->name) == 0; } };

struct hash_hashitem { size_t operator()(hashitem hi) const {
	return hi.hashvalue; } };

#  else
struct comp_hashitem {
    enum { bucket_size = 4, min_buckets = 8 };
    // bucket_size and min_buckets are just guesses
    size_t operator()(const hashitem hi) const {
	return hi.hashvalue; }
    bool operator()(const hashitem hi1, const hashitem hi2) const {
	return kc_strcmp(hi1.contents->name, hi2.contents->name) < 0; }
};
#  endif // Whether gcc or icc
#endif // Whether hash or not

struct hashtable_level
{
    hashtable_level(bool cod = true): clean_on_destruction(cod) { }
    void clear(bool free_entries=true) {
	if(free_entries)
	    clear_entries();
	_casestring.clear();
	_nocasestring.clear();
	_integer.clear();
	_real.clear();
	_voidptr.clear();
	_abstract_phylum.clear();
    }
    void clear_entries() {
#ifdef USE_HASHSET
	std::for_each(_casestring.begin(),_casestring.end(),deletefunhashitem);
#else
	std::for_each(_casestring.begin(),_casestring.end(),deletefun);
#endif
	std::for_each(_nocasestring.begin(),_nocasestring.end(),deletefun);
	std::for_each(_integer.begin(),_integer.end(),deletefun);
	std::for_each(_real.begin(),_real.end(),deletefun);
	std::for_each(_voidptr.begin(),_voidptr.end(),deletefun);
	std::for_each(_abstract_phylum.begin(),_abstract_phylum.end(),deletefun);
    }
    ~hashtable_level() {
	clear(clean_on_destruction);
    }
    abstract_phylum check_insert(abstract_phylum t) {
	return *_abstract_phylum.insert(t).first;
    }
    casestring check_insert(casestring t) {
#ifdef USE_HASHSET
	return (*_casestring.insert(hashitem(t)).first).contents;
#else
	return *_casestring.insert(t).first;
#endif
    }
    nocasestring check_insert(nocasestring t) {
	return *_nocasestring.insert(t).first;
    }
    integer check_insert(integer t) {
	return *_integer.insert(t).first;
    }
    real check_insert(real t) {
	return *_real.insert(t).first;
    }
    voidptr check_insert(voidptr t) {
	return *_voidptr.insert(t).first;
    }
private:
    bool clean_on_destruction;
#ifdef USE_HASHSET
#  ifdef __GNUC__
#    if __GNUC__==2 || (__GNUC__==3 && __GNUC_MINOR__==0)
    std::hash_set<hashitem, hash_hashitem, eq_hashitem> _casestring;
#    else
    __gnu_cxx::hash_set<hashitem, hash_hashitem, eq_hashitem> _casestring;
#    endif
#  else
    std::hash_set<hashitem, comp_hashitem> _casestring;
#  endif
#else
    std::set<casestring, phylum_less<casestring> > _casestring;
#endif
    std::set<nocasestring, phylum_less<nocasestring> > _nocasestring;
    std::set<integer, phylum_less<integer> > _integer;
    std::set<real, phylum_less<real> > _real;
    std::set<voidptr, phylum_less<voidptr> > _voidptr;
    std::set<abstract_phylum, phylum_less<abstract_phylum> > _abstract_phylum;
};

class hashtable_stack: public std::list<hashtable_level> {
public:
    hashtable_stack(): _pos(begin()) { }

    void inc_level() { _pos=insert(_pos, hashtable_level()); }
    void dec_level() { if(valid() && _pos!=end()) ++_pos; }
    void free_level() { if(_pos!=begin()) { erase(begin(),_pos);_pos=begin(); } }

    bool valid() const { return !empty(); }
    hashtable_level& get_level() { return *_pos; }

    template<typename T>
    T check_insert(T t) {
	return dynamic_cast<T>((*_pos).check_insert(t));
    }
private:
    iterator _pos;
};

class hashtable_struct_t {
public:
    // don't clean _static_level on destruction (program ends)
    hashtable_struct_t(): _static_level(false), _to_be_freed(false),  _dynamic(false) { }

    template <typename T>
    T ht_check_insert(T t) {
	if(_dynamic && _dynamic_level.valid())
	    return _dynamic_level.check_insert(t);
	else
	    return dynamic_cast<T>(_static_level.check_insert(t));
    }
    void ht_static() {_dynamic=false; }
    void ht_dynamic() {
	_dynamic=true;
	if(!_dynamic_level.valid())
	    _dynamic_level.inc_level();
    }
    void ht_inc_level() { _dynamic_level.inc_level(); }
    void ht_dec_level() { _dynamic_level.dec_level(); }
    void ht_free_level() { _dynamic_level.free_level(); }
    void ht_clear() { _static_level.clear(); _dynamic_level.clear(); _dynamic=false; }

    bool to_be_freed() { return _to_be_freed; }
    void set_to_be_freed(bool b=true) { _to_be_freed=b; }
private:
    hashtable_level _static_level;
    hashtable_stack _dynamic_level;
    bool _to_be_freed; /* should be true for dynamic, false for statically allocated structures */
    bool _dynamic;
};

impl_nocasestring_NoCaseStr::impl_nocasestring_NoCaseStr(const kc_char_t* _name) : name(_name) { }
void impl_nocasestring_NoCaseStr::make_own(int length) {
    kc_char_t *newname=new kc_char_t[length+1];
    for (int i=0; i < length && name[i]; ++i)
    newname[i] = kc_tolower(name[i]);
    newname[length]=0;
    name=newname;
}

impl_casestring__Str::impl_casestring__Str(const kc_char_t* _name) : name(_name) { }
void impl_casestring__Str::make_own(int length) {
    kc_char_t *newname=kc_strncpy(new kc_char_t[length+1],name,length);
    newname[length]=0;
    name=newname;
}
abstract_phylum impl_tAcceptingSet_AcceptingSet::subphylum(int no) const
{
    switch(no){
	case 0: return tAcceptingSet_1;
	case 1: return tAcceptingSet_2;
    }
    return 0;
}
abstract_phylum impl_tAcceptingSet_AcceptingState::subphylum(int no) const
{
    switch(no){
	case 0: return integer_1;
    }
    return 0;
}
abstract_phylum impl_tTransitionRules_TransitionRules::subphylum(int no) const
{
    switch(no){
	case 0: return tTransitionRules_1;
	case 1: return tTransitionRules_2;
    }
    return 0;
}
abstract_phylum impl_tTransitionRules_TransitionRule::subphylum(int no) const
{
    switch(no){
	case 0: return tFormula_1;
	case 1: return integer_1;
    }
    return 0;
}
abstract_phylum impl_tBuechiRules_BuechiRules::subphylum(int no) const
{
    switch(no){
	case 0: return tBuechiRules_1;
	case 1: return tBuechiRules_2;
    }
    return 0;
}
abstract_phylum impl_tBuechiRules_ExpandedBuechiRule::subphylum(int no) const
{
    switch(no){
	case 0: return integer_1;
	case 1: return tFormula_1;
	case 2: return integer_2;
    }
    return 0;
}
abstract_phylum impl_tBuechiRules_BuechiRule::subphylum(int no) const
{
    switch(no){
	case 0: return integer_1;
	case 1: return tTransitionRules_1;
    }
    return 0;
}
abstract_phylum impl_tBuechiAutomata_BuechiAutomaton::subphylum(int no) const
{
    switch(no){
	case 0: return tBuechiRules_1;
	case 1: return tAcceptingSet_1;
    }
    return 0;
}
abstract_phylum impl_tProduct_list::subphylum(int no) const
{
    switch(no){
	case 0: return tTerm_1;
	case 1: return tProduct_list_1;
    }
    return 0;
}
abstract_phylum impl_tTerm_ProductList::subphylum(int no) const
{
    switch(no){
	case 0: return tProduct_list_1;
    }
    return 0;
}
abstract_phylum impl_tTerm_Product::subphylum(int no) const
{
    switch(no){
	case 0: return integer_1;
	case 1: return tTerm_1;
    }
    return 0;
}
abstract_phylum impl_tTerm_Difference::subphylum(int no) const
{
    switch(no){
	case 0: return tTerm_1;
	case 1: return tTerm_2;
    }
    return 0;
}
abstract_phylum impl_tTerm_Sum::subphylum(int no) const
{
    switch(no){
	case 0: return tTerm_1;
	case 1: return tTerm_2;
    }
    return 0;
}
abstract_phylum impl_tTerm_Number::subphylum(int no) const
{
    switch(no){
	case 0: return integer_1;
    }
    return 0;
}
abstract_phylum impl_tTerm_Node::subphylum(int no) const
{
    switch(no){
	case 0: return integer_1;
    }
    return 0;
}
abstract_phylum impl_tAtomicProposition_Fireable::subphylum(int no) const
{
    switch(no){
	case 0: return integer_1;
    }
    return 0;
}
abstract_phylum impl_tAtomicProposition_LessEqualAtomicProposition::subphylum(int no) const
{
    switch(no){
	case 0: return tTerm_1;
	case 1: return tTerm_2;
    }
    return 0;
}
abstract_phylum impl_tAtomicProposition_LessAtomicProposition::subphylum(int no) const
{
    switch(no){
	case 0: return tTerm_1;
	case 1: return tTerm_2;
    }
    return 0;
}
abstract_phylum impl_tAtomicProposition_GreaterEqualAtomicProposition::subphylum(int no) const
{
    switch(no){
	case 0: return tTerm_1;
	case 1: return tTerm_2;
    }
    return 0;
}
abstract_phylum impl_tAtomicProposition_GreaterAtomicProposition::subphylum(int no) const
{
    switch(no){
	case 0: return tTerm_1;
	case 1: return tTerm_2;
    }
    return 0;
}
abstract_phylum impl_tAtomicProposition_NotEqualsAtomicProposition::subphylum(int no) const
{
    switch(no){
	case 0: return tTerm_1;
	case 1: return tTerm_2;
    }
    return 0;
}
abstract_phylum impl_tAtomicProposition_EqualsAtomicProposition::subphylum(int no) const
{
    switch(no){
	case 0: return tTerm_1;
	case 1: return tTerm_2;
    }
    return 0;
}
abstract_phylum impl_tDisjunction_list::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
	case 1: return tDisjunction_list_1;
    }
    return 0;
}
abstract_phylum impl_tConjunction_list::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
	case 1: return tConjunction_list_1;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_DisjunctionList::subphylum(int no) const
{
    switch(no){
	case 0: return tDisjunction_list_1;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_ConjunctionList::subphylum(int no) const
{
    switch(no){
	case 0: return tConjunction_list_1;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_EX::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_AX::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_EG::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_AG::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_EF::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_AF::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_ER::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
	case 1: return tStatePredicate_2;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_AR::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
	case 1: return tStatePredicate_2;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_EU::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
	case 1: return tStatePredicate_2;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_AU::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
	case 1: return tStatePredicate_2;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_Release::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
	case 1: return tStatePredicate_2;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_Until::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
	case 1: return tStatePredicate_2;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_NextState::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_Eventually::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_Always::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_ExPath::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_AllPath::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_Equivalence::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
	case 1: return tStatePredicate_2;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_Implication::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
	case 1: return tStatePredicate_2;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_ExclusiveDisjunction::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
	case 1: return tStatePredicate_2;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_Disjunction::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
	case 1: return tStatePredicate_2;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_Conjunction::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
	case 1: return tStatePredicate_2;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_Negation::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
    }
    return 0;
}
abstract_phylum impl_tStatePredicate_AtomicProposition::subphylum(int no) const
{
    switch(no){
	case 0: return tAtomicProposition_1;
    }
    return 0;
}
abstract_phylum impl_tFormula_StatePredicateFormula::subphylum(int no) const
{
    switch(no){
	case 0: return tStatePredicate_1;
    }
    return 0;
}
void impl_tAcceptingSet_AcceptingSet::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tAcceptingSet_1 = dynamic_cast<tAcceptingSet>(val);break;
	case 1: newval = tAcceptingSet_2 = dynamic_cast<tAcceptingSet>(val);break;
    }
    assertNonNull(newval);
}
void impl_tAcceptingSet_AcceptingState::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = integer_1 = dynamic_cast<integer>(val);break;
    }
    assertNonNull(newval);
}
void impl_tTransitionRules_TransitionRules::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tTransitionRules_1 = dynamic_cast<tTransitionRules>(val);break;
	case 1: newval = tTransitionRules_2 = dynamic_cast<tTransitionRules>(val);break;
    }
    assertNonNull(newval);
}
void impl_tTransitionRules_TransitionRule::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tFormula_1 = dynamic_cast<tFormula>(val);break;
	case 1: newval = integer_1 = dynamic_cast<integer>(val);break;
    }
    assertNonNull(newval);
}
void impl_tBuechiRules_BuechiRules::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tBuechiRules_1 = dynamic_cast<tBuechiRules>(val);break;
	case 1: newval = tBuechiRules_2 = dynamic_cast<tBuechiRules>(val);break;
    }
    assertNonNull(newval);
}
void impl_tBuechiRules_ExpandedBuechiRule::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = integer_1 = dynamic_cast<integer>(val);break;
	case 1: newval = tFormula_1 = dynamic_cast<tFormula>(val);break;
	case 2: newval = integer_2 = dynamic_cast<integer>(val);break;
    }
    assertNonNull(newval);
}
void impl_tBuechiRules_BuechiRule::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = integer_1 = dynamic_cast<integer>(val);break;
	case 1: newval = tTransitionRules_1 = dynamic_cast<tTransitionRules>(val);break;
    }
    assertNonNull(newval);
}
void impl_tBuechiAutomata_BuechiAutomaton::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tBuechiRules_1 = dynamic_cast<tBuechiRules>(val);break;
	case 1: newval = tAcceptingSet_1 = dynamic_cast<tAcceptingSet>(val);break;
    }
    assertNonNull(newval);
}
void impl_tProduct_list::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tTerm_1 = dynamic_cast<tTerm>(val);break;
	case 1: newval = tProduct_list_1 = dynamic_cast<tProduct_list>(val);break;
    }
    assertNonNull(newval);
}
void impl_tTerm_ProductList::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tProduct_list_1 = dynamic_cast<tProduct_list>(val);break;
    }
    assertNonNull(newval);
}
void impl_tTerm_Product::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = integer_1 = dynamic_cast<integer>(val);break;
	case 1: newval = tTerm_1 = dynamic_cast<tTerm>(val);break;
    }
    assertNonNull(newval);
}
void impl_tTerm_Difference::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tTerm_1 = dynamic_cast<tTerm>(val);break;
	case 1: newval = tTerm_2 = dynamic_cast<tTerm>(val);break;
    }
    assertNonNull(newval);
}
void impl_tTerm_Sum::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tTerm_1 = dynamic_cast<tTerm>(val);break;
	case 1: newval = tTerm_2 = dynamic_cast<tTerm>(val);break;
    }
    assertNonNull(newval);
}
void impl_tTerm_Number::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = integer_1 = dynamic_cast<integer>(val);break;
    }
    assertNonNull(newval);
}
void impl_tTerm_Node::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = integer_1 = dynamic_cast<integer>(val);break;
    }
    assertNonNull(newval);
}
void impl_tAtomicProposition_Fireable::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = integer_1 = dynamic_cast<integer>(val);break;
    }
    assertNonNull(newval);
}
void impl_tAtomicProposition_LessEqualAtomicProposition::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tTerm_1 = dynamic_cast<tTerm>(val);break;
	case 1: newval = tTerm_2 = dynamic_cast<tTerm>(val);break;
    }
    assertNonNull(newval);
}
void impl_tAtomicProposition_LessAtomicProposition::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tTerm_1 = dynamic_cast<tTerm>(val);break;
	case 1: newval = tTerm_2 = dynamic_cast<tTerm>(val);break;
    }
    assertNonNull(newval);
}
void impl_tAtomicProposition_GreaterEqualAtomicProposition::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tTerm_1 = dynamic_cast<tTerm>(val);break;
	case 1: newval = tTerm_2 = dynamic_cast<tTerm>(val);break;
    }
    assertNonNull(newval);
}
void impl_tAtomicProposition_GreaterAtomicProposition::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tTerm_1 = dynamic_cast<tTerm>(val);break;
	case 1: newval = tTerm_2 = dynamic_cast<tTerm>(val);break;
    }
    assertNonNull(newval);
}
void impl_tAtomicProposition_NotEqualsAtomicProposition::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tTerm_1 = dynamic_cast<tTerm>(val);break;
	case 1: newval = tTerm_2 = dynamic_cast<tTerm>(val);break;
    }
    assertNonNull(newval);
}
void impl_tAtomicProposition_EqualsAtomicProposition::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tTerm_1 = dynamic_cast<tTerm>(val);break;
	case 1: newval = tTerm_2 = dynamic_cast<tTerm>(val);break;
    }
    assertNonNull(newval);
}
void impl_tDisjunction_list::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
	case 1: newval = tDisjunction_list_1 = dynamic_cast<tDisjunction_list>(val);break;
    }
    assertNonNull(newval);
}
void impl_tConjunction_list::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
	case 1: newval = tConjunction_list_1 = dynamic_cast<tConjunction_list>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_DisjunctionList::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tDisjunction_list_1 = dynamic_cast<tDisjunction_list>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_ConjunctionList::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tConjunction_list_1 = dynamic_cast<tConjunction_list>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_EX::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_AX::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_EG::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_AG::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_EF::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_AF::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_ER::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
	case 1: newval = tStatePredicate_2 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_AR::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
	case 1: newval = tStatePredicate_2 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_EU::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
	case 1: newval = tStatePredicate_2 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_AU::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
	case 1: newval = tStatePredicate_2 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_Release::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
	case 1: newval = tStatePredicate_2 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_Until::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
	case 1: newval = tStatePredicate_2 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_NextState::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_Eventually::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_Always::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_ExPath::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_AllPath::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_Equivalence::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
	case 1: newval = tStatePredicate_2 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_Implication::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
	case 1: newval = tStatePredicate_2 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_ExclusiveDisjunction::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
	case 1: newval = tStatePredicate_2 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_Disjunction::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
	case 1: newval = tStatePredicate_2 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_Conjunction::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
	case 1: newval = tStatePredicate_2 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_Negation::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}
void impl_tStatePredicate_AtomicProposition::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tAtomicProposition_1 = dynamic_cast<tAtomicProposition>(val);break;
    }
    assertNonNull(newval);
}
void impl_tFormula_StatePredicateFormula::set_subphylum(int no, abstract_phylum val)
{
    abstract_phylum newval=0;
    switch(no) {
	case 0: newval = tStatePredicate_1 = dynamic_cast<tStatePredicate>(val);break;
    }
    assertNonNull(newval);
}

void
copy_attributes(enum_phyla copyPhy, c_abstract_phylum kc_p1, abstract_phylum kc_p2)
{
    switch(copyPhy) {
    case phylum_tFormula: {
	c_tFormula p1 = dynamic_cast<c_tFormula>(kc_p1);
	tFormula p2 = dynamic_cast<tFormula>(kc_p2);
	p2->type = p1->type;
	p2->formula = p1->formula;
	p2->ctl_formula = p1->ctl_formula;
	p2->ltl_tree = p1->ltl_tree;
	break;
    }
    case phylum_tStatePredicate: {
	c_tStatePredicate p1 = dynamic_cast<c_tStatePredicate>(kc_p1);
	tStatePredicate p2 = dynamic_cast<tStatePredicate>(kc_p2);
	p2->containsTemporal = p1->containsTemporal;
	p2->validCTLPathFormula = p1->validCTLPathFormula;
	p2->validCTLStateFormula = p1->validCTLStateFormula;
	p2->validLTLFormula = p1->validLTLFormula;
	p2->priority = p1->priority;
	break;
    }
    case phylum_tBuechiAutomata:
	dynamic_cast<tBuechiAutomata>(kc_p2)->automata = dynamic_cast<c_tBuechiAutomata>(kc_p1)->automata;
	break;
    case one_before_first_phylum: // just to avoid a warning about missing case if empty
    default:
	break; // it's alright, no attributes to copy
    }
    enum_operators copyOp=kc_p1->prod_sel();
    for (int i=operator_info[copyOp].no_attrs-1; i>=0; --i)
	attributeOf(kc_p2, i)=attributeOf(const_cast<abstract_phylum>(kc_p1), i);
}

KC_PHYLUM_INFO phylum_info[] = {
    { "", one_before_first_operator, one_before_first_operator, (kc_storageclass_t)0 }, /* dummy element */
    { "nocasestring", sel_NoCaseStr, sel_NoCaseStr, uniq },
    { "casestring", sel__Str, sel__Str, uniq },
    { "real", sel__Real, sel__Real, uniq },
    { "integer", sel__Int, sel__Int, uniq },
    { "voidptr", sel__VoidPtr, sel__VoidPtr, uniq },
    { "tFormula", sel_StatePredicateFormula, sel_StatePredicateFormula, kc_not_uniq },
    { "tStatePredicate", sel_AtomicProposition, sel_DisjunctionList, kc_not_uniq },
    { "tConjunction_list", sel_NiltConjunction_list, sel_ConstConjunction_list, kc_not_uniq },
    { "tDisjunction_list", sel_NiltDisjunction_list, sel_ConstDisjunction_list, kc_not_uniq },
    { "tAtomicProposition", sel_EqualsAtomicProposition, sel_Fireable, kc_not_uniq },
    { "tTerm", sel_Node, sel_ProductList, kc_not_uniq },
    { "tProduct_list", sel_NiltProduct_list, sel_ConstProduct_list, kc_not_uniq },
    { "tBuechiAutomata", sel_BuechiAutomaton, sel_BuechiNull, kc_not_uniq },
    { "tBuechiRules", sel_EmptyBuechiRules, sel_BuechiRules, kc_not_uniq },
    { "tTransitionRules", sel_EmptyTransitionRules, sel_TransitionRules, kc_not_uniq },
    { "tAcceptingSet", sel_EmptyAcceptingSet, sel_AcceptingSet, kc_not_uniq },
    { "", one_before_first_operator, one_before_first_operator, (kc_storageclass_t)0 } /* last element */
};

static enum_phyla kc_subphyla_StatePredicateFormula[] = { phylum_tStatePredicate };
static enum_phyla kc_subphyla_AtomicProposition[] = { phylum_tAtomicProposition };
static enum_phyla kc_subphyla_Negation[] = { phylum_tStatePredicate };
static enum_phyla kc_subphyla_Conjunction[] = { phylum_tStatePredicate, phylum_tStatePredicate };
static enum_phyla kc_subphyla_Disjunction[] = { phylum_tStatePredicate, phylum_tStatePredicate };
static enum_phyla kc_subphyla_ExclusiveDisjunction[] = { phylum_tStatePredicate, phylum_tStatePredicate };
static enum_phyla kc_subphyla_Implication[] = { phylum_tStatePredicate, phylum_tStatePredicate };
static enum_phyla kc_subphyla_Equivalence[] = { phylum_tStatePredicate, phylum_tStatePredicate };
static enum_phyla kc_subphyla_AllPath[] = { phylum_tStatePredicate };
static enum_phyla kc_subphyla_ExPath[] = { phylum_tStatePredicate };
static enum_phyla kc_subphyla_Always[] = { phylum_tStatePredicate };
static enum_phyla kc_subphyla_Eventually[] = { phylum_tStatePredicate };
static enum_phyla kc_subphyla_NextState[] = { phylum_tStatePredicate };
static enum_phyla kc_subphyla_Until[] = { phylum_tStatePredicate, phylum_tStatePredicate };
static enum_phyla kc_subphyla_Release[] = { phylum_tStatePredicate, phylum_tStatePredicate };
static enum_phyla kc_subphyla_AU[] = { phylum_tStatePredicate, phylum_tStatePredicate };
static enum_phyla kc_subphyla_EU[] = { phylum_tStatePredicate, phylum_tStatePredicate };
static enum_phyla kc_subphyla_AR[] = { phylum_tStatePredicate, phylum_tStatePredicate };
static enum_phyla kc_subphyla_ER[] = { phylum_tStatePredicate, phylum_tStatePredicate };
static enum_phyla kc_subphyla_AF[] = { phylum_tStatePredicate };
static enum_phyla kc_subphyla_EF[] = { phylum_tStatePredicate };
static enum_phyla kc_subphyla_AG[] = { phylum_tStatePredicate };
static enum_phyla kc_subphyla_EG[] = { phylum_tStatePredicate };
static enum_phyla kc_subphyla_AX[] = { phylum_tStatePredicate };
static enum_phyla kc_subphyla_EX[] = { phylum_tStatePredicate };
static enum_phyla kc_subphyla_ConjunctionList[] = { phylum_tConjunction_list };
static enum_phyla kc_subphyla_DisjunctionList[] = { phylum_tDisjunction_list };
static enum_phyla kc_subphyla_ConstConjunction_list[] = { phylum_tStatePredicate, phylum_tConjunction_list };
static enum_phyla kc_subphyla_ConstDisjunction_list[] = { phylum_tStatePredicate, phylum_tDisjunction_list };
static enum_phyla kc_subphyla_EqualsAtomicProposition[] = { phylum_tTerm, phylum_tTerm };
static enum_phyla kc_subphyla_NotEqualsAtomicProposition[] = { phylum_tTerm, phylum_tTerm };
static enum_phyla kc_subphyla_GreaterAtomicProposition[] = { phylum_tTerm, phylum_tTerm };
static enum_phyla kc_subphyla_GreaterEqualAtomicProposition[] = { phylum_tTerm, phylum_tTerm };
static enum_phyla kc_subphyla_LessAtomicProposition[] = { phylum_tTerm, phylum_tTerm };
static enum_phyla kc_subphyla_LessEqualAtomicProposition[] = { phylum_tTerm, phylum_tTerm };
static enum_phyla kc_subphyla_Fireable[] = { phylum_integer };
static enum_phyla kc_subphyla_Node[] = { phylum_integer };
static enum_phyla kc_subphyla_Number[] = { phylum_integer };
static enum_phyla kc_subphyla_Sum[] = { phylum_tTerm, phylum_tTerm };
static enum_phyla kc_subphyla_Difference[] = { phylum_tTerm, phylum_tTerm };
static enum_phyla kc_subphyla_Product[] = { phylum_integer, phylum_tTerm };
static enum_phyla kc_subphyla_ProductList[] = { phylum_tProduct_list };
static enum_phyla kc_subphyla_ConstProduct_list[] = { phylum_tTerm, phylum_tProduct_list };
static enum_phyla kc_subphyla_BuechiAutomaton[] = { phylum_tBuechiRules, phylum_tAcceptingSet };
static enum_phyla kc_subphyla_BuechiRule[] = { phylum_integer, phylum_tTransitionRules };
static enum_phyla kc_subphyla_ExpandedBuechiRule[] = { phylum_integer, phylum_tFormula, phylum_integer };
static enum_phyla kc_subphyla_BuechiRules[] = { phylum_tBuechiRules, phylum_tBuechiRules };
static enum_phyla kc_subphyla_TransitionRule[] = { phylum_tFormula, phylum_integer };
static enum_phyla kc_subphyla_TransitionRules[] = { phylum_tTransitionRules, phylum_tTransitionRules };
static enum_phyla kc_subphyla_AcceptingState[] = { phylum_integer };
static enum_phyla kc_subphyla_AcceptingSet[] = { phylum_tAcceptingSet, phylum_tAcceptingSet };


KC_OPERATOR_INFO operator_info[] = {
    { "", 0, 0, one_before_first_phylum, 0, 0, 0, 0 }, /* dummy element */
    { "NoCaseStr", 0, true, phylum_nocasestring, 0, 0, 0, sizeof(impl_nocasestring_NoCaseStr) },
    { "_Str", 0, true, phylum_casestring, 0, 0, 0, sizeof(impl_casestring__Str) },
    { "_Real", 0, true, phylum_real, 0, 0, 0, sizeof(impl_real__Real) },
    { "_Int", 0, true, phylum_integer, 0, 0, 0, sizeof(impl_integer__Int) },
    { "_VoidPtr", 0, true, phylum_voidptr, 0, 0, 0, sizeof(impl_voidptr__VoidPtr) },
    { "StatePredicateFormula", 1, false, phylum_tFormula, kc_subphyla_StatePredicateFormula, 0, 0, sizeof(impl_tFormula_StatePredicateFormula) },
    { "AtomicProposition", 1, false, phylum_tStatePredicate, kc_subphyla_AtomicProposition, 0, 0, sizeof(impl_tStatePredicate_AtomicProposition) },
    { "Negation", 1, false, phylum_tStatePredicate, kc_subphyla_Negation, 0, 0, sizeof(impl_tStatePredicate_Negation) },
    { "Conjunction", 2, false, phylum_tStatePredicate, kc_subphyla_Conjunction, 0, 0, sizeof(impl_tStatePredicate_Conjunction) },
    { "Disjunction", 2, false, phylum_tStatePredicate, kc_subphyla_Disjunction, 0, 0, sizeof(impl_tStatePredicate_Disjunction) },
    { "ExclusiveDisjunction", 2, false, phylum_tStatePredicate, kc_subphyla_ExclusiveDisjunction, 0, 0, sizeof(impl_tStatePredicate_ExclusiveDisjunction) },
    { "Implication", 2, false, phylum_tStatePredicate, kc_subphyla_Implication, 0, 0, sizeof(impl_tStatePredicate_Implication) },
    { "Equivalence", 2, false, phylum_tStatePredicate, kc_subphyla_Equivalence, 0, 0, sizeof(impl_tStatePredicate_Equivalence) },
    { "AllPath", 1, false, phylum_tStatePredicate, kc_subphyla_AllPath, 0, 0, sizeof(impl_tStatePredicate_AllPath) },
    { "ExPath", 1, false, phylum_tStatePredicate, kc_subphyla_ExPath, 0, 0, sizeof(impl_tStatePredicate_ExPath) },
    { "Always", 1, false, phylum_tStatePredicate, kc_subphyla_Always, 0, 0, sizeof(impl_tStatePredicate_Always) },
    { "Eventually", 1, false, phylum_tStatePredicate, kc_subphyla_Eventually, 0, 0, sizeof(impl_tStatePredicate_Eventually) },
    { "NextState", 1, false, phylum_tStatePredicate, kc_subphyla_NextState, 0, 0, sizeof(impl_tStatePredicate_NextState) },
    { "Until", 2, false, phylum_tStatePredicate, kc_subphyla_Until, 0, 0, sizeof(impl_tStatePredicate_Until) },
    { "Release", 2, false, phylum_tStatePredicate, kc_subphyla_Release, 0, 0, sizeof(impl_tStatePredicate_Release) },
    { "AU", 2, false, phylum_tStatePredicate, kc_subphyla_AU, 0, 0, sizeof(impl_tStatePredicate_AU) },
    { "EU", 2, false, phylum_tStatePredicate, kc_subphyla_EU, 0, 0, sizeof(impl_tStatePredicate_EU) },
    { "AR", 2, false, phylum_tStatePredicate, kc_subphyla_AR, 0, 0, sizeof(impl_tStatePredicate_AR) },
    { "ER", 2, false, phylum_tStatePredicate, kc_subphyla_ER, 0, 0, sizeof(impl_tStatePredicate_ER) },
    { "AF", 1, false, phylum_tStatePredicate, kc_subphyla_AF, 0, 0, sizeof(impl_tStatePredicate_AF) },
    { "EF", 1, false, phylum_tStatePredicate, kc_subphyla_EF, 0, 0, sizeof(impl_tStatePredicate_EF) },
    { "AG", 1, false, phylum_tStatePredicate, kc_subphyla_AG, 0, 0, sizeof(impl_tStatePredicate_AG) },
    { "EG", 1, false, phylum_tStatePredicate, kc_subphyla_EG, 0, 0, sizeof(impl_tStatePredicate_EG) },
    { "AX", 1, false, phylum_tStatePredicate, kc_subphyla_AX, 0, 0, sizeof(impl_tStatePredicate_AX) },
    { "EX", 1, false, phylum_tStatePredicate, kc_subphyla_EX, 0, 0, sizeof(impl_tStatePredicate_EX) },
    { "ConjunctionList", 1, false, phylum_tStatePredicate, kc_subphyla_ConjunctionList, 0, 0, sizeof(impl_tStatePredicate_ConjunctionList) },
    { "DisjunctionList", 1, false, phylum_tStatePredicate, kc_subphyla_DisjunctionList, 0, 0, sizeof(impl_tStatePredicate_DisjunctionList) },
    { "NiltConjunction_list", 0, false, phylum_tConjunction_list, 0, 0, 0, sizeof(impl_tConjunction_list) },
    { "ConstConjunction_list", 2, false, phylum_tConjunction_list, kc_subphyla_ConstConjunction_list, 0, 0, sizeof(impl_tConjunction_list) },
    { "NiltDisjunction_list", 0, false, phylum_tDisjunction_list, 0, 0, 0, sizeof(impl_tDisjunction_list) },
    { "ConstDisjunction_list", 2, false, phylum_tDisjunction_list, kc_subphyla_ConstDisjunction_list, 0, 0, sizeof(impl_tDisjunction_list) },
    { "EqualsAtomicProposition", 2, false, phylum_tAtomicProposition, kc_subphyla_EqualsAtomicProposition, 0, 0, sizeof(impl_tAtomicProposition_EqualsAtomicProposition) },
    { "NotEqualsAtomicProposition", 2, false, phylum_tAtomicProposition, kc_subphyla_NotEqualsAtomicProposition, 0, 0, sizeof(impl_tAtomicProposition_NotEqualsAtomicProposition) },
    { "GreaterAtomicProposition", 2, false, phylum_tAtomicProposition, kc_subphyla_GreaterAtomicProposition, 0, 0, sizeof(impl_tAtomicProposition_GreaterAtomicProposition) },
    { "GreaterEqualAtomicProposition", 2, false, phylum_tAtomicProposition, kc_subphyla_GreaterEqualAtomicProposition, 0, 0, sizeof(impl_tAtomicProposition_GreaterEqualAtomicProposition) },
    { "LessAtomicProposition", 2, false, phylum_tAtomicProposition, kc_subphyla_LessAtomicProposition, 0, 0, sizeof(impl_tAtomicProposition_LessAtomicProposition) },
    { "LessEqualAtomicProposition", 2, false, phylum_tAtomicProposition, kc_subphyla_LessEqualAtomicProposition, 0, 0, sizeof(impl_tAtomicProposition_LessEqualAtomicProposition) },
    { "True", 0, false, phylum_tAtomicProposition, 0, 0, 0, sizeof(impl_tAtomicProposition_True) },
    { "False", 0, false, phylum_tAtomicProposition, 0, 0, 0, sizeof(impl_tAtomicProposition_False) },
    { "NoDeadlock", 0, false, phylum_tAtomicProposition, 0, 0, 0, sizeof(impl_tAtomicProposition_NoDeadlock) },
    { "Deadlock", 0, false, phylum_tAtomicProposition, 0, 0, 0, sizeof(impl_tAtomicProposition_Deadlock) },
    { "Initial", 0, false, phylum_tAtomicProposition, 0, 0, 0, sizeof(impl_tAtomicProposition_Initial) },
    { "Fireable", 1, false, phylum_tAtomicProposition, kc_subphyla_Fireable, 0, 0, sizeof(impl_tAtomicProposition_Fireable) },
    { "Node", 1, false, phylum_tTerm, kc_subphyla_Node, 0, 0, sizeof(impl_tTerm_Node) },
    { "Number", 1, false, phylum_tTerm, kc_subphyla_Number, 0, 0, sizeof(impl_tTerm_Number) },
    { "Sum", 2, false, phylum_tTerm, kc_subphyla_Sum, 0, 0, sizeof(impl_tTerm_Sum) },
    { "Difference", 2, false, phylum_tTerm, kc_subphyla_Difference, 0, 0, sizeof(impl_tTerm_Difference) },
    { "Product", 2, false, phylum_tTerm, kc_subphyla_Product, 0, 0, sizeof(impl_tTerm_Product) },
    { "ProductList", 1, false, phylum_tTerm, kc_subphyla_ProductList, 0, 0, sizeof(impl_tTerm_ProductList) },
    { "NiltProduct_list", 0, false, phylum_tProduct_list, 0, 0, 0, sizeof(impl_tProduct_list) },
    { "ConstProduct_list", 2, false, phylum_tProduct_list, kc_subphyla_ConstProduct_list, 0, 0, sizeof(impl_tProduct_list) },
    { "BuechiAutomaton", 2, false, phylum_tBuechiAutomata, kc_subphyla_BuechiAutomaton, 0, 0, sizeof(impl_tBuechiAutomata_BuechiAutomaton) },
    { "BuechiNull", 0, false, phylum_tBuechiAutomata, 0, 0, 0, sizeof(impl_tBuechiAutomata_BuechiNull) },
    { "EmptyBuechiRules", 0, false, phylum_tBuechiRules, 0, 0, 0, sizeof(impl_tBuechiRules_EmptyBuechiRules) },
    { "BuechiRule", 2, false, phylum_tBuechiRules, kc_subphyla_BuechiRule, 0, 0, sizeof(impl_tBuechiRules_BuechiRule) },
    { "ExpandedBuechiRule", 3, false, phylum_tBuechiRules, kc_subphyla_ExpandedBuechiRule, 0, 0, sizeof(impl_tBuechiRules_ExpandedBuechiRule) },
    { "BuechiRules", 2, false, phylum_tBuechiRules, kc_subphyla_BuechiRules, 0, 0, sizeof(impl_tBuechiRules_BuechiRules) },
    { "EmptyTransitionRules", 0, false, phylum_tTransitionRules, 0, 0, 0, sizeof(impl_tTransitionRules_EmptyTransitionRules) },
    { "TransitionRule", 2, false, phylum_tTransitionRules, kc_subphyla_TransitionRule, 0, 0, sizeof(impl_tTransitionRules_TransitionRule) },
    { "TransitionRules", 2, false, phylum_tTransitionRules, kc_subphyla_TransitionRules, 0, 0, sizeof(impl_tTransitionRules_TransitionRules) },
    { "EmptyAcceptingSet", 0, false, phylum_tAcceptingSet, 0, 0, 0, sizeof(impl_tAcceptingSet_EmptyAcceptingSet) },
    { "AcceptingState", 1, false, phylum_tAcceptingSet, kc_subphyla_AcceptingState, 0, 0, sizeof(impl_tAcceptingSet_AcceptingState) },
    { "AcceptingSet", 2, false, phylum_tAcceptingSet, kc_subphyla_AcceptingSet, 0, 0, sizeof(impl_tAcceptingSet_AcceptingSet) },
    { "", 0, 0, one_before_first_phylum, 0, 0, 0, 0 } /* last element */
};

static enum_phyla phylumstorageclass_uniq[] = { one_before_first_phylum, phylum_nocasestring, phylum_casestring, phylum_real, phylum_integer, phylum_voidptr, last_phylum };

KC_UNIQ_INFO kc_UniqInfo[] = {
    (KC_UNIQ_INFO)0,
    phylumstorageclass_uniq
};

} // namespace kc

namespace kc {

void
kc_no_default_in_with( const char *kc_func, int kc_line, const char *kc_file )
{
    fflush(stdout);
#ifdef _AFX
    USES_CONVERSION;
    const _TCHAR* format=A2CT(KC_NO_DEFAULT_IN_WITH);
    const _TCHAR* tkc_func=A2CT(kc_func);
    const _TCHAR* tkc_file=A2CT(kc_file);
    TRACE( format, tkc_func, tkc_file, kc_line );
#ifdef _DEBUG
    if (AfxAssertFailedLine(kc_file, kc_line))
#endif
	AfxDebugBreak();
#else
    fprintf( stderr, KC_NO_DEFAULT_IN_WITH, kc_func, kc_file, kc_line );
#ifndef KC_NODEFAULT_NO_ABORT
    abort();
#else
    exit( 1 );
#endif
#endif
}

void
kc_returnless_function( const char *kc_func, int kc_line, const char *kc_file )
{
    fflush(stdout);
#ifdef _AFX
    USES_CONVERSION;
    const _TCHAR* format=_T("Internal Error: function %s does not return a value, at %s:%d");
    const _TCHAR* tkc_func=A2CT(kc_func);
    const _TCHAR* tkc_file=A2CT(kc_file);
    TRACE( format, tkc_func, tkc_file, kc_line );
#ifdef _DEBUG
    if (AfxAssertFailedLine(kc_file, kc_line))
#endif
	AfxDebugBreak();
#else
    fprintf( stderr, "Internal Error: function %s does not return a value, at %s:%d", kc_func, kc_file, kc_line );
#ifndef KC_NODEFAULT_NO_ABORT
    abort();
#else
    exit( 1 );
#endif
#endif
}

void
kc_assertionFailed(const char *kc_fn, int kc_l)
{
    fflush(stdout);
#ifdef _AFX
    USES_CONVERSION;
    const _TCHAR* format=_T("Internal Error: Assertion failed at %s:%d\n");
    const _TCHAR* tkc_func=A2CT(kc_fn);
    TRACE( format, tkc_func, kc_l );
#ifdef _DEBUG
    if (AfxAssertFailedLine(kc_fn, kc_l))
#endif
	AfxDebugBreak();
#else
    fprintf( stderr, "Internal Error: Assertion failed at %s:%d\n", kc_fn, kc_l );
#ifndef KC_ASSERT_NO_ABORT
    abort();
#else
    exit( 1 );
#endif
#endif
}

void
kc_assertionReasonFailed(const char *kc_fn, int kc_l, const char *kc_s)
{
    fflush(stdout);
#ifdef _AFX
    USES_CONVERSION;
    const _TCHAR* format=_T("Internal Error: Assertion failed at file %s:%d: %s\n");
    const _TCHAR* tkc_func=A2CT(kc_fn);
    const _TCHAR* tkc_s=A2CT(kc_s);
    TRACE( format, tkc_func, kc_l, tkc_s );
#ifdef _DEBUG
    if (AfxAssertFailedLine(kc_fn, kc_l))
#endif
	AfxDebugBreak();
#else
    fprintf( stderr, "Internal Error: Assertion failed at file %s:%d: %s\n", kc_fn, kc_l, kc_s );
#ifndef KC_ASSERT_NO_ABORT
    abort();
#else
    exit( 1 );
#endif
#endif
}

void
kc_assertionNonNullFailed(const char *kc_fn, int kc_l, const char *kc_str)
{
    fflush(stdout);
#ifdef _AFX
    USES_CONVERSION;
    const _TCHAR* format=_T("Internal Error: Assertion failed at %s:%d: pointer %s is NULL\n");
    const _TCHAR* tkc_func=A2CT(kc_fn);
    const _TCHAR* tkc_s=A2CT(kc_str);
    TRACE( format , tkc_func, kc_l, tkc_s);
#ifdef _DEBUG
    if (AfxAssertFailedLine(kc_fn, kc_l))
#endif
	AfxDebugBreak();
#else
    fprintf( stderr, "Internal Error: Assertion failed at %s:%d: pointer %s is NULL\n", kc_fn, kc_l, kc_str );
#ifndef KC_ASSERT_NO_ABORT
    abort();
#else
    exit( 1 );
#endif
#endif
}

void
kc_assertionOperatorInPhylumFailed(int kc_op, const char *kc_str1, const char *kc_str2, const char *kc_phy, const char *kc_fn, int kc_l)
{
    fflush(stdout);
#ifdef _AFX
    USES_CONVERSION;
    const _TCHAR* format=_T("Internal Error: Assertion failed at %s:%d: illegal value for (%s) %s%s: %d not a valid operator\n");
    const _TCHAR* tkc_func=A2CT(kc_fn);
    const _TCHAR* tkc_s1=A2CT(kc_str1);
    const _TCHAR* tkc_s2=A2CT(kc_str2);
    const _TCHAR* tname=A2CT(kc_phy);
    if ((kc_op <= one_before_first_operator) || (kc_op >= last_operator)) {
	TRACE (format, tkc_func, kc_l, tname, tkc_s1, tkc_s2, kc_op );
    } else {
	format=_T("Internal Error: Assertion failed at %s:%d: illegal value for (%s) %s%s: %s (%d) is a value of %s\n");
	const _TCHAR* tname2=A2CT(operator_info[kc_op].name);
	const _TCHAR* tname3=A2CT(phylum_info[operator_info[kc_op].phylum].name);
	TRACE(format,tkc_func, kc_l, tname, tkc_s1, tkc_s2, tname2, kc_op, tname3 );
    }
#ifdef _DEBUG
    if (AfxAssertFailedLine(kc_fn, kc_l))
#endif
	AfxDebugBreak();
#else
    if ((kc_op <= one_before_first_operator) || (kc_op >= last_operator)) {
	fprintf( stderr, "Internal Error: Assertion failed at %s:%d: illegal value for (%s) %s%s: %d not a valid operator\n",
	    kc_fn, kc_l, kc_phy, kc_str1, kc_str2, kc_op );
    } else {
	fprintf( stderr, "Internal Error: Assertion failed at %s:%d: illegal value for (%s) %s%s: %s (%d) is a value of %s\n",
	    kc_fn, kc_l, kc_phy, kc_str1, kc_str2, operator_info[kc_op].name, kc_op, phylum_info[operator_info[kc_op].phylum].name );
    }
#ifndef KC_ASSERT_NO_ABORT
    abort();
#else
    exit( 1 );
#endif
#endif
}

void kc_invalid_operator( const char *kc_func_prefix, enum_phyla kc_phy, int kc_line, const char *kc_file, enum_operators kc_oper )
{
    fflush(stdout);
#ifdef _AFX
    USES_CONVERSION;
    const _TCHAR* format=_T("Internal Error: invalid operator code in %s%s at %s:%d: %s\n");
    const _TCHAR* tkc_func=A2CT(kc_func_prefix);
    const _TCHAR* tkc_file=A2CT(kc_file);
    const _TCHAR* ts1=A2CT(phylumname_or_error( kc_phy ));
    const _TCHAR* ts2=A2CT(kc_operatorname_or_error( kc_oper ));
    TRACE( format, tkc_func, ts1, tkc_file, kc_line, ts2);
#ifdef _DEBUG
    if (AfxAssertFailedLine(kc_file, kc_line))
#endif
	AfxDebugBreak();
#else
    fprintf( stderr, "Internal Error: invalid operator code in %s%s at %s:%d: %s\n", kc_func_prefix, phylumname_or_error( kc_phy ), kc_file, kc_line, kc_operatorname_or_error( kc_oper ));
#ifndef KC_INVALID_OPERATOR_NO_ABORT
    abort();
#else
    exit( 1 );
#endif
#endif
}
const enum_phyla impl_nocasestring::phylum_sel_ = phylum_nocasestring;
const enum_phyla impl_casestring::phylum_sel_ = phylum_casestring;
const enum_phyla impl_real::phylum_sel_ = phylum_real;
impl_real__Real::impl_real__Real(REAL _value)
    : value(_value) { }
const enum_phyla impl_integer::phylum_sel_ = phylum_integer;
impl_integer__Int::impl_integer__Int(INTEGER _value)
    : value(_value) { }
const enum_phyla impl_voidptr::phylum_sel_ = phylum_voidptr;
impl_voidptr__VoidPtr::impl_voidptr__VoidPtr(void* _pointer)
    : pointer(_pointer) { }
const enum_phyla impl_tFormula::phylum_sel_ = phylum_tFormula;
impl_tFormula_StatePredicateFormula::impl_tFormula_StatePredicateFormula(tStatePredicate _tStatePredicate_1)
    : tStatePredicate_1(_tStatePredicate_1) { }
const enum_phyla impl_tStatePredicate::phylum_sel_ = phylum_tStatePredicate;
impl_tStatePredicate_DisjunctionList::impl_tStatePredicate_DisjunctionList(tDisjunction_list _tDisjunction_list_1)
    : tDisjunction_list_1(_tDisjunction_list_1) { }
impl_tStatePredicate_ConjunctionList::impl_tStatePredicate_ConjunctionList(tConjunction_list _tConjunction_list_1)
    : tConjunction_list_1(_tConjunction_list_1) { }
impl_tStatePredicate_EX::impl_tStatePredicate_EX(tStatePredicate _tStatePredicate_1)
    : tStatePredicate_1(_tStatePredicate_1) { }
impl_tStatePredicate_AX::impl_tStatePredicate_AX(tStatePredicate _tStatePredicate_1)
    : tStatePredicate_1(_tStatePredicate_1) { }
impl_tStatePredicate_EG::impl_tStatePredicate_EG(tStatePredicate _tStatePredicate_1)
    : tStatePredicate_1(_tStatePredicate_1) { }
impl_tStatePredicate_AG::impl_tStatePredicate_AG(tStatePredicate _tStatePredicate_1)
    : tStatePredicate_1(_tStatePredicate_1) { }
impl_tStatePredicate_EF::impl_tStatePredicate_EF(tStatePredicate _tStatePredicate_1)
    : tStatePredicate_1(_tStatePredicate_1) { }
impl_tStatePredicate_AF::impl_tStatePredicate_AF(tStatePredicate _tStatePredicate_1)
    : tStatePredicate_1(_tStatePredicate_1) { }
impl_tStatePredicate_ER::impl_tStatePredicate_ER(tStatePredicate _tStatePredicate_1, tStatePredicate _tStatePredicate_2)
    : tStatePredicate_1(_tStatePredicate_1), tStatePredicate_2(_tStatePredicate_2) { }
impl_tStatePredicate_AR::impl_tStatePredicate_AR(tStatePredicate _tStatePredicate_1, tStatePredicate _tStatePredicate_2)
    : tStatePredicate_1(_tStatePredicate_1), tStatePredicate_2(_tStatePredicate_2) { }
impl_tStatePredicate_EU::impl_tStatePredicate_EU(tStatePredicate _tStatePredicate_1, tStatePredicate _tStatePredicate_2)
    : tStatePredicate_1(_tStatePredicate_1), tStatePredicate_2(_tStatePredicate_2) { }
impl_tStatePredicate_AU::impl_tStatePredicate_AU(tStatePredicate _tStatePredicate_1, tStatePredicate _tStatePredicate_2)
    : tStatePredicate_1(_tStatePredicate_1), tStatePredicate_2(_tStatePredicate_2) { }
impl_tStatePredicate_Release::impl_tStatePredicate_Release(tStatePredicate _tStatePredicate_1, tStatePredicate _tStatePredicate_2)
    : tStatePredicate_1(_tStatePredicate_1), tStatePredicate_2(_tStatePredicate_2) { }
impl_tStatePredicate_Until::impl_tStatePredicate_Until(tStatePredicate _tStatePredicate_1, tStatePredicate _tStatePredicate_2)
    : tStatePredicate_1(_tStatePredicate_1), tStatePredicate_2(_tStatePredicate_2) { }
impl_tStatePredicate_NextState::impl_tStatePredicate_NextState(tStatePredicate _tStatePredicate_1)
    : tStatePredicate_1(_tStatePredicate_1) { }
impl_tStatePredicate_Eventually::impl_tStatePredicate_Eventually(tStatePredicate _tStatePredicate_1)
    : tStatePredicate_1(_tStatePredicate_1) { }
impl_tStatePredicate_Always::impl_tStatePredicate_Always(tStatePredicate _tStatePredicate_1)
    : tStatePredicate_1(_tStatePredicate_1) { }
impl_tStatePredicate_ExPath::impl_tStatePredicate_ExPath(tStatePredicate _tStatePredicate_1)
    : tStatePredicate_1(_tStatePredicate_1) { }
impl_tStatePredicate_AllPath::impl_tStatePredicate_AllPath(tStatePredicate _tStatePredicate_1)
    : tStatePredicate_1(_tStatePredicate_1) { }
impl_tStatePredicate_Equivalence::impl_tStatePredicate_Equivalence(tStatePredicate _tStatePredicate_1, tStatePredicate _tStatePredicate_2)
    : tStatePredicate_1(_tStatePredicate_1), tStatePredicate_2(_tStatePredicate_2) { }
impl_tStatePredicate_Implication::impl_tStatePredicate_Implication(tStatePredicate _tStatePredicate_1, tStatePredicate _tStatePredicate_2)
    : tStatePredicate_1(_tStatePredicate_1), tStatePredicate_2(_tStatePredicate_2) { }
impl_tStatePredicate_ExclusiveDisjunction::impl_tStatePredicate_ExclusiveDisjunction(tStatePredicate _tStatePredicate_1, tStatePredicate _tStatePredicate_2)
    : tStatePredicate_1(_tStatePredicate_1), tStatePredicate_2(_tStatePredicate_2) { }
impl_tStatePredicate_Disjunction::impl_tStatePredicate_Disjunction(tStatePredicate _tStatePredicate_1, tStatePredicate _tStatePredicate_2)
    : tStatePredicate_1(_tStatePredicate_1), tStatePredicate_2(_tStatePredicate_2) { }
impl_tStatePredicate_Conjunction::impl_tStatePredicate_Conjunction(tStatePredicate _tStatePredicate_1, tStatePredicate _tStatePredicate_2)
    : tStatePredicate_1(_tStatePredicate_1), tStatePredicate_2(_tStatePredicate_2) { }
impl_tStatePredicate_Negation::impl_tStatePredicate_Negation(tStatePredicate _tStatePredicate_1)
    : tStatePredicate_1(_tStatePredicate_1) { }
impl_tStatePredicate_AtomicProposition::impl_tStatePredicate_AtomicProposition(tAtomicProposition _tAtomicProposition_1)
    : tAtomicProposition_1(_tAtomicProposition_1) { }
const enum_phyla impl_tConjunction_list::phylum_sel_ = phylum_tConjunction_list;
impl_tConjunction_list::impl_tConjunction_list(tStatePredicate p1 , tConjunction_list p2)
    : tStatePredicate_1(p1), tConjunction_list_1(p2) { }
const enum_phyla impl_tDisjunction_list::phylum_sel_ = phylum_tDisjunction_list;
impl_tDisjunction_list::impl_tDisjunction_list(tStatePredicate p1 , tDisjunction_list p2)
    : tStatePredicate_1(p1), tDisjunction_list_1(p2) { }
const enum_phyla impl_tAtomicProposition::phylum_sel_ = phylum_tAtomicProposition;
impl_tAtomicProposition_Fireable::impl_tAtomicProposition_Fireable(integer _integer_1)
    : integer_1(_integer_1) { }
impl_tAtomicProposition_Initial::impl_tAtomicProposition_Initial()
    { }
impl_tAtomicProposition_Deadlock::impl_tAtomicProposition_Deadlock()
    { }
impl_tAtomicProposition_NoDeadlock::impl_tAtomicProposition_NoDeadlock()
    { }
impl_tAtomicProposition_False::impl_tAtomicProposition_False()
    { }
impl_tAtomicProposition_True::impl_tAtomicProposition_True()
    { }
impl_tAtomicProposition_LessEqualAtomicProposition::impl_tAtomicProposition_LessEqualAtomicProposition(tTerm _tTerm_1, tTerm _tTerm_2)
    : tTerm_1(_tTerm_1), tTerm_2(_tTerm_2) { }
impl_tAtomicProposition_LessAtomicProposition::impl_tAtomicProposition_LessAtomicProposition(tTerm _tTerm_1, tTerm _tTerm_2)
    : tTerm_1(_tTerm_1), tTerm_2(_tTerm_2) { }
impl_tAtomicProposition_GreaterEqualAtomicProposition::impl_tAtomicProposition_GreaterEqualAtomicProposition(tTerm _tTerm_1, tTerm _tTerm_2)
    : tTerm_1(_tTerm_1), tTerm_2(_tTerm_2) { }
impl_tAtomicProposition_GreaterAtomicProposition::impl_tAtomicProposition_GreaterAtomicProposition(tTerm _tTerm_1, tTerm _tTerm_2)
    : tTerm_1(_tTerm_1), tTerm_2(_tTerm_2) { }
impl_tAtomicProposition_NotEqualsAtomicProposition::impl_tAtomicProposition_NotEqualsAtomicProposition(tTerm _tTerm_1, tTerm _tTerm_2)
    : tTerm_1(_tTerm_1), tTerm_2(_tTerm_2) { }
impl_tAtomicProposition_EqualsAtomicProposition::impl_tAtomicProposition_EqualsAtomicProposition(tTerm _tTerm_1, tTerm _tTerm_2)
    : tTerm_1(_tTerm_1), tTerm_2(_tTerm_2) { }
const enum_phyla impl_tTerm::phylum_sel_ = phylum_tTerm;
impl_tTerm_ProductList::impl_tTerm_ProductList(tProduct_list _tProduct_list_1)
    : tProduct_list_1(_tProduct_list_1) { }
impl_tTerm_Product::impl_tTerm_Product(integer _integer_1, tTerm _tTerm_1)
    : integer_1(_integer_1), tTerm_1(_tTerm_1) { }
impl_tTerm_Difference::impl_tTerm_Difference(tTerm _tTerm_1, tTerm _tTerm_2)
    : tTerm_1(_tTerm_1), tTerm_2(_tTerm_2) { }
impl_tTerm_Sum::impl_tTerm_Sum(tTerm _tTerm_1, tTerm _tTerm_2)
    : tTerm_1(_tTerm_1), tTerm_2(_tTerm_2) { }
impl_tTerm_Number::impl_tTerm_Number(integer _integer_1)
    : integer_1(_integer_1) { }
impl_tTerm_Node::impl_tTerm_Node(integer _integer_1)
    : integer_1(_integer_1) { }
const enum_phyla impl_tProduct_list::phylum_sel_ = phylum_tProduct_list;
impl_tProduct_list::impl_tProduct_list(tTerm p1 , tProduct_list p2)
    : tTerm_1(p1), tProduct_list_1(p2) { }
const enum_phyla impl_tBuechiAutomata::phylum_sel_ = phylum_tBuechiAutomata;
impl_tBuechiAutomata_BuechiNull::impl_tBuechiAutomata_BuechiNull()
    { }
impl_tBuechiAutomata_BuechiAutomaton::impl_tBuechiAutomata_BuechiAutomaton(tBuechiRules _tBuechiRules_1, tAcceptingSet _tAcceptingSet_1)
    : tBuechiRules_1(_tBuechiRules_1), tAcceptingSet_1(_tAcceptingSet_1) { }
const enum_phyla impl_tBuechiRules::phylum_sel_ = phylum_tBuechiRules;
impl_tBuechiRules_BuechiRules::impl_tBuechiRules_BuechiRules(tBuechiRules _tBuechiRules_1, tBuechiRules _tBuechiRules_2)
    : tBuechiRules_1(_tBuechiRules_1), tBuechiRules_2(_tBuechiRules_2) { }
impl_tBuechiRules_ExpandedBuechiRule::impl_tBuechiRules_ExpandedBuechiRule(integer _integer_1, tFormula _tFormula_1, integer _integer_2)
    : integer_1(_integer_1), tFormula_1(_tFormula_1), integer_2(_integer_2) { }
impl_tBuechiRules_BuechiRule::impl_tBuechiRules_BuechiRule(integer _integer_1, tTransitionRules _tTransitionRules_1)
    : integer_1(_integer_1), tTransitionRules_1(_tTransitionRules_1) { }
impl_tBuechiRules_EmptyBuechiRules::impl_tBuechiRules_EmptyBuechiRules()
    { }
const enum_phyla impl_tTransitionRules::phylum_sel_ = phylum_tTransitionRules;
impl_tTransitionRules_TransitionRules::impl_tTransitionRules_TransitionRules(tTransitionRules _tTransitionRules_1, tTransitionRules _tTransitionRules_2)
    : tTransitionRules_1(_tTransitionRules_1), tTransitionRules_2(_tTransitionRules_2) { }
impl_tTransitionRules_TransitionRule::impl_tTransitionRules_TransitionRule(tFormula _tFormula_1, integer _integer_1)
    : tFormula_1(_tFormula_1), integer_1(_integer_1) { }
impl_tTransitionRules_EmptyTransitionRules::impl_tTransitionRules_EmptyTransitionRules()
    { }
const enum_phyla impl_tAcceptingSet::phylum_sel_ = phylum_tAcceptingSet;
impl_tAcceptingSet_AcceptingSet::impl_tAcceptingSet_AcceptingSet(tAcceptingSet _tAcceptingSet_1, tAcceptingSet _tAcceptingSet_2)
    : tAcceptingSet_1(_tAcceptingSet_1), tAcceptingSet_2(_tAcceptingSet_2) { }
impl_tAcceptingSet_AcceptingState::impl_tAcceptingSet_AcceptingState(integer _integer_1)
    : integer_1(_integer_1) { }
impl_tAcceptingSet_EmptyAcceptingSet::impl_tAcceptingSet_EmptyAcceptingSet()
    { }

#ifdef KC_STATISTICS
KC_OPERATOR_STATISTICS operator_statistics[KC_NO_OF_OPERATORS];
static int kc_casestring_strlen =0;
static int kc_nocasestring_strlen =0;
#  define KC_COLLECT_STATS0(v) v
#else
#  define KC_COLLECT_STATS0(v)
#endif

#ifndef KC_CREATE_STATS
#  define KC_CREATE_STATS(oper) operator_statistics[oper].created++;
#endif
#ifndef KC_EXISTINGNOTFOUND_STATS
#  define KC_EXISTINGNOTFOUND_STATS(oper) operator_statistics[oper].existing_not_found++;
#endif

#ifndef KC_FREE_CALLED_STATS
#  define KC_FREE_CALLED_STATS(oper,rec) operator_statistics[oper].free_called[(rec?true:false)]++;
#endif

#ifndef KC_FREED_STATS
#  define KC_FREED_STATS(oper,rec) operator_statistics[oper].freed[(rec?true:false)]++;
#endif
static hashtable_struct_t kc_not_uniq_static_hashtable;
static hashtable_struct_t uniq_static_hashtable;

bool kc_storageclass_still_uniq[] = {
    true, true };

hashtable_t hashtables[] = {
    &kc_not_uniq_static_hashtable,
    &uniq_static_hashtable,
};

const char* kc_storageclassnames[] = { "kc_not_uniq", "uniq" };

namespace { // all local to k.cc

tFormula kc_initialize_tFormula(tFormula kc_x)
{
#line 43 "Frontend/Parser/formula_abstract.k"
    kc_x->formula =  NULL;
#line 44 "Frontend/Parser/formula_abstract.k"
    kc_x->ctl_formula =  NULL;
#line 45 "Frontend/Parser/formula_abstract.k"
    kc_x->ltl_tree =  NULL;

#line  1694 "ast-system-k.cc"
    return kc_x;
}

tStatePredicate kc_initialize_tStatePredicate(tStatePredicate kc_x)
{
#line 78 "Frontend/Parser/formula_abstract.k"
    kc_x->containsTemporal =  false;
#line 80 "Frontend/Parser/formula_abstract.k"
    kc_x->validCTLPathFormula =  false;
#line 82 "Frontend/Parser/formula_abstract.k"
    kc_x->validCTLStateFormula =  false;
#line 84 "Frontend/Parser/formula_abstract.k"
    kc_x->validLTLFormula =  false;
#line 85 "Frontend/Parser/formula_abstract.k"
    kc_x->priority =  0;

#line  1711 "ast-system-k.cc"
    return kc_x;
}


} // namespace

enum_phyla
impl_abstract_phylum::phylum() const {
    return operator_info[prod_sel()].phylum;
}

const char*
impl_abstract_phylum::phylum_name() const {
    return phylum_info[phylum()].name;
}

const char*
impl_abstract_phylum::op_name() const {
    return operator_info[prod_sel()].name;
}

casestring
mkcasestring(const kc_char_t *kc_s, int length)
{
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel__Str));

    casestring kc_x=new impl_casestring__Str(kc_s);
    if(length>=0) 
	kc_x->make_own(length);

    casestring unique_kc_x=hashtables[uniq]->ht_check_insert((casestring)kc_x);
    if(unique_kc_x!=kc_x) {
	if(length<0) 
	    kc_x->name=0;

	delete kc_x;
	kc_x=unique_kc_x;
    } else {
	KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel__Str));
	if(length<0) 
	    kc_x->make_own(static_cast<int>(kc_strlen(kc_s)));

	kc_x->post_create();
    }
    return kc_x;
}

nocasestring
mknocasestring(const kc_char_t *kc_s, int length)
{
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_NoCaseStr));

    nocasestring kc_x=new impl_nocasestring_NoCaseStr(kc_s);
    if(length>=0)
	kc_x->make_own(length);
    nocasestring unique_kc_x=hashtables[uniq]->ht_check_insert((nocasestring)kc_x);
    if(unique_kc_x!=kc_x) {
	if(length<0)
	    kc_x->name=0;
	delete kc_x;
	kc_x=unique_kc_x;
    } else {
	KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_NoCaseStr));
	if(length<0)
	    kc_x->make_own(static_cast<int>(kc_strlen(kc_s)));
	kc_x->post_create();
    }

    return kc_x;
}

integer
mkinteger(const INTEGER kc_i)
{
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel__Int));

    integer kc_x =new impl_integer__Int(kc_i);
    integer unique_kc_x=hashtables[uniq]->ht_check_insert(kc_x);
    if(unique_kc_x!=kc_x) {
	delete kc_x;
	kc_x=unique_kc_x;
    } else {
	KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel__Int));
	kc_x->post_create();
    }

    return kc_x;
}

real
mkreal(const REAL kc_r)
{
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel__Real));

    real kc_x=new impl_real__Real(kc_r);
    real unique_kc_x=hashtables[uniq]->ht_check_insert(kc_x);
    if(unique_kc_x!=kc_x) {
	delete kc_x;
	kc_x=unique_kc_x;
    } else {
	KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel__Real));
	kc_x->post_create();
    }

    return kc_x;
}

voidptr
mkvoidptr(void *kc_p)
{
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel__VoidPtr));
    voidptr kc_x=new impl_voidptr__VoidPtr(kc_p);
    voidptr unique_kc_x=hashtables[uniq]->ht_check_insert(kc_x);
    if(unique_kc_x!=kc_x) {
	delete kc_x;
	kc_x=unique_kc_x;
    } else {
	KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel__VoidPtr));
	kc_x->post_create();
    }
    return kc_x;
}

impl_tFormula_StatePredicateFormula*
StatePredicateFormula(tStatePredicate _tStatePredicate_1) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    tFormula kc_x = new impl_tFormula_StatePredicateFormula(_tStatePredicate_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_StatePredicateFormula));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_StatePredicateFormula));
    kc_x->post_create();
    kc_x = kc_initialize_tFormula(kc_x);
    return static_cast<impl_tFormula_StatePredicateFormula*>(kc_x);
}

impl_tStatePredicate_AtomicProposition*
AtomicProposition(tAtomicProposition _tAtomicProposition_1) {
    assertPhylum(_tAtomicProposition_1, phylum_tAtomicProposition);
    tStatePredicate kc_x = new impl_tStatePredicate_AtomicProposition(_tAtomicProposition_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_AtomicProposition));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_AtomicProposition));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_AtomicProposition*>(kc_x);
}

impl_tStatePredicate_Negation*
Negation(tStatePredicate _tStatePredicate_1) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    tStatePredicate kc_x = new impl_tStatePredicate_Negation(_tStatePredicate_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Negation));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Negation));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_Negation*>(kc_x);
}

impl_tStatePredicate_Conjunction*
Conjunction(tStatePredicate _tStatePredicate_1, tStatePredicate _tStatePredicate_2) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    assertPhylum(_tStatePredicate_2, phylum_tStatePredicate);
    tStatePredicate kc_x = new impl_tStatePredicate_Conjunction(_tStatePredicate_1, _tStatePredicate_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Conjunction));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Conjunction));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_Conjunction*>(kc_x);
}

impl_tStatePredicate_Disjunction*
Disjunction(tStatePredicate _tStatePredicate_1, tStatePredicate _tStatePredicate_2) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    assertPhylum(_tStatePredicate_2, phylum_tStatePredicate);
    tStatePredicate kc_x = new impl_tStatePredicate_Disjunction(_tStatePredicate_1, _tStatePredicate_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Disjunction));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Disjunction));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_Disjunction*>(kc_x);
}

impl_tStatePredicate_ExclusiveDisjunction*
ExclusiveDisjunction(tStatePredicate _tStatePredicate_1, tStatePredicate _tStatePredicate_2) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    assertPhylum(_tStatePredicate_2, phylum_tStatePredicate);
    tStatePredicate kc_x = new impl_tStatePredicate_ExclusiveDisjunction(_tStatePredicate_1, _tStatePredicate_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExclusiveDisjunction));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExclusiveDisjunction));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_ExclusiveDisjunction*>(kc_x);
}

impl_tStatePredicate_Implication*
Implication(tStatePredicate _tStatePredicate_1, tStatePredicate _tStatePredicate_2) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    assertPhylum(_tStatePredicate_2, phylum_tStatePredicate);
    tStatePredicate kc_x = new impl_tStatePredicate_Implication(_tStatePredicate_1, _tStatePredicate_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Implication));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Implication));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_Implication*>(kc_x);
}

impl_tStatePredicate_Equivalence*
Equivalence(tStatePredicate _tStatePredicate_1, tStatePredicate _tStatePredicate_2) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    assertPhylum(_tStatePredicate_2, phylum_tStatePredicate);
    tStatePredicate kc_x = new impl_tStatePredicate_Equivalence(_tStatePredicate_1, _tStatePredicate_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Equivalence));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Equivalence));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_Equivalence*>(kc_x);
}

impl_tStatePredicate_AllPath*
AllPath(tStatePredicate _tStatePredicate_1) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    tStatePredicate kc_x = new impl_tStatePredicate_AllPath(_tStatePredicate_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_AllPath));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_AllPath));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_AllPath*>(kc_x);
}

impl_tStatePredicate_ExPath*
ExPath(tStatePredicate _tStatePredicate_1) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    tStatePredicate kc_x = new impl_tStatePredicate_ExPath(_tStatePredicate_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExPath));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExPath));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_ExPath*>(kc_x);
}

impl_tStatePredicate_Always*
Always(tStatePredicate _tStatePredicate_1) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    tStatePredicate kc_x = new impl_tStatePredicate_Always(_tStatePredicate_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Always));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Always));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_Always*>(kc_x);
}

impl_tStatePredicate_Eventually*
Eventually(tStatePredicate _tStatePredicate_1) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    tStatePredicate kc_x = new impl_tStatePredicate_Eventually(_tStatePredicate_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Eventually));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Eventually));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_Eventually*>(kc_x);
}

impl_tStatePredicate_NextState*
NextState(tStatePredicate _tStatePredicate_1) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    tStatePredicate kc_x = new impl_tStatePredicate_NextState(_tStatePredicate_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_NextState));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_NextState));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_NextState*>(kc_x);
}

impl_tStatePredicate_Until*
Until(tStatePredicate _tStatePredicate_1, tStatePredicate _tStatePredicate_2) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    assertPhylum(_tStatePredicate_2, phylum_tStatePredicate);
    tStatePredicate kc_x = new impl_tStatePredicate_Until(_tStatePredicate_1, _tStatePredicate_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Until));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Until));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_Until*>(kc_x);
}

impl_tStatePredicate_Release*
Release(tStatePredicate _tStatePredicate_1, tStatePredicate _tStatePredicate_2) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    assertPhylum(_tStatePredicate_2, phylum_tStatePredicate);
    tStatePredicate kc_x = new impl_tStatePredicate_Release(_tStatePredicate_1, _tStatePredicate_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Release));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Release));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_Release*>(kc_x);
}

impl_tStatePredicate_AU*
AU(tStatePredicate _tStatePredicate_1, tStatePredicate _tStatePredicate_2) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    assertPhylum(_tStatePredicate_2, phylum_tStatePredicate);
    tStatePredicate kc_x = new impl_tStatePredicate_AU(_tStatePredicate_1, _tStatePredicate_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_AU));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_AU));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_AU*>(kc_x);
}

impl_tStatePredicate_EU*
EU(tStatePredicate _tStatePredicate_1, tStatePredicate _tStatePredicate_2) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    assertPhylum(_tStatePredicate_2, phylum_tStatePredicate);
    tStatePredicate kc_x = new impl_tStatePredicate_EU(_tStatePredicate_1, _tStatePredicate_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EU));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EU));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_EU*>(kc_x);
}

impl_tStatePredicate_AR*
AR(tStatePredicate _tStatePredicate_1, tStatePredicate _tStatePredicate_2) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    assertPhylum(_tStatePredicate_2, phylum_tStatePredicate);
    tStatePredicate kc_x = new impl_tStatePredicate_AR(_tStatePredicate_1, _tStatePredicate_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_AR));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_AR));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_AR*>(kc_x);
}

impl_tStatePredicate_ER*
ER(tStatePredicate _tStatePredicate_1, tStatePredicate _tStatePredicate_2) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    assertPhylum(_tStatePredicate_2, phylum_tStatePredicate);
    tStatePredicate kc_x = new impl_tStatePredicate_ER(_tStatePredicate_1, _tStatePredicate_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ER));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ER));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_ER*>(kc_x);
}

impl_tStatePredicate_AF*
AF(tStatePredicate _tStatePredicate_1) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    tStatePredicate kc_x = new impl_tStatePredicate_AF(_tStatePredicate_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_AF));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_AF));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_AF*>(kc_x);
}

impl_tStatePredicate_EF*
EF(tStatePredicate _tStatePredicate_1) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    tStatePredicate kc_x = new impl_tStatePredicate_EF(_tStatePredicate_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EF));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EF));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_EF*>(kc_x);
}

impl_tStatePredicate_AG*
AG(tStatePredicate _tStatePredicate_1) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    tStatePredicate kc_x = new impl_tStatePredicate_AG(_tStatePredicate_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_AG));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_AG));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_AG*>(kc_x);
}

impl_tStatePredicate_EG*
EG(tStatePredicate _tStatePredicate_1) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    tStatePredicate kc_x = new impl_tStatePredicate_EG(_tStatePredicate_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EG));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EG));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_EG*>(kc_x);
}

impl_tStatePredicate_AX*
AX(tStatePredicate _tStatePredicate_1) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    tStatePredicate kc_x = new impl_tStatePredicate_AX(_tStatePredicate_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_AX));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_AX));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_AX*>(kc_x);
}

impl_tStatePredicate_EX*
EX(tStatePredicate _tStatePredicate_1) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    tStatePredicate kc_x = new impl_tStatePredicate_EX(_tStatePredicate_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EX));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EX));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_EX*>(kc_x);
}

impl_tStatePredicate_ConjunctionList*
ConjunctionList(tConjunction_list _tConjunction_list_1) {
    assertPhylum(_tConjunction_list_1, phylum_tConjunction_list);
    tStatePredicate kc_x = new impl_tStatePredicate_ConjunctionList(_tConjunction_list_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ConjunctionList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ConjunctionList));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_ConjunctionList*>(kc_x);
}

impl_tStatePredicate_DisjunctionList*
DisjunctionList(tDisjunction_list _tDisjunction_list_1) {
    assertPhylum(_tDisjunction_list_1, phylum_tDisjunction_list);
    tStatePredicate kc_x = new impl_tStatePredicate_DisjunctionList(_tDisjunction_list_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_DisjunctionList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_DisjunctionList));
    kc_x->post_create();
    kc_x = kc_initialize_tStatePredicate(kc_x);
    return static_cast<impl_tStatePredicate_DisjunctionList*>(kc_x);
}

impl_tConjunction_list*
NiltConjunction_list() {
    tConjunction_list kc_x = new impl_tConjunction_list();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_NiltConjunction_list));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_NiltConjunction_list));
    kc_x->post_create();
    return static_cast<impl_tConjunction_list*>(kc_x);
}

impl_tConjunction_list*
ConstConjunction_list(tStatePredicate _tStatePredicate_1, tConjunction_list _tConjunction_list_1) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    assertPhylum(_tConjunction_list_1, phylum_tConjunction_list);
    tConjunction_list kc_x = new impl_tConjunction_list(_tStatePredicate_1, _tConjunction_list_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ConstConjunction_list));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ConstConjunction_list));
    kc_x->post_create();
    return static_cast<impl_tConjunction_list*>(kc_x);
}

impl_tDisjunction_list*
NiltDisjunction_list() {
    tDisjunction_list kc_x = new impl_tDisjunction_list();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_NiltDisjunction_list));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_NiltDisjunction_list));
    kc_x->post_create();
    return static_cast<impl_tDisjunction_list*>(kc_x);
}

impl_tDisjunction_list*
ConstDisjunction_list(tStatePredicate _tStatePredicate_1, tDisjunction_list _tDisjunction_list_1) {
    assertPhylum(_tStatePredicate_1, phylum_tStatePredicate);
    assertPhylum(_tDisjunction_list_1, phylum_tDisjunction_list);
    tDisjunction_list kc_x = new impl_tDisjunction_list(_tStatePredicate_1, _tDisjunction_list_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ConstDisjunction_list));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ConstDisjunction_list));
    kc_x->post_create();
    return static_cast<impl_tDisjunction_list*>(kc_x);
}

impl_tAtomicProposition_EqualsAtomicProposition*
EqualsAtomicProposition(tTerm _tTerm_1, tTerm _tTerm_2) {
    assertPhylum(_tTerm_1, phylum_tTerm);
    assertPhylum(_tTerm_2, phylum_tTerm);
    tAtomicProposition kc_x = new impl_tAtomicProposition_EqualsAtomicProposition(_tTerm_1, _tTerm_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EqualsAtomicProposition));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EqualsAtomicProposition));
    kc_x->post_create();
    return static_cast<impl_tAtomicProposition_EqualsAtomicProposition*>(kc_x);
}

impl_tAtomicProposition_NotEqualsAtomicProposition*
NotEqualsAtomicProposition(tTerm _tTerm_1, tTerm _tTerm_2) {
    assertPhylum(_tTerm_1, phylum_tTerm);
    assertPhylum(_tTerm_2, phylum_tTerm);
    tAtomicProposition kc_x = new impl_tAtomicProposition_NotEqualsAtomicProposition(_tTerm_1, _tTerm_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_NotEqualsAtomicProposition));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_NotEqualsAtomicProposition));
    kc_x->post_create();
    return static_cast<impl_tAtomicProposition_NotEqualsAtomicProposition*>(kc_x);
}

impl_tAtomicProposition_GreaterAtomicProposition*
GreaterAtomicProposition(tTerm _tTerm_1, tTerm _tTerm_2) {
    assertPhylum(_tTerm_1, phylum_tTerm);
    assertPhylum(_tTerm_2, phylum_tTerm);
    tAtomicProposition kc_x = new impl_tAtomicProposition_GreaterAtomicProposition(_tTerm_1, _tTerm_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_GreaterAtomicProposition));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_GreaterAtomicProposition));
    kc_x->post_create();
    return static_cast<impl_tAtomicProposition_GreaterAtomicProposition*>(kc_x);
}

impl_tAtomicProposition_GreaterEqualAtomicProposition*
GreaterEqualAtomicProposition(tTerm _tTerm_1, tTerm _tTerm_2) {
    assertPhylum(_tTerm_1, phylum_tTerm);
    assertPhylum(_tTerm_2, phylum_tTerm);
    tAtomicProposition kc_x = new impl_tAtomicProposition_GreaterEqualAtomicProposition(_tTerm_1, _tTerm_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_GreaterEqualAtomicProposition));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_GreaterEqualAtomicProposition));
    kc_x->post_create();
    return static_cast<impl_tAtomicProposition_GreaterEqualAtomicProposition*>(kc_x);
}

impl_tAtomicProposition_LessAtomicProposition*
LessAtomicProposition(tTerm _tTerm_1, tTerm _tTerm_2) {
    assertPhylum(_tTerm_1, phylum_tTerm);
    assertPhylum(_tTerm_2, phylum_tTerm);
    tAtomicProposition kc_x = new impl_tAtomicProposition_LessAtomicProposition(_tTerm_1, _tTerm_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_LessAtomicProposition));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_LessAtomicProposition));
    kc_x->post_create();
    return static_cast<impl_tAtomicProposition_LessAtomicProposition*>(kc_x);
}

impl_tAtomicProposition_LessEqualAtomicProposition*
LessEqualAtomicProposition(tTerm _tTerm_1, tTerm _tTerm_2) {
    assertPhylum(_tTerm_1, phylum_tTerm);
    assertPhylum(_tTerm_2, phylum_tTerm);
    tAtomicProposition kc_x = new impl_tAtomicProposition_LessEqualAtomicProposition(_tTerm_1, _tTerm_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_LessEqualAtomicProposition));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_LessEqualAtomicProposition));
    kc_x->post_create();
    return static_cast<impl_tAtomicProposition_LessEqualAtomicProposition*>(kc_x);
}

impl_tAtomicProposition_True*
True() {
    tAtomicProposition kc_x = new impl_tAtomicProposition_True();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_True));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_True));
    kc_x->post_create();
    return static_cast<impl_tAtomicProposition_True*>(kc_x);
}

impl_tAtomicProposition_False*
False() {
    tAtomicProposition kc_x = new impl_tAtomicProposition_False();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_False));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_False));
    kc_x->post_create();
    return static_cast<impl_tAtomicProposition_False*>(kc_x);
}

impl_tAtomicProposition_NoDeadlock*
NoDeadlock() {
    tAtomicProposition kc_x = new impl_tAtomicProposition_NoDeadlock();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_NoDeadlock));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_NoDeadlock));
    kc_x->post_create();
    return static_cast<impl_tAtomicProposition_NoDeadlock*>(kc_x);
}

impl_tAtomicProposition_Deadlock*
Deadlock() {
    tAtomicProposition kc_x = new impl_tAtomicProposition_Deadlock();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Deadlock));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Deadlock));
    kc_x->post_create();
    return static_cast<impl_tAtomicProposition_Deadlock*>(kc_x);
}

impl_tAtomicProposition_Initial*
Initial() {
    tAtomicProposition kc_x = new impl_tAtomicProposition_Initial();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Initial));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Initial));
    kc_x->post_create();
    return static_cast<impl_tAtomicProposition_Initial*>(kc_x);
}

impl_tAtomicProposition_Fireable*
Fireable(integer _integer_1) {
    assertPhylum(_integer_1, phylum_integer);
    tAtomicProposition kc_x = new impl_tAtomicProposition_Fireable(_integer_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Fireable));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Fireable));
    kc_x->post_create();
    return static_cast<impl_tAtomicProposition_Fireable*>(kc_x);
}

impl_tTerm_Node*
Node(integer _integer_1) {
    assertPhylum(_integer_1, phylum_integer);
    tTerm kc_x = new impl_tTerm_Node(_integer_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Node));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Node));
    kc_x->post_create();
    return static_cast<impl_tTerm_Node*>(kc_x);
}

impl_tTerm_Number*
Number(integer _integer_1) {
    assertPhylum(_integer_1, phylum_integer);
    tTerm kc_x = new impl_tTerm_Number(_integer_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Number));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Number));
    kc_x->post_create();
    return static_cast<impl_tTerm_Number*>(kc_x);
}

impl_tTerm_Sum*
Sum(tTerm _tTerm_1, tTerm _tTerm_2) {
    assertPhylum(_tTerm_1, phylum_tTerm);
    assertPhylum(_tTerm_2, phylum_tTerm);
    tTerm kc_x = new impl_tTerm_Sum(_tTerm_1, _tTerm_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Sum));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Sum));
    kc_x->post_create();
    return static_cast<impl_tTerm_Sum*>(kc_x);
}

impl_tTerm_Difference*
Difference(tTerm _tTerm_1, tTerm _tTerm_2) {
    assertPhylum(_tTerm_1, phylum_tTerm);
    assertPhylum(_tTerm_2, phylum_tTerm);
    tTerm kc_x = new impl_tTerm_Difference(_tTerm_1, _tTerm_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Difference));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Difference));
    kc_x->post_create();
    return static_cast<impl_tTerm_Difference*>(kc_x);
}

impl_tTerm_Product*
Product(integer _integer_1, tTerm _tTerm_1) {
    assertPhylum(_integer_1, phylum_integer);
    assertPhylum(_tTerm_1, phylum_tTerm);
    tTerm kc_x = new impl_tTerm_Product(_integer_1, _tTerm_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_Product));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_Product));
    kc_x->post_create();
    return static_cast<impl_tTerm_Product*>(kc_x);
}

impl_tTerm_ProductList*
ProductList(tProduct_list _tProduct_list_1) {
    assertPhylum(_tProduct_list_1, phylum_tProduct_list);
    tTerm kc_x = new impl_tTerm_ProductList(_tProduct_list_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ProductList));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ProductList));
    kc_x->post_create();
    return static_cast<impl_tTerm_ProductList*>(kc_x);
}

impl_tProduct_list*
NiltProduct_list() {
    tProduct_list kc_x = new impl_tProduct_list();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_NiltProduct_list));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_NiltProduct_list));
    kc_x->post_create();
    return static_cast<impl_tProduct_list*>(kc_x);
}

impl_tProduct_list*
ConstProduct_list(tTerm _tTerm_1, tProduct_list _tProduct_list_1) {
    assertPhylum(_tTerm_1, phylum_tTerm);
    assertPhylum(_tProduct_list_1, phylum_tProduct_list);
    tProduct_list kc_x = new impl_tProduct_list(_tTerm_1, _tProduct_list_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ConstProduct_list));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ConstProduct_list));
    kc_x->post_create();
    return static_cast<impl_tProduct_list*>(kc_x);
}

impl_tBuechiAutomata_BuechiAutomaton*
BuechiAutomaton(tBuechiRules _tBuechiRules_1, tAcceptingSet _tAcceptingSet_1) {
    assertPhylum(_tBuechiRules_1, phylum_tBuechiRules);
    assertPhylum(_tAcceptingSet_1, phylum_tAcceptingSet);
    tBuechiAutomata kc_x = new impl_tBuechiAutomata_BuechiAutomaton(_tBuechiRules_1, _tAcceptingSet_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_BuechiAutomaton));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_BuechiAutomaton));
    kc_x->post_create();
    return static_cast<impl_tBuechiAutomata_BuechiAutomaton*>(kc_x);
}

impl_tBuechiAutomata_BuechiNull*
BuechiNull() {
    tBuechiAutomata kc_x = new impl_tBuechiAutomata_BuechiNull();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_BuechiNull));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_BuechiNull));
    kc_x->post_create();
    return static_cast<impl_tBuechiAutomata_BuechiNull*>(kc_x);
}

impl_tBuechiRules_EmptyBuechiRules*
EmptyBuechiRules() {
    tBuechiRules kc_x = new impl_tBuechiRules_EmptyBuechiRules();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptyBuechiRules));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptyBuechiRules));
    kc_x->post_create();
    return static_cast<impl_tBuechiRules_EmptyBuechiRules*>(kc_x);
}

impl_tBuechiRules_BuechiRule*
BuechiRule(integer _integer_1, tTransitionRules _tTransitionRules_1) {
    assertPhylum(_integer_1, phylum_integer);
    assertPhylum(_tTransitionRules_1, phylum_tTransitionRules);
    tBuechiRules kc_x = new impl_tBuechiRules_BuechiRule(_integer_1, _tTransitionRules_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_BuechiRule));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_BuechiRule));
    kc_x->post_create();
    return static_cast<impl_tBuechiRules_BuechiRule*>(kc_x);
}

impl_tBuechiRules_ExpandedBuechiRule*
ExpandedBuechiRule(integer _integer_1, tFormula _tFormula_1, integer _integer_2) {
    assertPhylum(_integer_1, phylum_integer);
    assertPhylum(_tFormula_1, phylum_tFormula);
    assertPhylum(_integer_2, phylum_integer);
    tBuechiRules kc_x = new impl_tBuechiRules_ExpandedBuechiRule(_integer_1, _tFormula_1, _integer_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_ExpandedBuechiRule));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_ExpandedBuechiRule));
    kc_x->post_create();
    return static_cast<impl_tBuechiRules_ExpandedBuechiRule*>(kc_x);
}

impl_tBuechiRules_BuechiRules*
BuechiRules(tBuechiRules _tBuechiRules_1, tBuechiRules _tBuechiRules_2) {
    assertPhylum(_tBuechiRules_1, phylum_tBuechiRules);
    assertPhylum(_tBuechiRules_2, phylum_tBuechiRules);
    tBuechiRules kc_x = new impl_tBuechiRules_BuechiRules(_tBuechiRules_1, _tBuechiRules_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_BuechiRules));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_BuechiRules));
    kc_x->post_create();
    return static_cast<impl_tBuechiRules_BuechiRules*>(kc_x);
}

impl_tTransitionRules_EmptyTransitionRules*
EmptyTransitionRules() {
    tTransitionRules kc_x = new impl_tTransitionRules_EmptyTransitionRules();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptyTransitionRules));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptyTransitionRules));
    kc_x->post_create();
    return static_cast<impl_tTransitionRules_EmptyTransitionRules*>(kc_x);
}

impl_tTransitionRules_TransitionRule*
TransitionRule(tFormula _tFormula_1, integer _integer_1) {
    assertPhylum(_tFormula_1, phylum_tFormula);
    assertPhylum(_integer_1, phylum_integer);
    tTransitionRules kc_x = new impl_tTransitionRules_TransitionRule(_tFormula_1, _integer_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_TransitionRule));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_TransitionRule));
    kc_x->post_create();
    return static_cast<impl_tTransitionRules_TransitionRule*>(kc_x);
}

impl_tTransitionRules_TransitionRules*
TransitionRules(tTransitionRules _tTransitionRules_1, tTransitionRules _tTransitionRules_2) {
    assertPhylum(_tTransitionRules_1, phylum_tTransitionRules);
    assertPhylum(_tTransitionRules_2, phylum_tTransitionRules);
    tTransitionRules kc_x = new impl_tTransitionRules_TransitionRules(_tTransitionRules_1, _tTransitionRules_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_TransitionRules));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_TransitionRules));
    kc_x->post_create();
    return static_cast<impl_tTransitionRules_TransitionRules*>(kc_x);
}

impl_tAcceptingSet_EmptyAcceptingSet*
EmptyAcceptingSet() {
    tAcceptingSet kc_x = new impl_tAcceptingSet_EmptyAcceptingSet();
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_EmptyAcceptingSet));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_EmptyAcceptingSet));
    kc_x->post_create();
    return static_cast<impl_tAcceptingSet_EmptyAcceptingSet*>(kc_x);
}

impl_tAcceptingSet_AcceptingState*
AcceptingState(integer _integer_1) {
    assertPhylum(_integer_1, phylum_integer);
    tAcceptingSet kc_x = new impl_tAcceptingSet_AcceptingState(_integer_1);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_AcceptingState));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_AcceptingState));
    kc_x->post_create();
    return static_cast<impl_tAcceptingSet_AcceptingState*>(kc_x);
}

impl_tAcceptingSet_AcceptingSet*
AcceptingSet(tAcceptingSet _tAcceptingSet_1, tAcceptingSet _tAcceptingSet_2) {
    assertPhylum(_tAcceptingSet_1, phylum_tAcceptingSet);
    assertPhylum(_tAcceptingSet_2, phylum_tAcceptingSet);
    tAcceptingSet kc_x = new impl_tAcceptingSet_AcceptingSet(_tAcceptingSet_1, _tAcceptingSet_2);
    KC_COLLECT_STATS0(KC_CREATE_STATS(sel_AcceptingSet));
    KC_COLLECT_STATS0(KC_EXISTINGNOTFOUND_STATS(sel_AcceptingSet));
    kc_x->post_create();
    return static_cast<impl_tAcceptingSet_AcceptingSet*>(kc_x);
}


abstract_phylum
kc_create(enum_operators createOp, abstract_phylum kc_p1, abstract_phylum kc_p2, abstract_phylum kc_p3)
{
    switch(createOp) {
    case sel__VoidPtr:
    case sel__Int:
    case sel__Real:
    case sel__Str:
    case sel_NoCaseStr:
	assertionFailed("Cannot create this kind of phylum - predefined phyla must be handled seperately");break;
    case sel_AcceptingSet:
	return AcceptingSet(phylum_cast<tAcceptingSet>(kc_p1), phylum_cast<tAcceptingSet>(kc_p2));
    case sel_AcceptingState:
	return AcceptingState(phylum_cast<integer>(kc_p1));
    case sel_EmptyAcceptingSet:
	return EmptyAcceptingSet();
    case sel_TransitionRules:
	return TransitionRules(phylum_cast<tTransitionRules>(kc_p1), phylum_cast<tTransitionRules>(kc_p2));
    case sel_TransitionRule:
	return TransitionRule(phylum_cast<tFormula>(kc_p1), phylum_cast<integer>(kc_p2));
    case sel_EmptyTransitionRules:
	return EmptyTransitionRules();
    case sel_BuechiRules:
	return BuechiRules(phylum_cast<tBuechiRules>(kc_p1), phylum_cast<tBuechiRules>(kc_p2));
    case sel_ExpandedBuechiRule:
	return ExpandedBuechiRule(phylum_cast<integer>(kc_p1), phylum_cast<tFormula>(kc_p2), phylum_cast<integer>(kc_p3));
    case sel_BuechiRule:
	return BuechiRule(phylum_cast<integer>(kc_p1), phylum_cast<tTransitionRules>(kc_p2));
    case sel_EmptyBuechiRules:
	return EmptyBuechiRules();
    case sel_BuechiNull:
	return BuechiNull();
    case sel_BuechiAutomaton:
	return BuechiAutomaton(phylum_cast<tBuechiRules>(kc_p1), phylum_cast<tAcceptingSet>(kc_p2));
    case sel_ConstProduct_list:
	return ConstProduct_list(phylum_cast<tTerm>(kc_p1), phylum_cast<tProduct_list>(kc_p2));
    case sel_NiltProduct_list:
	return NiltProduct_list();
    case sel_ProductList:
	return ProductList(phylum_cast<tProduct_list>(kc_p1));
    case sel_Product:
	return Product(phylum_cast<integer>(kc_p1), phylum_cast<tTerm>(kc_p2));
    case sel_Difference:
	return Difference(phylum_cast<tTerm>(kc_p1), phylum_cast<tTerm>(kc_p2));
    case sel_Sum:
	return Sum(phylum_cast<tTerm>(kc_p1), phylum_cast<tTerm>(kc_p2));
    case sel_Number:
	return Number(phylum_cast<integer>(kc_p1));
    case sel_Node:
	return Node(phylum_cast<integer>(kc_p1));
    case sel_Fireable:
	return Fireable(phylum_cast<integer>(kc_p1));
    case sel_Initial:
	return Initial();
    case sel_Deadlock:
	return Deadlock();
    case sel_NoDeadlock:
	return NoDeadlock();
    case sel_False:
	return False();
    case sel_True:
	return True();
    case sel_LessEqualAtomicProposition:
	return LessEqualAtomicProposition(phylum_cast<tTerm>(kc_p1), phylum_cast<tTerm>(kc_p2));
    case sel_LessAtomicProposition:
	return LessAtomicProposition(phylum_cast<tTerm>(kc_p1), phylum_cast<tTerm>(kc_p2));
    case sel_GreaterEqualAtomicProposition:
	return GreaterEqualAtomicProposition(phylum_cast<tTerm>(kc_p1), phylum_cast<tTerm>(kc_p2));
    case sel_GreaterAtomicProposition:
	return GreaterAtomicProposition(phylum_cast<tTerm>(kc_p1), phylum_cast<tTerm>(kc_p2));
    case sel_NotEqualsAtomicProposition:
	return NotEqualsAtomicProposition(phylum_cast<tTerm>(kc_p1), phylum_cast<tTerm>(kc_p2));
    case sel_EqualsAtomicProposition:
	return EqualsAtomicProposition(phylum_cast<tTerm>(kc_p1), phylum_cast<tTerm>(kc_p2));
    case sel_ConstDisjunction_list:
	return ConstDisjunction_list(phylum_cast<tStatePredicate>(kc_p1), phylum_cast<tDisjunction_list>(kc_p2));
    case sel_NiltDisjunction_list:
	return NiltDisjunction_list();
    case sel_ConstConjunction_list:
	return ConstConjunction_list(phylum_cast<tStatePredicate>(kc_p1), phylum_cast<tConjunction_list>(kc_p2));
    case sel_NiltConjunction_list:
	return NiltConjunction_list();
    case sel_DisjunctionList:
	return DisjunctionList(phylum_cast<tDisjunction_list>(kc_p1));
    case sel_ConjunctionList:
	return ConjunctionList(phylum_cast<tConjunction_list>(kc_p1));
    case sel_EX:
	return EX(phylum_cast<tStatePredicate>(kc_p1));
    case sel_AX:
	return AX(phylum_cast<tStatePredicate>(kc_p1));
    case sel_EG:
	return EG(phylum_cast<tStatePredicate>(kc_p1));
    case sel_AG:
	return AG(phylum_cast<tStatePredicate>(kc_p1));
    case sel_EF:
	return EF(phylum_cast<tStatePredicate>(kc_p1));
    case sel_AF:
	return AF(phylum_cast<tStatePredicate>(kc_p1));
    case sel_ER:
	return ER(phylum_cast<tStatePredicate>(kc_p1), phylum_cast<tStatePredicate>(kc_p2));
    case sel_AR:
	return AR(phylum_cast<tStatePredicate>(kc_p1), phylum_cast<tStatePredicate>(kc_p2));
    case sel_EU:
	return EU(phylum_cast<tStatePredicate>(kc_p1), phylum_cast<tStatePredicate>(kc_p2));
    case sel_AU:
	return AU(phylum_cast<tStatePredicate>(kc_p1), phylum_cast<tStatePredicate>(kc_p2));
    case sel_Release:
	return Release(phylum_cast<tStatePredicate>(kc_p1), phylum_cast<tStatePredicate>(kc_p2));
    case sel_Until:
	return Until(phylum_cast<tStatePredicate>(kc_p1), phylum_cast<tStatePredicate>(kc_p2));
    case sel_NextState:
	return NextState(phylum_cast<tStatePredicate>(kc_p1));
    case sel_Eventually:
	return Eventually(phylum_cast<tStatePredicate>(kc_p1));
    case sel_Always:
	return Always(phylum_cast<tStatePredicate>(kc_p1));
    case sel_ExPath:
	return ExPath(phylum_cast<tStatePredicate>(kc_p1));
    case sel_AllPath:
	return AllPath(phylum_cast<tStatePredicate>(kc_p1));
    case sel_Equivalence:
	return Equivalence(phylum_cast<tStatePredicate>(kc_p1), phylum_cast<tStatePredicate>(kc_p2));
    case sel_Implication:
	return Implication(phylum_cast<tStatePredicate>(kc_p1), phylum_cast<tStatePredicate>(kc_p2));
    case sel_ExclusiveDisjunction:
	return ExclusiveDisjunction(phylum_cast<tStatePredicate>(kc_p1), phylum_cast<tStatePredicate>(kc_p2));
    case sel_Disjunction:
	return Disjunction(phylum_cast<tStatePredicate>(kc_p1), phylum_cast<tStatePredicate>(kc_p2));
    case sel_Conjunction:
	return Conjunction(phylum_cast<tStatePredicate>(kc_p1), phylum_cast<tStatePredicate>(kc_p2));
    case sel_Negation:
	return Negation(phylum_cast<tStatePredicate>(kc_p1));
    case sel_AtomicProposition:
	return AtomicProposition(phylum_cast<tAtomicProposition>(kc_p1));
    case sel_StatePredicateFormula:
	return StatePredicateFormula(phylum_cast<tStatePredicate>(kc_p1));
    default:
	assertionFailed("Cannot create this kind of phylum - unkown operator id");
    }
    NORETURN
}

abstract_phylum
kc_create(enum_operators createOp, const std::vector<abstract_phylum>& kc_ps)
{
    if (kc_ps.size() < 3) {
	assertionFailed("Need vector of size of maximum subphylum count (which is 3)!");
    }
    return kc_create(createOp, kc_ps[0], kc_ps[1], kc_ps[2]);
}

abstract_phylum&
attributeOf(abstract_phylum kc_p, int no)
{
    assertionFailed("Cannot select attribute for this kind of phylum - has no attributes");
    NORETURN
}

abstract_phylum
impl_abstract_phylum::subphylum(int) const
{
    return 0;
}

void
impl_abstract_phylum::set_subphylum(int,abstract_phylum)
{
}

void
impl_abstract_phylum::free(bool kc_rec)
{
    KC_COLLECT_STATS0(KC_FREE_CALLED_STATS(prod_sel(), kc_rec));
    if (!phylum_info[phylum()].uniq_stored) {
	if (kc_rec) {
	    abstract_phylum son;
	    for (int kc_i=0; (son = subphylum(kc_i)); kc_i++)
	    {
		if (son!=0) son->free(kc_rec);
		son=0;
	    }
	}
	KC_COLLECT_STATS0(KC_FREED_STATS(prod_sel(), kc_rec));
	delete this;
    }
}

bool
impl_abstract_phylum::eq(c_abstract_phylum kc_p2) const
{
    if (this == kc_p2)
	return true;
    if (prod_sel() != kc_p2->prod_sel())
	return false;

    int kc_st = phylum_info[phylum()].uniq_stored;
    if (kc_st && kc_storageclass_still_uniq[kc_st])
	return false;

    c_abstract_phylum son1;
    for (int kc_i=0; (son1 = subphylum(kc_i)); kc_i++) {
	if (!son1->eq(kc_p2->subphylum(kc_i)))
	    return false;
    }

    return true;
}

static string kc_indentation = "";
static const char *kc_printformat_not_nullary_open = "%s%s(\n";
static const char *kc_printformat_list_open = "%s%s\n";

static const char *kc_printformat_not_nullary_close = "%s)\n";
static const char *kc_printformat_nullary = "%s%s()\n";

void
impl_abstract_phylum::fprint(FILE*kc_f)
{
    int kc_i;

    if (!kc_f) kc_f = stdout;
    abstract_list al = dynamic_cast<abstract_list>(this);
    if (al != 0 && !al->is_nil()) {
	fprintf(kc_f, kc_printformat_list_open, kc_indentation.c_str(), op_name());
	kc_indentation+="| ";
	subphylum(0)->fprint(kc_f);
	kc_indentation=kc_indentation.substr(0, kc_indentation.length()-2);
	phylum_cast<abstract_list>(subphylum(1))->fprint_list(kc_f);
	kc_indentation=kc_indentation.substr(0, kc_indentation.length()-2);
    } else // not list
	switch(phylum()) {
	case phylum_voidptr:
	    fprintf(kc_f, "%s%p\n", kc_indentation.c_str(), static_cast<voidptr>(this)->pointer);
	    break;
	case phylum_casestring:
	case phylum_nocasestring:
	    fprintf(kc_f, "%s%s\n", kc_indentation.c_str(), static_cast<casestring>(this)->name);
	    break;
	case phylum_integer:
	    fprintf(kc_f, "%s%i\n", kc_indentation.c_str(), static_cast<integer>(this)->value);
	    break;
	case phylum_real:
	    fprintf(kc_f, "%s%f\n", kc_indentation.c_str(), static_cast<real>(this)->value);
	    break;
	default:
	    if (!subphylum(0)) {
		fprintf(kc_f, kc_printformat_nullary, kc_indentation.c_str(), op_name());
	    } else {
		fprintf(kc_f, kc_printformat_not_nullary_open, kc_indentation.c_str(), op_name());
		kc_indentation+="  ";
		abstract_phylum son;
		for (kc_i=0; (son = subphylum(kc_i)); kc_i++) {
		    son->fprint(kc_f);
		}
		kc_indentation=kc_indentation.substr(0, kc_indentation.length()-2);
		fprintf(kc_f, kc_printformat_not_nullary_close, kc_indentation.c_str());
	    }
    }
}

void 
impl_abstract_phylum::print()
{
    fprint(stdout);
}

void 
impl_abstract_list::fprint_list(FILE*kc_f)
{
    if (!kc_f)
	kc_f = stdout;
    if (this->is_nil()) {
	kc_indentation+="`-";
	fprintf(kc_f, kc_printformat_nullary, kc_indentation.c_str(), op_name());
    } else {
	kc_indentation+="|-";
	fprintf(kc_f, kc_printformat_list_open, kc_indentation.c_str(), op_name());
	kc_indentation=kc_indentation.substr(0, kc_indentation.length()-2);
	kc_indentation+="| ";
	subphylum(0)->fprint(kc_f);
	kc_indentation=kc_indentation.substr(0, kc_indentation.length()-2);
	phylum_cast<abstract_list>(subphylum(1))->fprint_list(kc_f);
    }
}

int
impl_abstract_list::length() const
{
    int kc_length = 0;
    c_abstract_phylum kc_p = this;
    while((kc_p = kc_p->subphylum(1)))
	kc_length++;
    return kc_length;
}
void impl_abstract_list::freelist()
{
    abstract_phylum kc_p = this, kc_tmp_p;
    do {
	kc_tmp_p=kc_p->subphylum(1);
	kc_p->free(false);
	kc_p=kc_tmp_p;
    } while(kc_p);
}
abstract_phylum
impl_abstract_list::do_concat(c_abstract_phylum kc_p2, enum_operators mk) const
{
    abstract_phylum next = subphylum(1);
    if(!next)
	return const_cast<abstract_phylum>(kc_p2);
    return kc_create(mk, subphylum(0), static_cast<abstract_list>(next)->do_concat(kc_p2, mk));
}

abstract_phylum
impl_abstract_list::do_reverse(c_abstract_phylum tail, enum_operators mk) const
{
    for (impl_abstract_list const* iterator_ = this; iterator_->subphylum(1) != 0;
	iterator_ = static_cast<impl_abstract_list const*>(iterator_->subphylum(1)) )
    tail = kc_create(mk, iterator_->subphylum(0), const_cast<abstract_phylum>(tail));
    return const_cast<abstract_phylum>(tail);
}

abstract_phylum
impl_abstract_list::last() const
{
    c_abstract_phylum kc_p = this, next = subphylum(1), nextnext;
#ifdef _AFX
    ASSERT(next);
    if(!next)
	return NULL;
#else
    if(!next){
	fflush(stdout);
	fprintf(stderr, "Internal Error: list::last was called with argument Nil%s\n", phylum_name());
	exit(1);
    }
#endif
    while ((nextnext = next->subphylum(1))) {
	kc_p = next;
	next = nextnext;
    }
    return const_cast<abstract_phylum>(kc_p->subphylum(0));/* XXX remove cast */
}

abstract_phylum
impl_abstract_list::do_map(abstract_phylum (*kc_fp)(abstract_phylum), enum_operators mk)
{
    abstract_phylum el = subphylum(0);
    if (!el)
	return this;
    abstract_list next = static_cast<abstract_list>(subphylum(1));
    return kc_create(mk, kc_fp(el), next->do_map(kc_fp, mk));
}

abstract_phylum
impl_abstract_list::do_filter(bool (*kc_fp)(abstract_phylum), enum_operators mk)
{
    abstract_phylum el = subphylum(0);
    if (!el)
	return this;
    abstract_list next = static_cast<abstract_list>(subphylum(1));
    if ((*kc_fp)(el)) {
	return kc_create(mk, el, next->do_filter(kc_fp, mk));
    } else {
	return next->do_filter(kc_fp, mk);
    }
}

abstract_list
impl_abstract_list::do_append(abstract_phylum new_last, abstract_list eol)
{
    abstract_list next = this;
    while (!next->is_nil())
	next = phylum_cast<abstract_list>(next->subphylum(1));
    next->set_subphylum(0, new_last);
    next->set_subphylum(1, eol);
    return next;
}

abstract_phylum
impl_abstract_list::do_merge(abstract_list second,abstract_phylum(*kc_fp)(abstract_phylum,abstract_phylum), enum_operators mk)
{
    abstract_phylum el = subphylum(0);
    if (!el)
	return this;
    abstract_phylum el2 = second->subphylum(0);
    if (!el2)
	return el2;
    abstract_list next = static_cast<abstract_list>(subphylum(1));
    abstract_list next2 = static_cast<abstract_list>(second->subphylum(1));
    return kc_create(mk, kc_fp(el,el2), next->do_merge(next2, kc_fp, mk));
}

abstract_phylum
impl_abstract_list::do_reduce(abstract_phylum neutral, abstract_phylum(*kc_fp)(abstract_phylum,abstract_phylum)) {
    abstract_phylum el = subphylum(0);
    if (!el)
	return neutral;
    abstract_list next = static_cast<abstract_list>(subphylum(1));
    return kc_fp(el,next->do_reduce(neutral,kc_fp));
}


extern const char* kc_storageclassnames[];

#ifdef KC_STATISTICS
void do_print_operator_statistics(FILE * kc_f)
{
    unsigned int kc_i;
    assertNonNull( kc_f );
    fprintf(kc_f, "%-*s| %-*s| %-*s| %-*s| %-*s| %-*s| %-*s| %-*s| %-*s| %-*s\n", 38 , "Operator", 3, "Sz", 8, "#oper", 8, "#new", 8, "#exist", 8, "#frnrec", 8, "#frrec", 8, "#freed", 8, "#rem", 9, "total (bytes)");
    fprintf(kc_f, "%-*s|%*s |%*d |%*d |%*d |%*d |%*d |%*d |%*d |%*d\n", 38, "case sensitive strings", 3, "-", 8, operator_statistics[sel__Str].created, 8, operator_statistics[sel__Str].existing_not_found, 8, operator_statistics[sel__Str].created-operator_statistics[sel__Str].existing_not_found, 8, 0, 8, 0, 8, 0, 8, 0, 9, kc_casestring_strlen);
    fprintf(kc_f, "%-*s|%*s |%*d |%*d |%*d |%*d |%*d |%*d |%*d |%*d\n", 38, "case insensitive strings", 3, "-", 8, operator_statistics[sel_NoCaseStr].created, 8, operator_statistics[sel_NoCaseStr].existing_not_found, 8, operator_statistics[sel_NoCaseStr].created-operator_statistics[sel_NoCaseStr].existing_not_found, 8, 0, 8, 0, 8, 0, 8, 0, 9, kc_nocasestring_strlen);
    for (kc_i = one_before_first_operator+1; kc_i < last_operator; kc_i++) {
	fprintf(kc_f, "%-*s|%*d |%*d |%*d |%*d |%*d |%*d |%*d |%*d |%*d\n", 38, operator_info[kc_i].name, 3, operator_info[kc_i].size, 8, operator_statistics[kc_i].created, 8, operator_statistics[kc_i].existing_not_found, 8, operator_statistics[kc_i].created-operator_statistics[kc_i].existing_not_found, 8, operator_statistics[kc_i].free_called[false], 8, operator_statistics[kc_i].free_called[true], 8, operator_statistics[kc_i].freed[false]+operator_statistics[kc_i].freed[true], 8, operator_statistics[kc_i].existing_not_found-(operator_statistics[kc_i].freed[false]+operator_statistics[kc_i].freed[true]), 9, operator_info[kc_i].size*(operator_statistics[kc_i].existing_not_found-(operator_statistics[kc_i].freed[false]+operator_statistics[kc_i].freed[true])));
    }
}
#endif // KC_STATISTICS


void
ht_static(kc_storageclass_t kc_a_storageclass_t)
{
    hashtables[kc_a_storageclass_t]->ht_static();
}

void
ht_dynamic(kc_storageclass_t kc_a_storageclass_t)
{
    hashtables[kc_a_storageclass_t]->ht_dynamic();
}

void
ht_inc_level(kc_storageclass_t kc_a_storageclass_t)
{
    hashtables[kc_a_storageclass_t]->ht_inc_level();
}

void
ht_dec_level(kc_storageclass_t kc_a_storageclass_t)
{
    hashtables[kc_a_storageclass_t]->ht_dec_level();
}

void
ht_free_level(kc_storageclass_t kc_a_storageclass_t)
{
    hashtables[kc_a_storageclass_t]->ht_free_level();
}

hashtable_t
ht_create_simple()
{
    hashtable_t kc_ht=new hashtable_struct_t;
    kc_ht->set_to_be_freed();
    return kc_ht;
}

hashtable_t
ht_assign(hashtable_t kc_a_hashtable_t, kc_storageclass_t kc_a_storageclass_t, bool still_unique)
{
    hashtable_t kc_tmp = hashtables[kc_a_storageclass_t];
    hashtables[kc_a_storageclass_t] = kc_a_hashtable_t;
    kc_storageclass_still_uniq[kc_a_storageclass_t] = still_unique;
    return kc_tmp;
}

hashtable_t
ht_assigned(kc_storageclass_t kc_a_storageclass_t)
{
    return hashtables[kc_a_storageclass_t];
}

void
ht_clear(hashtable_t kc_a_hashtable_t)
{
    kc_a_hashtable_t->ht_clear();
}

void
ht_delete(hashtable_t kc_a_hashtable_t)
{
    if(kc_a_hashtable_t->to_be_freed())
	delete kc_a_hashtable_t;
}
const char*
phylumname_or_error(enum_phyla kc_phy)
{
    if ((kc_phy <= one_before_first_phylum) || (kc_phy >= last_phylum)) {
	char *kc_strof_error;
	sprintf((kc_strof_error=new char[69]), "Internal Error: unknown phylum number: %d", kc_phy);
	return kc_strof_error;
    } else {
	return phylum_info[kc_phy].name;
    }   }


const char*
kc_operatorname_or_error(enum_operators kc_operator)
{
    if ((kc_operator <= one_before_first_operator) || (kc_operator >= last_operator)) {
	char *kc_strof_error;
	sprintf((kc_strof_error=new char[71]), "Internal Error: unknown operator number: %d", kc_operator);
	return kc_strof_error;
    } else {
	return operator_info[kc_operator].name;
    }   }


#ifndef KC_PRINTDOT_LABELSIZE
# define KC_PRINTDOT_LABELSIZE 1023
#endif

class impl_kc_dotedgenode_t
{
    public:
    impl_kc_dotedgenode_t(c_abstract_phylum from,c_abstract_phylum to, int _son_nr):
    ptr_from(from), ptr_to(to), son_nr(_son_nr), label(0), lsize(0), next(0) { }
    c_abstract_phylum ptr_from;
    c_abstract_phylum ptr_to;
    int son_nr;
    char *label;
    int lsize;
    kc_dotedgenode_t next;
};

static kc_dotedgenode_t
kc_mkdotedgenode(struct kc_dotedge_ht*, c_abstract_phylum, c_abstract_phylum, int);
static void kc_do_printdot_do_add_edge (c_abstract_phylum, c_abstract_phylum, int, int*, kc_dotedgenode_t*, const char*);
static void kc_do_printdot_subgraph_prologue (FILE*, c_abstract_phylum, const char*, const char*, bool, bool);
static void kc_do_printdot_subgraph_epilogue (FILE*);
static void kc_do_printdot_genfields (FILE*, int, bool);
static void kc_do_printdot_edges (FILE*, kc_dotedgenode_t, const char*, bool);

static bool
kc_dotedge_less(kc_dotedgenode_t p1, kc_dotedgenode_t p2)
{
    if(p2==0)
	return false;
    if(p1==0)
	return true;
    if(p1->ptr_from<p2->ptr_from)
	return true;
    if(p1->ptr_from>p2->ptr_from)
	return false;
    if(p1->ptr_to<p2->ptr_to)
	return true;
    if(p1->ptr_to>p2->ptr_to)
	return false;
    if(p1->son_nr<p2->son_nr)
	return true;
    // OPERATORHASH((unsigned) kc_phy_from);
    // OPERATORHASH((unsigned) kc_phy_to);
    return false;
}

template<typename T>
struct dotedge_less : std::binary_function<T, T, bool> {
    bool operator()(const T& X, const T& Y) const { return kc_dotedge_less(X,Y); }
};

struct kc_dotedge_ht: public std::set<kc_dotedgenode_t, dotedge_less<kc_dotedgenode_t> > {
    ~kc_dotedge_ht() {
	for(iterator i=begin();i!=end();++i)
	delete const_cast<kc_dotedgenode_t>(*i);
	clear();
    }
    kc_dotedgenode_t check_insert(kc_dotedgenode_t t) {
	std::pair<iterator,bool> res=insert(t);
	return *res.first;
    }
};

static kc_dotedge_ht* fprintdot_hashtable;
void impl_nocasestring::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_casestring::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_real::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_integer::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_voidptr::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_tFormula::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_tStatePredicate::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_tConjunction_list::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_tDisjunction_list::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_tAtomicProposition::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_tTerm::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_tProduct_list::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_tBuechiAutomata::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_tBuechiRules::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_tTransitionRules::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}
void impl_tAcceptingSet::fprintdot(FILE *f, const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const
{
    int kc_edge_nr = 1;
    kc_dotedgenode_t kc_edges = 0;
    if (print_prologue_and_epilogue) fprintdotprologue(f);
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_prologue(f, this, root_label_prefix, edge_attributes, print_node_labels, use_context_when_sharing_leaves);
    fprintdot_hashtable = new kc_dotedge_ht;
    do_printdot(f, true, &kc_edge_nr, &kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, 0, 0);
    kc_do_printdot_edges(f, kc_edges, edge_attributes, use_context_when_sharing_leaves);
    delete fprintdot_hashtable;
    fprintdot_hashtable=0;
    /*if (kc_outmost)*/ kc_do_printdot_subgraph_epilogue(f);
    if (print_prologue_and_epilogue) fprintdotepilogue(f);
}


kc_dotedgenode_t
kc_mkdotedgenode(kc_dotedge_ht* kc_a_ht, c_abstract_phylum kc_s_from, c_abstract_phylum kc_s_to, int kc_son_nr)
{
    kc_dotedgenode_t kc_x = new impl_kc_dotedgenode_t(kc_s_from,kc_s_to,kc_son_nr);
    kc_dotedgenode_t unique_kc_x=kc_a_ht->check_insert(kc_x);
    if(unique_kc_x!=kc_x) {
	delete kc_x;
	kc_x=unique_kc_x;
    }
    return kc_x;
}

void kc_do_printdot_subgraph_prologue(FILE *kc_f, c_abstract_phylum kc_p, const char *root_label_prefix, const char *edge_attributes, bool print_node_labels, bool use_context_when_sharing_leaves)
{
    if (!kc_f) kc_f = stdout;
    fprintf(kc_f, "/*subgraph*/ {\n");
    if (root_label_prefix) {
	fprintf(kc_f, "\"%s\" [shape=ellipse", root_label_prefix);
	if (edge_attributes && (strlen(edge_attributes) > 0)) {
	    fprintf(kc_f, ", %s", edge_attributes);
	}
	if (print_node_labels) {
	    fprintf(kc_f, ", label=\"%s\\n%s\"", root_label_prefix, phylum_info[kc_p->phylum()].name);
	}
	fprintf(kc_f, "];\n");
	fprintf(kc_f, "\"%s\" ->", root_label_prefix);
	kc_p->do_printdot_id(kc_f, use_context_when_sharing_leaves, 0, 0);
	if (edge_attributes && (strlen(edge_attributes) > 0)) {
	    fprintf(kc_f, "[%s]", edge_attributes);
	}
	fprintf(kc_f, ";\n");
    }
}

void kc_do_printdot_subgraph_epilogue(FILE *kc_f)
{
    if (!kc_f) kc_f = stdout;
    fprintf(kc_f, "}\n");
}

void fprintdotprologue(FILE *kc_f)
{
    if (!kc_f) kc_f = stdout;
    fprintf(kc_f, "digraph kc_output{\n");
    fprintf(kc_f, "node [shape=record, height=.1, fontname=Helvetica];\n");
}

void fprintdotepilogue(FILE *kc_f)
{
    if (!kc_f) kc_f = stdout;
    fprintf(kc_f, "}\n");
}

void kc_do_printdot_genfields(FILE *kc_f, int kc_prodsel, bool print_node_labels)
{
    int kc_i = 1;
    KC_OPERATOR_INFO *kc_op_info = &operator_info[kc_prodsel];
    if (kc_op_info->no_sons <= 0) return;
    if (!kc_f) kc_f = stdout;
    while(kc_i < kc_op_info->no_sons) {
	fprintf(kc_f, "<f%d>", kc_i);
	if (print_node_labels) {
	    fprintf(kc_f, "%s", phylum_info[kc_op_info->subphylum[kc_i-1]].name);
	}
	fprintf(kc_f, "|");
	kc_i++;
    }
    fprintf(kc_f, "<f%d>", kc_i);
    if (print_node_labels) {
	fprintf(kc_f, "%s", phylum_info[kc_op_info->subphylum[kc_i-1]].name);
    }
}

void impl_abstract_phylum::do_printdot_id(FILE *kc_f, bool use_context_when_sharing_leaves, c_abstract_phylum kc_ctxt, int kc_son_nr) const
{
    // The casts only make unique ids, so reinterpret_cast is alright
    if (!kc_f) kc_f = stdout;
    enum_phyla kc_phy = phylum();
    if (kc_phy == phylum_voidptr) {
	fprintf(kc_f, "kcidp%lx", reinterpret_cast<unsigned long int>(this));
	if (use_context_when_sharing_leaves) {
	    fprintf(kc_f, "_%lx_%d", reinterpret_cast<unsigned long int>(kc_ctxt), kc_son_nr);
	}
    } else if ((kc_phy == phylum_casestring) || (kc_phy == phylum_nocasestring)) {
	fprintf(kc_f, "kcids%lx", reinterpret_cast<unsigned long int>(this));
	if (use_context_when_sharing_leaves) {
	    fprintf(kc_f, "_%lx_%d", reinterpret_cast<unsigned long int>(kc_ctxt), kc_son_nr);
	}
    } else if (kc_phy == phylum_integer) {
	fprintf(kc_f, "kcidi%lx", reinterpret_cast<unsigned long int>(this));
	if (use_context_when_sharing_leaves) {
	    fprintf(kc_f, "_%lx_%d", reinterpret_cast<unsigned long int>(kc_ctxt), kc_son_nr);
	}
    } else if (kc_phy == phylum_real) {
	fprintf(kc_f, "kcidf%lx", reinterpret_cast<unsigned long int>(this));
	if (use_context_when_sharing_leaves) {
	    fprintf(kc_f, "_%lx_%d", reinterpret_cast<unsigned long int>(kc_ctxt), kc_son_nr);
	}
    } else {
	fprintf(kc_f, "kcidx%lx", reinterpret_cast<unsigned long int>(this));
    }   }

void kc_do_printdot_do_add_edge(c_abstract_phylum kc_p, c_abstract_phylum kc_sub_p, int kc_son_nr, int *kc_edge_nr, kc_dotedgenode_t *kc_edges, const char *edge_label_prefix)
{
    kc_dotedgenode_t kc_hn;
    char kc_buf[30];
    kc_hn = kc_mkdotedgenode(fprintdot_hashtable, kc_p, kc_sub_p, kc_son_nr);
    if (! kc_hn->label) {
	kc_hn->label = new char[(size_t)(KC_PRINTDOT_LABELSIZE+1)];
	kc_hn->lsize = KC_PRINTDOT_LABELSIZE;
	strcpy(kc_hn->label, "");
	kc_hn->next = *kc_edges;
	*kc_edges = kc_hn;
    } else {
	char kc_buf2[30];
	sprintf(kc_buf2, ", ");
	strncat(kc_hn->label, kc_buf2, kc_hn->lsize - strlen(kc_hn->label));
    }
    if (edge_label_prefix) {
	strncat(kc_hn->label, edge_label_prefix, kc_hn->lsize - strlen(kc_hn->label));
    }
    sprintf(kc_buf, "%d", *kc_edge_nr);
    strncat(kc_hn->label, kc_buf, kc_hn->lsize - strlen(kc_hn->label));
    (*kc_edge_nr)++;
}

void impl_abstract_phylum::printdot_add_edge(c_abstract_phylum kc_sub_p, int kc_son_nr, int *kc_edge_nr, kc_dotedgenode_t *kc_edges, const char *edge_label_prefix) const
{
    kc_do_printdot_do_add_edge(this, kc_sub_p, kc_son_nr, kc_edge_nr, kc_edges, edge_label_prefix);
}

void kc_do_printdot_edges(FILE *kc_f, kc_dotedgenode_t kc_edges, const char *edge_attributes, bool use_context_when_sharing_leaves)
{
    kc_dotedgenode_t kc_p = kc_edges;
    if (!kc_f) kc_f = stdout;
    while(kc_p) {
	kc_p->ptr_from->do_printdot_id(kc_f, use_context_when_sharing_leaves, 0, 0);
	fprintf(kc_f, ":f%d -> ", kc_p->son_nr);
	kc_p->ptr_to->do_printdot_id(kc_f, use_context_when_sharing_leaves, kc_p->ptr_from, kc_p->son_nr);
	fprintf(kc_f, " [label=\"%s\"", kc_p->label);
	if (edge_attributes && (strlen(edge_attributes) > 0)) {
	    fprintf(kc_f, ", %s", edge_attributes);
	}
	fprintf(kc_f, "];\n");
	kc_p = kc_p->next;
    }   }

void impl_abstract_phylum::do_printdot(FILE *kc_f, bool kc_outmost, int *kc_edge_nr, kc_dotedgenode_t *kc_edges, const char *edge_label_prefix, bool print_node_labels, bool use_context_when_sharing_leaves, c_abstract_phylum kc_ctxt, int kc_son_nr) const
{
    int kc_i;

    if (!kc_f) kc_f = stdout;
    switch(phylum()) {
	case phylum_voidptr:
	do_printdot_id(kc_f, use_context_when_sharing_leaves, kc_ctxt, kc_son_nr);
	fprintf(kc_f, " [label=\"%p\", shape=ellipse];\n", dynamic_cast<c_voidptr>(this)->pointer);
	break;
	case phylum_casestring:
	case phylum_nocasestring:
	do_printdot_id(kc_f, use_context_when_sharing_leaves, kc_ctxt, kc_son_nr);
#ifdef KC_UNICODE
	fprintf(kc_f, " [label=\"%s\", shape=ellipse];\n", kc_to_cstring(static_cast<c_casestring>(this)->name).c_str());
#else
	fprintf(kc_f, " [label=\"%s\", shape=ellipse];\n", static_cast<c_casestring>(this)->name);
#endif
	break;
	case phylum_integer:
	do_printdot_id(kc_f, use_context_when_sharing_leaves, kc_ctxt, kc_son_nr);
	fprintf(kc_f, " [label=\"%i\", shape=ellipse];\n", ((integer)this)->value);
	break;
	case phylum_real:
	do_printdot_id(kc_f, use_context_when_sharing_leaves, kc_ctxt, kc_son_nr);
	fprintf(kc_f, " [label=\"%f\", shape=ellipse];\n", ((real)this)->value);
	break;
	default:
	if (!subphylum(0)) {
	    do_printdot_id(kc_f, use_context_when_sharing_leaves, kc_ctxt, kc_son_nr);
	    fprintf(kc_f, " [label=\"<f0>%s\"];\n", op_name());
	} else {
	    do_printdot_id(kc_f, use_context_when_sharing_leaves, kc_ctxt, kc_son_nr);
	    fprintf(kc_f, " [label=\"{<f0>%s|{", op_name());
	    kc_do_printdot_genfields(kc_f, prod_sel(), print_node_labels);
	    fprintf(kc_f, "}}\"];\n");
	    abstract_phylum child;
	    for (kc_i=0; (child = subphylum(kc_i)); kc_i++) {
		printdot_add_edge(child, kc_i+1, kc_edge_nr, kc_edges, edge_label_prefix );
		child->do_printdot( kc_f, false, kc_edge_nr, kc_edges, edge_label_prefix, print_node_labels, use_context_when_sharing_leaves, this, kc_i+1 );
	    }
	}
    }
}
tConjunction_list
concat(c_tConjunction_list kc_p1, c_tConjunction_list kc_p2)
{ return dynamic_cast<tConjunction_list>(kc_p1->do_concat(kc_p2, sel_ConstConjunction_list)); }

tConjunction_list
impl_tConjunction_list::reverse() const
{ return dynamic_cast<tConjunction_list>(do_reverse(NiltConjunction_list(), sel_ConstConjunction_list)); }

tStatePredicate
impl_tConjunction_list::last() const
{ return dynamic_cast<tStatePredicate>(impl_abstract_list::last()); }

bool
impl_tConjunction_list::is_nil() const
{
    return tStatePredicate_1==0 && tConjunction_list_1==0;
}

tConjunction_list
impl_tConjunction_list::map(tStatePredicate (*kc_fp)(tStatePredicate))
{ return dynamic_cast<tConjunction_list>(do_map((abstract_phylum (*)(abstract_phylum))kc_fp, sel_ConstConjunction_list)); }
tConjunction_list
impl_tConjunction_list::filter(bool (*kc_fp)(tStatePredicate))
{ return dynamic_cast<tConjunction_list>(do_filter((bool (*)(abstract_phylum))kc_fp, sel_ConstConjunction_list)); }

tConjunction_list
impl_tConjunction_list::append(tStatePredicate new_last)
{
    return dynamic_cast<tConjunction_list>(do_append(new_last, NiltConjunction_list()));
}
tConjunction_list
impl_tConjunction_list::merge( tConjunction_list second, tStatePredicate (*kc_fp)(tStatePredicate, tStatePredicate))
{
    return dynamic_cast<tConjunction_list>(do_merge(second,(abstract_phylum(*)(abstract_phylum,abstract_phylum))kc_fp, sel_ConstConjunction_list));
}
tStatePredicate
impl_tConjunction_list::reduce( tStatePredicate neutral, tStatePredicate (*kc_fp)(tStatePredicate, tStatePredicate))
{
    return dynamic_cast<tStatePredicate>(do_reduce(neutral,(abstract_phylum(*)(abstract_phylum,abstract_phylum))kc_fp));
}

tDisjunction_list
concat(c_tDisjunction_list kc_p1, c_tDisjunction_list kc_p2)
{ return dynamic_cast<tDisjunction_list>(kc_p1->do_concat(kc_p2, sel_ConstDisjunction_list)); }

tDisjunction_list
impl_tDisjunction_list::reverse() const
{ return dynamic_cast<tDisjunction_list>(do_reverse(NiltDisjunction_list(), sel_ConstDisjunction_list)); }

tStatePredicate
impl_tDisjunction_list::last() const
{ return dynamic_cast<tStatePredicate>(impl_abstract_list::last()); }

bool
impl_tDisjunction_list::is_nil() const
{
    return tStatePredicate_1==0 && tDisjunction_list_1==0;
}

tDisjunction_list
impl_tDisjunction_list::map(tStatePredicate (*kc_fp)(tStatePredicate))
{ return dynamic_cast<tDisjunction_list>(do_map((abstract_phylum (*)(abstract_phylum))kc_fp, sel_ConstDisjunction_list)); }
tDisjunction_list
impl_tDisjunction_list::filter(bool (*kc_fp)(tStatePredicate))
{ return dynamic_cast<tDisjunction_list>(do_filter((bool (*)(abstract_phylum))kc_fp, sel_ConstDisjunction_list)); }

tDisjunction_list
impl_tDisjunction_list::append(tStatePredicate new_last)
{
    return dynamic_cast<tDisjunction_list>(do_append(new_last, NiltDisjunction_list()));
}
tDisjunction_list
impl_tDisjunction_list::merge( tDisjunction_list second, tStatePredicate (*kc_fp)(tStatePredicate, tStatePredicate))
{
    return dynamic_cast<tDisjunction_list>(do_merge(second,(abstract_phylum(*)(abstract_phylum,abstract_phylum))kc_fp, sel_ConstDisjunction_list));
}
tStatePredicate
impl_tDisjunction_list::reduce( tStatePredicate neutral, tStatePredicate (*kc_fp)(tStatePredicate, tStatePredicate))
{
    return dynamic_cast<tStatePredicate>(do_reduce(neutral,(abstract_phylum(*)(abstract_phylum,abstract_phylum))kc_fp));
}

tProduct_list
concat(c_tProduct_list kc_p1, c_tProduct_list kc_p2)
{ return dynamic_cast<tProduct_list>(kc_p1->do_concat(kc_p2, sel_ConstProduct_list)); }

tProduct_list
impl_tProduct_list::reverse() const
{ return dynamic_cast<tProduct_list>(do_reverse(NiltProduct_list(), sel_ConstProduct_list)); }

tTerm
impl_tProduct_list::last() const
{ return dynamic_cast<tTerm>(impl_abstract_list::last()); }

bool
impl_tProduct_list::is_nil() const
{
    return tTerm_1==0 && tProduct_list_1==0;
}

tProduct_list
impl_tProduct_list::map(tTerm (*kc_fp)(tTerm))
{ return dynamic_cast<tProduct_list>(do_map((abstract_phylum (*)(abstract_phylum))kc_fp, sel_ConstProduct_list)); }
tProduct_list
impl_tProduct_list::filter(bool (*kc_fp)(tTerm))
{ return dynamic_cast<tProduct_list>(do_filter((bool (*)(abstract_phylum))kc_fp, sel_ConstProduct_list)); }

tProduct_list
impl_tProduct_list::append(tTerm new_last)
{
    return dynamic_cast<tProduct_list>(do_append(new_last, NiltProduct_list()));
}
tProduct_list
impl_tProduct_list::merge( tProduct_list second, tTerm (*kc_fp)(tTerm, tTerm))
{
    return dynamic_cast<tProduct_list>(do_merge(second,(abstract_phylum(*)(abstract_phylum,abstract_phylum))kc_fp, sel_ConstProduct_list));
}
tTerm
impl_tProduct_list::reduce( tTerm neutral, tTerm (*kc_fp)(tTerm, tTerm))
{
    return dynamic_cast<tTerm>(do_reduce(neutral,(abstract_phylum(*)(abstract_phylum,abstract_phylum))kc_fp));
}

abstract_phylum
impl_abstract_phylum::copy(bool kc_copy_attributes) const
{
    enum_phyla kc_phy = phylum(); // XXX - implement special cases in subclasses - MvL
    KC_OPERATOR_INFO *kc_op_info = &operator_info[prod_sel()];
    kc_storageclass_t kc_st = phylum_info[kc_op_info->phylum].uniq_stored;
    if (kc_st && kc_storageclass_still_uniq[kc_st])
	return const_cast<abstract_phylum>(this);
    abstract_phylum kc_answer=0;
    if (kc_phy == phylum_casestring) {
	kc_answer=mkcasestring((dynamic_cast<c_casestring>(this))->name);
    } else if (kc_phy == phylum_nocasestring) {
	kc_answer=mknocasestring((dynamic_cast<c_nocasestring>(this))->name);
    } else if (kc_phy == phylum_voidptr) {
	kc_answer=mkvoidptr((dynamic_cast<c_voidptr>(this))->pointer);
    } else if (kc_phy == phylum_integer) {
	kc_answer=mkinteger((dynamic_cast<c_integer>(this))->value);
    } else if (kc_phy == phylum_real) {
	kc_answer=mkreal((dynamic_cast<c_real>(this))->value);
    } else {
	abstract_phylum kc_subtmp[3], child;
	for (int kc_i = 0; (child = subphylum(kc_i)); kc_i++) {
	    kc_subtmp[kc_i] = child->copy(kc_copy_attributes);
	}
	switch(kc_op_info->no_sons) {
	    case 0: kc_answer = kc_create(prod_sel()); break;
	    case 1: kc_answer = kc_create(prod_sel(), kc_subtmp[0]); break;
	    case 2: kc_answer = kc_create(prod_sel(), kc_subtmp[0], kc_subtmp[1]); break;
	    case 3: kc_answer = kc_create(prod_sel(), kc_subtmp[0], kc_subtmp[1], kc_subtmp[2]); break;
	    default: assertionFailed("unexpected number of sub-phyla");
	}
    }
    if (kc_copy_attributes)
	copy_attributes(kc_phy, this, kc_answer);
    return kc_answer;
}


} // namespace kc
