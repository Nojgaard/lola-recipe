/* translation of file(s)
	"Frontend/Parser/formula_abstract.k"
	"Frontend/Parser/formula_rewrite.k"
	"Frontend/Parser/formula_unparse.k"
 */
/* generated by:
 *  @(#)$Author: Kimwitu++ version 2.3.13 (C) 1998-2008 Humboldt-Universitaet zu Berlin $
 */
#ifndef KC_TYPES_HEADER
#define KC_TYPES_HEADER

#define KIMWITUVERSIONMAJOR 2
#define KIMWITUVERSIONMINOR 3
#define KIMWITUVERSIONMICRO 13

#include <stdio.h>
#include <stddef.h>
#include <string>
#include <vector>

namespace kc {

#ifndef INTEGER
# define INTEGER int
#endif
#ifndef REAL
# define REAL double
#endif

#ifdef KC_UNICODE

#define kc_t(TEXT) L ## TEXT
typedef wchar_t kc_char_t;
typedef std::wstring kc_string_t;

#if defined(_WIN32) && ! defined (__GNUC__)
#define kc_strlen wcslen
#define kc_strcmp wcscmp
#define kc_strcasecmp _wcsicmp
#define kc_strcpy wcscpy
#define kc_strncpy wcsncpy
#define kc_tolower towlower
#define kc_print_integer(buf,number) swprintf(buf,kc_t("%d"),number)
#define kc_print_real(buf,number) swprintf(buf,kc_t("%g"),number)

// needed for printdot and csgio only
inline
std::string kc_to_cstring(const std::wstring& s) {
    USES_CONVERSION;
    return W2CA(s.c_str());
}

// needed for csgio only
inline
std::wstring kc_to_wstring(const std::string& s) {
    USES_CONVERSION;
    return A2CW(s.c_str());
}

#else // !defined(_WIN32) || defined(__GNUC__)
// if you want to use UNICODE on other platforms you have to write
// the following functions on your own
int kc_strlen(const kc_char_t*);
int kc_strcmp(const kc_char_t*,const kc_char_t*);
int kc_strcasecmp(const kc_char_t*,const kc_char_t*);
int kc_strcpy(kc_char_t*,const kc_char_t*);
int kc_strncpy(kc_char_t*,const kc_char_t*, int);
kc_char_t kc_tolower(kc_char_t);
int kc_print_integer(kc_char_t* buffer, INTEGER number );
int kc_print_real(kc_char_t* buffer, REAL number);

// needed for printdot and csgio only
std::string kc_to_cstring(const std::wstring& );
// needed for csgio only
std::wstring kc_to_wstring(const std::string& );

#endif

#else // !KC_UNICODE

#define kc_t(TEXT) TEXT  
typedef char kc_char_t;
typedef std::string kc_string_t;

#define kc_strlen strlen
#define kc_strcmp strcmp
#if defined(_WIN32) && ! defined (__GNUC__)
#define kc_strcasecmp _stricmp
#else
#define kc_strcasecmp strcasecmp
#endif
#define kc_strcpy strcpy
#define kc_strncpy strncpy
#define kc_tolower tolower  
#define kc_print_integer(buf,number) sprintf(buf,kc_t("%d"),number)
#define kc_print_real(buf,number) sprintf(buf,kc_t("%g"),number)
#endif
class uview_class;
typedef uview_class& uview;
typedef const uview_class& c_uview;

typedef class printer_functor_class& printer_functor;
typedef void (*printer_function)(const kc_char_t*, uview);

class rview_class;
typedef rview_class& rview;
typedef const rview_class& c_rview;

}

// Some compilers know __attribute__. Right now we test for the GNU compiler
// and Intel's icc (for ia32) and ecc (for ia64).
#if !defined __GNUC__ && !defined __ICC && !defined __ECC
# define __attribute__(x)
#endif

// Since all definitions are in namespace kc now, there is no need
// give them a kc_ prefix. Old code may still rely on the prefix, so these
// macros are generated for backwards compatibility
#ifdef KC_DEPRECATED
#define kc_PhylumInfo           phylum_info
#define kc_OperatorInfo         operator_info
#define kc_last_uview           last_uview
#define kc_uviews               uviews
#define kc_rviews               rviews
#define kc_ht_reuse             ht_clear
#define kc_ht_clear             ht_clear
#define kc_ht_assign            ht_assign
#define kc_ht_assigned          ht_assigned
#define kc_phylum_nocasestring phylum_nocasestring
#define kc_tag_nocasestring_NoCaseStr impl_nocasestring_NoCaseStr
#define kc_phylum_casestring phylum_casestring
#define kc_tag_casestring__Str impl_casestring__Str
#define kc_phylum_real phylum_real
#define kc_tag_real__Real impl_real__Real
#define kc_phylum_integer phylum_integer
#define kc_tag_integer__Int impl_integer__Int
#define kc_phylum_voidptr phylum_voidptr
#define kc_tag_voidptr__VoidPtr impl_voidptr__VoidPtr
#define kc_phylum_tFormula phylum_tFormula
#define kc_tag_tFormula_StatePredicateFormula impl_tFormula_StatePredicateFormula
#define kc_phylum_tStatePredicate phylum_tStatePredicate
#define kc_tag_tStatePredicate_AtomicProposition impl_tStatePredicate_AtomicProposition
#define kc_tag_tStatePredicate_Negation impl_tStatePredicate_Negation
#define kc_tag_tStatePredicate_Conjunction impl_tStatePredicate_Conjunction
#define kc_tag_tStatePredicate_Disjunction impl_tStatePredicate_Disjunction
#define kc_tag_tStatePredicate_ExclusiveDisjunction impl_tStatePredicate_ExclusiveDisjunction
#define kc_tag_tStatePredicate_Implication impl_tStatePredicate_Implication
#define kc_tag_tStatePredicate_Equivalence impl_tStatePredicate_Equivalence
#define kc_tag_tStatePredicate_AllPath impl_tStatePredicate_AllPath
#define kc_tag_tStatePredicate_ExPath impl_tStatePredicate_ExPath
#define kc_tag_tStatePredicate_Always impl_tStatePredicate_Always
#define kc_tag_tStatePredicate_Eventually impl_tStatePredicate_Eventually
#define kc_tag_tStatePredicate_NextState impl_tStatePredicate_NextState
#define kc_tag_tStatePredicate_Until impl_tStatePredicate_Until
#define kc_tag_tStatePredicate_Release impl_tStatePredicate_Release
#define kc_tag_tStatePredicate_AU impl_tStatePredicate_AU
#define kc_tag_tStatePredicate_EU impl_tStatePredicate_EU
#define kc_tag_tStatePredicate_AR impl_tStatePredicate_AR
#define kc_tag_tStatePredicate_ER impl_tStatePredicate_ER
#define kc_tag_tStatePredicate_AF impl_tStatePredicate_AF
#define kc_tag_tStatePredicate_EF impl_tStatePredicate_EF
#define kc_tag_tStatePredicate_AG impl_tStatePredicate_AG
#define kc_tag_tStatePredicate_EG impl_tStatePredicate_EG
#define kc_tag_tStatePredicate_AX impl_tStatePredicate_AX
#define kc_tag_tStatePredicate_EX impl_tStatePredicate_EX
#define kc_tag_tStatePredicate_ConjunctionList impl_tStatePredicate_ConjunctionList
#define kc_tag_tStatePredicate_DisjunctionList impl_tStatePredicate_DisjunctionList
#define kc_phylum_tConjunction_list phylum_tConjunction_list
#define kc_tag_tConjunction_list_NiltConjunction_list impl_tConjunction_list_NiltConjunction_list
#define kc_tag_tConjunction_list_ConstConjunction_list impl_tConjunction_list_ConstConjunction_list
#define kc_phylum_tDisjunction_list phylum_tDisjunction_list
#define kc_tag_tDisjunction_list_NiltDisjunction_list impl_tDisjunction_list_NiltDisjunction_list
#define kc_tag_tDisjunction_list_ConstDisjunction_list impl_tDisjunction_list_ConstDisjunction_list
#define kc_phylum_tAtomicProposition phylum_tAtomicProposition
#define kc_tag_tAtomicProposition_EqualsAtomicProposition impl_tAtomicProposition_EqualsAtomicProposition
#define kc_tag_tAtomicProposition_NotEqualsAtomicProposition impl_tAtomicProposition_NotEqualsAtomicProposition
#define kc_tag_tAtomicProposition_GreaterAtomicProposition impl_tAtomicProposition_GreaterAtomicProposition
#define kc_tag_tAtomicProposition_GreaterEqualAtomicProposition impl_tAtomicProposition_GreaterEqualAtomicProposition
#define kc_tag_tAtomicProposition_LessAtomicProposition impl_tAtomicProposition_LessAtomicProposition
#define kc_tag_tAtomicProposition_LessEqualAtomicProposition impl_tAtomicProposition_LessEqualAtomicProposition
#define kc_tag_tAtomicProposition_True impl_tAtomicProposition_True
#define kc_tag_tAtomicProposition_False impl_tAtomicProposition_False
#define kc_tag_tAtomicProposition_NoDeadlock impl_tAtomicProposition_NoDeadlock
#define kc_tag_tAtomicProposition_Deadlock impl_tAtomicProposition_Deadlock
#define kc_tag_tAtomicProposition_Initial impl_tAtomicProposition_Initial
#define kc_tag_tAtomicProposition_Fireable impl_tAtomicProposition_Fireable
#define kc_phylum_tTerm phylum_tTerm
#define kc_tag_tTerm_Node impl_tTerm_Node
#define kc_tag_tTerm_Number impl_tTerm_Number
#define kc_tag_tTerm_Sum impl_tTerm_Sum
#define kc_tag_tTerm_Difference impl_tTerm_Difference
#define kc_tag_tTerm_Product impl_tTerm_Product
#define kc_tag_tTerm_ProductList impl_tTerm_ProductList
#define kc_phylum_tProduct_list phylum_tProduct_list
#define kc_tag_tProduct_list_NiltProduct_list impl_tProduct_list_NiltProduct_list
#define kc_tag_tProduct_list_ConstProduct_list impl_tProduct_list_ConstProduct_list
#define kc_phylum_tBuechiAutomata phylum_tBuechiAutomata
#define kc_tag_tBuechiAutomata_BuechiAutomaton impl_tBuechiAutomata_BuechiAutomaton
#define kc_tag_tBuechiAutomata_BuechiNull impl_tBuechiAutomata_BuechiNull
#define kc_phylum_tBuechiRules phylum_tBuechiRules
#define kc_tag_tBuechiRules_EmptyBuechiRules impl_tBuechiRules_EmptyBuechiRules
#define kc_tag_tBuechiRules_BuechiRule impl_tBuechiRules_BuechiRule
#define kc_tag_tBuechiRules_ExpandedBuechiRule impl_tBuechiRules_ExpandedBuechiRule
#define kc_tag_tBuechiRules_BuechiRules impl_tBuechiRules_BuechiRules
#define kc_phylum_tTransitionRules phylum_tTransitionRules
#define kc_tag_tTransitionRules_EmptyTransitionRules impl_tTransitionRules_EmptyTransitionRules
#define kc_tag_tTransitionRules_TransitionRule impl_tTransitionRules_TransitionRule
#define kc_tag_tTransitionRules_TransitionRules impl_tTransitionRules_TransitionRules
#define kc_phylum_tAcceptingSet phylum_tAcceptingSet
#define kc_tag_tAcceptingSet_EmptyAcceptingSet impl_tAcceptingSet_EmptyAcceptingSet
#define kc_tag_tAcceptingSet_AcceptingState impl_tAcceptingSet_AcceptingState
#define kc_tag_tAcceptingSet_AcceptingSet impl_tAcceptingSet_AcceptingSet

#endif // KC_DEPRECATED

// Some compilers are too stupid to detect that a function will always return
// a proper value when it returns one in all branches of an if- or switch-
// statement (with final else or default, of course).
#if !defined __GNUC__
# define NORETURN throw 0;
#else
# define NORETURN
#endif

namespace kc {


typedef enum { one_before_first_phylum = 0 ,
    phylum_nocasestring = 1,
    phylum_casestring = 2,
    phylum_real = 3,
    phylum_integer = 4,
    phylum_voidptr = 5,
    phylum_tFormula = 6,
    phylum_tStatePredicate = 7,
    phylum_tConjunction_list = 8,
    phylum_tDisjunction_list = 9,
    phylum_tAtomicProposition = 10,
    phylum_tTerm = 11,
    phylum_tProduct_list = 12,
    phylum_tBuechiAutomata = 13,
    phylum_tBuechiRules = 14,
    phylum_tTransitionRules = 15,
    phylum_tAcceptingSet = 16,
    last_phylum = 17
} enum_phyla;

typedef enum { one_before_first_operator = 0 ,
    sel_NoCaseStr = 1,
    sel__Str = 2,
    sel__Real = 3,
    sel__Int = 4,
    sel__VoidPtr = 5,
    sel_StatePredicateFormula = 6,
    sel_AtomicProposition = 7,
    sel_Negation = 8,
    sel_Conjunction = 9,
    sel_Disjunction = 10,
    sel_ExclusiveDisjunction = 11,
    sel_Implication = 12,
    sel_Equivalence = 13,
    sel_AllPath = 14,
    sel_ExPath = 15,
    sel_Always = 16,
    sel_Eventually = 17,
    sel_NextState = 18,
    sel_Until = 19,
    sel_Release = 20,
    sel_AU = 21,
    sel_EU = 22,
    sel_AR = 23,
    sel_ER = 24,
    sel_AF = 25,
    sel_EF = 26,
    sel_AG = 27,
    sel_EG = 28,
    sel_AX = 29,
    sel_EX = 30,
    sel_ConjunctionList = 31,
    sel_DisjunctionList = 32,
    sel_NiltConjunction_list = 33,
    sel_ConstConjunction_list = 34,
    sel_NiltDisjunction_list = 35,
    sel_ConstDisjunction_list = 36,
    sel_EqualsAtomicProposition = 37,
    sel_NotEqualsAtomicProposition = 38,
    sel_GreaterAtomicProposition = 39,
    sel_GreaterEqualAtomicProposition = 40,
    sel_LessAtomicProposition = 41,
    sel_LessEqualAtomicProposition = 42,
    sel_True = 43,
    sel_False = 44,
    sel_NoDeadlock = 45,
    sel_Deadlock = 46,
    sel_Initial = 47,
    sel_Fireable = 48,
    sel_Node = 49,
    sel_Number = 50,
    sel_Sum = 51,
    sel_Difference = 52,
    sel_Product = 53,
    sel_ProductList = 54,
    sel_NiltProduct_list = 55,
    sel_ConstProduct_list = 56,
    sel_BuechiAutomaton = 57,
    sel_BuechiNull = 58,
    sel_EmptyBuechiRules = 59,
    sel_BuechiRule = 60,
    sel_ExpandedBuechiRule = 61,
    sel_BuechiRules = 62,
    sel_EmptyTransitionRules = 63,
    sel_TransitionRule = 64,
    sel_TransitionRules = 65,
    sel_EmptyAcceptingSet = 66,
    sel_AcceptingState = 67,
    sel_AcceptingSet = 68,
    last_operator = 69
} enum_operators;

class impl_abstract_phylum;
typedef impl_abstract_phylum * abstract_phylum;
typedef const impl_abstract_phylum * c_abstract_phylum;
class impl_abstract_list;
typedef impl_abstract_list * abstract_list;
typedef const impl_abstract_list * c_abstract_list;

template <typename P, typename T>
P phylum_cast(T* t) {
    return static_cast<P>(t);
}
template <typename P, typename T>
const P phylum_cast(const T* t) {
    return static_cast<const P>(t);
}
class impl_nocasestring_NoCaseStr;
class impl_casestring__Str;
class impl_real__Real;
class impl_integer__Int;
class impl_voidptr__VoidPtr;
class impl_tFormula;
class impl_tStatePredicate;
class impl_tConjunction_list;
class impl_tDisjunction_list;
class impl_tAtomicProposition;
class impl_tTerm;
class impl_tProduct_list;
class impl_tBuechiAutomata;
class impl_tBuechiRules;
class impl_tTransitionRules;
class impl_tAcceptingSet;


void kc_invalid_operator( const char *kc_func_prefix, enum_phyla kc_phy, int kc_line,
    const char *kc_file, enum_operators kc_oper ) __attribute__ ((noreturn));

typedef enum_phyla *enum_phyla_list;

/*
 * make sure that the first 'real' storage class _always_ gets a value > 0
 * and kc_not_uniq gets a value == 0
 * (because then we can use it as a C boolean)
 */
enum kc_storageclass_t {
    kc_not_uniq,
    uniq,
    last_storageclass
};

typedef struct {
    const char *name;			// name of the phylum
    enum_operators first_operator;	// index in operator_info[]
    enum_operators last_operator;	// index in operator_info[]
    kc_storageclass_t uniq_stored;	// storage class
} KC_PHYLUM_INFO;

typedef struct {
    const char *name;			// name of the operator
    size_t no_sons;			// number of sons
    bool atomicity;			// atomic type or not
    enum_phyla phylum;			// index in phylum_info[]
    enum_phyla_list subphylum;		// indexes in phylum_info[]
    int no_attrs;			// number of attributes
    enum_phyla_list attribute;		// indexes in phylum_info[]
    size_t size;			// size of operator (for statistics)
} KC_OPERATOR_INFO;

typedef enum_phyla_list KC_UNIQ_INFO;

extern KC_OPERATOR_INFO operator_info[];
extern KC_PHYLUM_INFO phylum_info[];
extern KC_UNIQ_INFO kc_UniqInfo[];

#define KC_OP_NAME(op) (operator_info[op].name)
#define KC_NO_SONS(prod) (operator_info[prod].no_sons)
#define KC_ATOMICITY(prod) (operator_info[prod].atomicity)

typedef class impl_kc_dotedgenode_t *kc_dotedgenode_t;

typedef impl_nocasestring_NoCaseStr *nocasestring;
typedef const impl_nocasestring_NoCaseStr *c_nocasestring;
typedef impl_casestring__Str *casestring;
typedef const impl_casestring__Str *c_casestring;
typedef impl_real__Real *real;
typedef const impl_real__Real *c_real;
typedef impl_integer__Int *integer;
typedef const impl_integer__Int *c_integer;
typedef impl_voidptr__VoidPtr *voidptr;
typedef const impl_voidptr__VoidPtr *c_voidptr;
typedef impl_tFormula *tFormula;
typedef const impl_tFormula *c_tFormula;
typedef impl_tStatePredicate *tStatePredicate;
typedef const impl_tStatePredicate *c_tStatePredicate;
typedef impl_tConjunction_list *tConjunction_list;
typedef const impl_tConjunction_list *c_tConjunction_list;
typedef impl_tDisjunction_list *tDisjunction_list;
typedef const impl_tDisjunction_list *c_tDisjunction_list;
typedef impl_tAtomicProposition *tAtomicProposition;
typedef const impl_tAtomicProposition *c_tAtomicProposition;
typedef impl_tTerm *tTerm;
typedef const impl_tTerm *c_tTerm;
typedef impl_tProduct_list *tProduct_list;
typedef const impl_tProduct_list *c_tProduct_list;
typedef impl_tBuechiAutomata *tBuechiAutomata;
typedef const impl_tBuechiAutomata *c_tBuechiAutomata;
typedef impl_tBuechiRules *tBuechiRules;
typedef const impl_tBuechiRules *c_tBuechiRules;
typedef impl_tTransitionRules *tTransitionRules;
typedef const impl_tTransitionRules *c_tTransitionRules;
typedef impl_tAcceptingSet *tAcceptingSet;
typedef const impl_tAcceptingSet *c_tAcceptingSet;

#define KC_NO_OF_OPERATORS 69


} // namespace kc
namespace kc { }
using namespace kc;
/* included stuff */
#line 19 "Frontend/Parser/formula_abstract.k"
#include <Core/Dimensions.h>
#include <Formula/StatePredicate/StatePredicate.h>
#include <Formula/LTL/BuechiAutomata.h>
#include <Formula/LTL/BuechiFromLTL.h>
#include <Formula/CTL/CTLFormula.h>
#include <cstring>
#include <map>
#include <string>

// required, because the abstract grammar does not allow pointer types
typedef StatePredicate* StatePredicate_p;
typedef BuechiAutomata* BuechiAutomata_p;
typedef CTLFormula* CTLFormula_p;
typedef tl_Node* LTLTree_p;
typedef char* char_p;

// don't use hash sets, since they are deprecated and unordered sets are not yet supported by Kimwitu++
#define DONT_USE_HASHSET

#line  461 "ast-system-k.h"
/* end included stuff */


namespace kc {

#ifndef KC_NO_DEFAULT_IN_WITH
# define KC_NO_DEFAULT_IN_WITH "Internal Error: no default action defined in function %s at %s:%d\n"
#endif
void kc_no_default_in_with (const char*, int, const char*);
void kc_returnless_function (const char *, int, const char*);

#ifndef NDEBUG
# define assertCond(t) do {if (!(t)) kc_assertionFailed(__FILE__,__LINE__);}while(false)
# define assertReason(t,s) do {if (!(t)) kc_assertionReasonFailed(__FILE__,__LINE__,s);}while(false)
# define assertNonNull(p) do {if (p == 0) kc_assertionNonNullFailed(__FILE__,__LINE__,#p);}while(false)
# define assertPhylum(ptr,phy) do { \
    assertNonNull(ptr); \
    if (ptr->phylum()!=phy) \
	kc_assertionOperatorInPhylumFailed(ptr->prod_sel(),#ptr,"->prod_sel()","phy",__FILE__,__LINE__); \
} while(false)
#else
# define assertCond(t)
# define assertReason(t,s)
# define assertNonNull(ptr)
# define assertPhylum(op,phy)
#endif
#define assertionFailed(s) kc_assertionReasonFailed(__FILE__,__LINE__,s)

void kc_assertionFailed (const char*, int) __attribute__ ((noreturn));
void kc_assertionReasonFailed (const char*, int, const char*) __attribute__ ((noreturn));
void kc_assertionNonNullFailed (const char*, int, const char*) __attribute__ ((noreturn));
void kc_assertionOperatorInPhylumFailed (int, const char*, const char*, const char*, const char*, int) __attribute__ ((noreturn));

casestring mkcasestring( const kc_char_t *, int length = -1);
nocasestring mknocasestring( const kc_char_t *, int length = -1);
integer mkinteger( const INTEGER );
real mkreal( const REAL );
inline casestring _Str( const kc_char_t * cc) { return mkcasestring(cc); }
inline nocasestring NoCaseStr( const kc_char_t * cc) { return mknocasestring(cc); }
inline integer _Int( const INTEGER cc) { return mkinteger(cc); }
inline real _Real( const REAL cc) { return mkreal(cc); }
class impl_tFormula_StatePredicateFormula* StatePredicateFormula (tStatePredicate);
class impl_tStatePredicate_AtomicProposition* AtomicProposition (tAtomicProposition);
class impl_tStatePredicate_Negation* Negation (tStatePredicate);
class impl_tStatePredicate_Conjunction* Conjunction (tStatePredicate, tStatePredicate);
class impl_tStatePredicate_Disjunction* Disjunction (tStatePredicate, tStatePredicate);
class impl_tStatePredicate_ExclusiveDisjunction* ExclusiveDisjunction (tStatePredicate, tStatePredicate);
class impl_tStatePredicate_Implication* Implication (tStatePredicate, tStatePredicate);
class impl_tStatePredicate_Equivalence* Equivalence (tStatePredicate, tStatePredicate);
class impl_tStatePredicate_AllPath* AllPath (tStatePredicate);
class impl_tStatePredicate_ExPath* ExPath (tStatePredicate);
class impl_tStatePredicate_Always* Always (tStatePredicate);
class impl_tStatePredicate_Eventually* Eventually (tStatePredicate);
class impl_tStatePredicate_NextState* NextState (tStatePredicate);
class impl_tStatePredicate_Until* Until (tStatePredicate, tStatePredicate);
class impl_tStatePredicate_Release* Release (tStatePredicate, tStatePredicate);
class impl_tStatePredicate_AU* AU (tStatePredicate, tStatePredicate);
class impl_tStatePredicate_EU* EU (tStatePredicate, tStatePredicate);
class impl_tStatePredicate_AR* AR (tStatePredicate, tStatePredicate);
class impl_tStatePredicate_ER* ER (tStatePredicate, tStatePredicate);
class impl_tStatePredicate_AF* AF (tStatePredicate);
class impl_tStatePredicate_EF* EF (tStatePredicate);
class impl_tStatePredicate_AG* AG (tStatePredicate);
class impl_tStatePredicate_EG* EG (tStatePredicate);
class impl_tStatePredicate_AX* AX (tStatePredicate);
class impl_tStatePredicate_EX* EX (tStatePredicate);
class impl_tStatePredicate_ConjunctionList* ConjunctionList (tConjunction_list);
class impl_tStatePredicate_DisjunctionList* DisjunctionList (tDisjunction_list);
tConjunction_list NiltConjunction_list();
tConjunction_list ConstConjunction_list(tStatePredicate,tConjunction_list);
tDisjunction_list NiltDisjunction_list();
tDisjunction_list ConstDisjunction_list(tStatePredicate,tDisjunction_list);
class impl_tAtomicProposition_EqualsAtomicProposition* EqualsAtomicProposition (tTerm, tTerm);
class impl_tAtomicProposition_NotEqualsAtomicProposition* NotEqualsAtomicProposition (tTerm, tTerm);
class impl_tAtomicProposition_GreaterAtomicProposition* GreaterAtomicProposition (tTerm, tTerm);
class impl_tAtomicProposition_GreaterEqualAtomicProposition* GreaterEqualAtomicProposition (tTerm, tTerm);
class impl_tAtomicProposition_LessAtomicProposition* LessAtomicProposition (tTerm, tTerm);
class impl_tAtomicProposition_LessEqualAtomicProposition* LessEqualAtomicProposition (tTerm, tTerm);
class impl_tAtomicProposition_True* True ();
class impl_tAtomicProposition_False* False ();
class impl_tAtomicProposition_NoDeadlock* NoDeadlock ();
class impl_tAtomicProposition_Deadlock* Deadlock ();
class impl_tAtomicProposition_Initial* Initial ();
class impl_tAtomicProposition_Fireable* Fireable (integer);
class impl_tTerm_Node* Node (integer);
class impl_tTerm_Number* Number (integer);
class impl_tTerm_Sum* Sum (tTerm, tTerm);
class impl_tTerm_Difference* Difference (tTerm, tTerm);
class impl_tTerm_Product* Product (integer, tTerm);
class impl_tTerm_ProductList* ProductList (tProduct_list);
tProduct_list NiltProduct_list();
tProduct_list ConstProduct_list(tTerm,tProduct_list);
class impl_tBuechiAutomata_BuechiAutomaton* BuechiAutomaton (tBuechiRules, tAcceptingSet);
class impl_tBuechiAutomata_BuechiNull* BuechiNull ();
class impl_tBuechiRules_EmptyBuechiRules* EmptyBuechiRules ();
class impl_tBuechiRules_BuechiRule* BuechiRule (integer, tTransitionRules);
class impl_tBuechiRules_ExpandedBuechiRule* ExpandedBuechiRule (integer, tFormula, integer);
class impl_tBuechiRules_BuechiRules* BuechiRules (tBuechiRules, tBuechiRules);
class impl_tTransitionRules_EmptyTransitionRules* EmptyTransitionRules ();
class impl_tTransitionRules_TransitionRule* TransitionRule (tFormula, integer);
class impl_tTransitionRules_TransitionRules* TransitionRules (tTransitionRules, tTransitionRules);
class impl_tAcceptingSet_EmptyAcceptingSet* EmptyAcceptingSet ();
class impl_tAcceptingSet_AcceptingState* AcceptingState (integer);
class impl_tAcceptingSet_AcceptingSet* AcceptingSet (tAcceptingSet, tAcceptingSet);

//namespace Phylum {

class impl_abstract_phylum {
public:
    virtual enum_operators prod_sel() const =0;
    static const enum_phyla phylum_sel_;
    enum_phyla phylum() const;
    const char* phylum_name() const;
    const char* op_name() const;
    virtual abstract_phylum subphylum(int) const;
    virtual void set_subphylum(int, abstract_phylum);
    void free(bool recursive=true);
    bool eq(c_abstract_phylum) const;
    void print();
    void fprint(FILE *);
    abstract_phylum copy(bool kc_copy_attributes) const;
    void unparse(printer_functor pf, uview uv)
	{ do_unparse(pf, uv); }
    void unparse(printer_function opf, uview uv);

    void printdot_add_edge (c_abstract_phylum, int, int*, kc_dotedgenode_t*, const char*) const;
    void do_printdot_id (FILE*, bool, c_abstract_phylum, int) const;
    void do_printdot (FILE*, bool, int*, kc_dotedgenode_t*, const char*, bool, bool, c_abstract_phylum, int) const;

    virtual void fprintdot(FILE *,
	const char *root_label_prefix, const char *edge_label_prefix, const char *edge_attributes,
	bool print_node_labels, bool use_context_when_sharing_leaves, bool print_prologue_and_epilogue) const =0;
    virtual abstract_phylum rewrite(rview v) { return do_rewrite(v); }
    virtual abstract_phylum do_rewrite(rview) { return this;}
    // called if a subphylum of an op is rewritten and a new op is created by default rule
    virtual void rewrite_members(abstract_phylum from) {} 
    virtual void post_create(){}
    virtual ~impl_abstract_phylum() { }
private:
    virtual void do_unparse(printer_functor, uview) =0;
protected:
    virtual void default_unparse(printer_functor, uview);
};


class impl_abstract_list: public impl_abstract_phylum{
private:
    void fprint_list(FILE *);
    friend class impl_abstract_phylum;
protected:
    abstract_phylum do_concat(c_abstract_phylum other, enum_operators) const;
    abstract_phylum do_reverse(c_abstract_phylum tail, enum_operators) const;
    abstract_phylum do_map(abstract_phylum (*kc_fp)(abstract_phylum), enum_operators);
    abstract_phylum do_filter(bool (*kc_fp)(abstract_phylum), enum_operators);
    abstract_list   do_append(abstract_phylum, abstract_list);
    abstract_phylum do_merge(abstract_list,abstract_phylum (*kc_fp)(abstract_phylum,abstract_phylum), enum_operators);
    abstract_phylum do_reduce(abstract_phylum neutral, abstract_phylum (*kc_fp)(abstract_phylum,abstract_phylum));
public:
    virtual bool is_nil() const =0;
    virtual abstract_list reverse() const =0;
    int length() const;
    abstract_phylum last() const;
    // Non-virtual, non-existing... Type must be known exactly anyway because
    // of the function given as a parameter
    //virtual abstract_list map( abstract_phylum (*)( abstract_phylum )) =0;
    //virtual abstract_list filter(bool (*)(abstract_phylum)) =0;
    void freelist();
};

abstract_phylum kc_create(enum_operators createOp, abstract_phylum=0, abstract_phylum=0, abstract_phylum=0);
abstract_phylum kc_create(enum_operators createOp, const std::vector<abstract_phylum>& kc_ps);
abstract_phylum& attributeOf(abstract_phylum kc_p, int no);

class impl_nocasestring_NoCaseStr;
typedef impl_nocasestring_NoCaseStr impl_nocasestring;
class impl_nocasestring_NoCaseStr:public impl_abstract_phylum{
public:
    enum_operators prod_sel() const
	{ return sel_NoCaseStr; }
    static const enum_phyla phylum_sel_;
private:
    explicit impl_nocasestring_NoCaseStr(const kc_char_t*);
    void make_own(int length);
    friend nocasestring mknocasestring(const kc_char_t*, int);
public:
    ~impl_nocasestring_NoCaseStr() {
#if defined (_MSC_VER) && _MSC_VER<1300
	delete [] (kc_char_t*)name;
#else
	delete [] name;
#endif
    }
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;

    nocasestring rewrite( rview )
	{ return this; }
    kc_char_t const* name;
private:
    void do_unparse(printer_functor, uview);
};
class impl_casestring__Str;
typedef impl_casestring__Str impl_casestring;
class impl_casestring__Str:public impl_abstract_phylum{
public:
    enum_operators prod_sel() const
	{ return sel__Str; }
    static const enum_phyla phylum_sel_;
private:
    explicit impl_casestring__Str(const kc_char_t*);
    void make_own(int length);
    friend casestring mkcasestring(const kc_char_t*, int);
public:
    ~impl_casestring__Str() {
#if defined (_MSC_VER) && _MSC_VER<1300
	delete [] (kc_char_t*)name;
#else
	delete [] name;
#endif
    }
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;

    casestring rewrite( rview )
	{ return this; }
    kc_char_t const* name;
private:
    void do_unparse(printer_functor, uview);
};
class impl_real__Real;
typedef impl_real__Real impl_real;
class impl_real__Real:public impl_abstract_phylum{
public:
    enum_operators prod_sel() const
	{ return sel__Real; }
    static const enum_phyla phylum_sel_;
    explicit impl_real__Real(REAL _value);
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;

    real rewrite( rview )
	{ return this; }
    REAL value;
private:
    void do_unparse(printer_functor, uview);
};
class impl_integer__Int;
typedef impl_integer__Int impl_integer;
class impl_integer__Int:public impl_abstract_phylum{
public:
    enum_operators prod_sel() const
	{ return sel__Int; }
    static const enum_phyla phylum_sel_;
    explicit impl_integer__Int(INTEGER _value);
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;

    integer rewrite( rview )
	{ return this; }
    INTEGER value;
private:
    void do_unparse(printer_functor, uview);
};
class impl_voidptr__VoidPtr;
typedef impl_voidptr__VoidPtr impl_voidptr;
class impl_voidptr__VoidPtr:public impl_abstract_phylum{
public:
    enum_operators prod_sel() const
	{ return sel__VoidPtr; }
    static const enum_phyla phylum_sel_;
    explicit impl_voidptr__VoidPtr(void* _pointer);
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;

    voidptr rewrite( rview )
	{ return this; }
    void* pointer;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tFormula: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    formula_t type;
    StatePredicate_p formula;
    CTLFormula_p ctl_formula;
    LTLTree_p ltl_tree;
    tFormula rewrite(rview) =0;
};
class impl_tFormula_StatePredicateFormula:public impl_tFormula{
public:
    enum_operators prod_sel() const
	{ return sel_StatePredicateFormula; }
    explicit impl_tFormula_StatePredicateFormula(tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tFormula rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    bool containsTemporal;
    bool validCTLPathFormula;
    bool validCTLStateFormula;
    bool validLTLFormula;
    int priority;
    tStatePredicate rewrite(rview) =0;
};
class impl_tStatePredicate_DisjunctionList:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_DisjunctionList; }
    explicit impl_tStatePredicate_DisjunctionList(tDisjunction_list);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tDisjunction_list* tDisjunction_list_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_ConjunctionList:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_ConjunctionList; }
    explicit impl_tStatePredicate_ConjunctionList(tConjunction_list);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tConjunction_list* tConjunction_list_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_EX:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_EX; }
    explicit impl_tStatePredicate_EX(tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_AX:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_AX; }
    explicit impl_tStatePredicate_AX(tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_EG:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_EG; }
    explicit impl_tStatePredicate_EG(tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_AG:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_AG; }
    explicit impl_tStatePredicate_AG(tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_EF:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_EF; }
    explicit impl_tStatePredicate_EF(tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_AF:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_AF; }
    explicit impl_tStatePredicate_AF(tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_ER:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_ER; }
    explicit impl_tStatePredicate_ER(tStatePredicate, tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
    impl_tStatePredicate* tStatePredicate_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_AR:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_AR; }
    explicit impl_tStatePredicate_AR(tStatePredicate, tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
    impl_tStatePredicate* tStatePredicate_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_EU:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_EU; }
    explicit impl_tStatePredicate_EU(tStatePredicate, tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
    impl_tStatePredicate* tStatePredicate_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_AU:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_AU; }
    explicit impl_tStatePredicate_AU(tStatePredicate, tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
    impl_tStatePredicate* tStatePredicate_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_Release:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_Release; }
    explicit impl_tStatePredicate_Release(tStatePredicate, tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
    impl_tStatePredicate* tStatePredicate_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_Until:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_Until; }
    explicit impl_tStatePredicate_Until(tStatePredicate, tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
    impl_tStatePredicate* tStatePredicate_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_NextState:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_NextState; }
    explicit impl_tStatePredicate_NextState(tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_Eventually:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_Eventually; }
    explicit impl_tStatePredicate_Eventually(tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_Always:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_Always; }
    explicit impl_tStatePredicate_Always(tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_ExPath:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_ExPath; }
    explicit impl_tStatePredicate_ExPath(tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_AllPath:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_AllPath; }
    explicit impl_tStatePredicate_AllPath(tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_Equivalence:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_Equivalence; }
    explicit impl_tStatePredicate_Equivalence(tStatePredicate, tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
    impl_tStatePredicate* tStatePredicate_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_Implication:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_Implication; }
    explicit impl_tStatePredicate_Implication(tStatePredicate, tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
    impl_tStatePredicate* tStatePredicate_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_ExclusiveDisjunction:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_ExclusiveDisjunction; }
    explicit impl_tStatePredicate_ExclusiveDisjunction(tStatePredicate, tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
    impl_tStatePredicate* tStatePredicate_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_Disjunction:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_Disjunction; }
    explicit impl_tStatePredicate_Disjunction(tStatePredicate, tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
    impl_tStatePredicate* tStatePredicate_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_Conjunction:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_Conjunction; }
    explicit impl_tStatePredicate_Conjunction(tStatePredicate, tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
    impl_tStatePredicate* tStatePredicate_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_Negation:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_Negation; }
    explicit impl_tStatePredicate_Negation(tStatePredicate);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tStatePredicate* tStatePredicate_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tStatePredicate_AtomicProposition:public impl_tStatePredicate{
public:
    enum_operators prod_sel() const
	{ return sel_AtomicProposition; }
    explicit impl_tStatePredicate_AtomicProposition(tAtomicProposition);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tStatePredicate rewrite( rview );
    impl_tAtomicProposition* tAtomicProposition_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tConjunction_list: public impl_abstract_list{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    enum_operators prod_sel() const{
	return is_nil() ? sel_NiltConjunction_list: sel_ConstConjunction_list;
    }
    explicit impl_tConjunction_list(tStatePredicate = 0, tConjunction_list = 0);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);
    friend tConjunction_list concat(c_tConjunction_list, c_tConjunction_list);
    tConjunction_list reverse() const;
    tConjunction_list rewrite(rview);
    tStatePredicate last() const;
    tConjunction_list append(tStatePredicate);
    tConjunction_list map(tStatePredicate (*)(tStatePredicate));
    tConjunction_list filter( bool (*)(tStatePredicate));
    tConjunction_list merge( tConjunction_list, tStatePredicate (*)(tStatePredicate, tStatePredicate));
    tStatePredicate reduce( tStatePredicate, tStatePredicate (*)(tStatePredicate, tStatePredicate));
    bool is_nil() const;
    tStatePredicate tStatePredicate_1;
    tConjunction_list tConjunction_list_1;
private:
    impl_tConjunction_list* nil_rewrite(rview);
    impl_tConjunction_list* cons_rewrite(rview);
    void nil_do_unparse(printer_functor, uview);
    void do_unparse(printer_functor, uview);
};
class impl_tDisjunction_list: public impl_abstract_list{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    enum_operators prod_sel() const{
	return is_nil() ? sel_NiltDisjunction_list: sel_ConstDisjunction_list;
    }
    explicit impl_tDisjunction_list(tStatePredicate = 0, tDisjunction_list = 0);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);
    friend tDisjunction_list concat(c_tDisjunction_list, c_tDisjunction_list);
    tDisjunction_list reverse() const;
    tDisjunction_list rewrite(rview);
    tStatePredicate last() const;
    tDisjunction_list append(tStatePredicate);
    tDisjunction_list map(tStatePredicate (*)(tStatePredicate));
    tDisjunction_list filter( bool (*)(tStatePredicate));
    tDisjunction_list merge( tDisjunction_list, tStatePredicate (*)(tStatePredicate, tStatePredicate));
    tStatePredicate reduce( tStatePredicate, tStatePredicate (*)(tStatePredicate, tStatePredicate));
    bool is_nil() const;
    tStatePredicate tStatePredicate_1;
    tDisjunction_list tDisjunction_list_1;
private:
    impl_tDisjunction_list* nil_rewrite(rview);
    impl_tDisjunction_list* cons_rewrite(rview);
    void nil_do_unparse(printer_functor, uview);
    void do_unparse(printer_functor, uview);
};
class impl_tAtomicProposition: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tAtomicProposition rewrite(rview) =0;
};
class impl_tAtomicProposition_Fireable:public impl_tAtomicProposition{
public:
    enum_operators prod_sel() const
	{ return sel_Fireable; }
    explicit impl_tAtomicProposition_Fireable(integer);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tAtomicProposition rewrite( rview );
    impl_integer* integer_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tAtomicProposition_Initial:public impl_tAtomicProposition{
public:
    enum_operators prod_sel() const
	{ return sel_Initial; }
    explicit impl_tAtomicProposition_Initial();

    tAtomicProposition rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_tAtomicProposition_Deadlock:public impl_tAtomicProposition{
public:
    enum_operators prod_sel() const
	{ return sel_Deadlock; }
    explicit impl_tAtomicProposition_Deadlock();

    tAtomicProposition rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_tAtomicProposition_NoDeadlock:public impl_tAtomicProposition{
public:
    enum_operators prod_sel() const
	{ return sel_NoDeadlock; }
    explicit impl_tAtomicProposition_NoDeadlock();

    tAtomicProposition rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_tAtomicProposition_False:public impl_tAtomicProposition{
public:
    enum_operators prod_sel() const
	{ return sel_False; }
    explicit impl_tAtomicProposition_False();

    tAtomicProposition rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_tAtomicProposition_True:public impl_tAtomicProposition{
public:
    enum_operators prod_sel() const
	{ return sel_True; }
    explicit impl_tAtomicProposition_True();

    tAtomicProposition rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_tAtomicProposition_LessEqualAtomicProposition:public impl_tAtomicProposition{
public:
    enum_operators prod_sel() const
	{ return sel_LessEqualAtomicProposition; }
    explicit impl_tAtomicProposition_LessEqualAtomicProposition(tTerm, tTerm);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tAtomicProposition rewrite( rview );
    impl_tTerm* tTerm_1;
    impl_tTerm* tTerm_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tAtomicProposition_LessAtomicProposition:public impl_tAtomicProposition{
public:
    enum_operators prod_sel() const
	{ return sel_LessAtomicProposition; }
    explicit impl_tAtomicProposition_LessAtomicProposition(tTerm, tTerm);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tAtomicProposition rewrite( rview );
    impl_tTerm* tTerm_1;
    impl_tTerm* tTerm_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tAtomicProposition_GreaterEqualAtomicProposition:public impl_tAtomicProposition{
public:
    enum_operators prod_sel() const
	{ return sel_GreaterEqualAtomicProposition; }
    explicit impl_tAtomicProposition_GreaterEqualAtomicProposition(tTerm, tTerm);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tAtomicProposition rewrite( rview );
    impl_tTerm* tTerm_1;
    impl_tTerm* tTerm_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tAtomicProposition_GreaterAtomicProposition:public impl_tAtomicProposition{
public:
    enum_operators prod_sel() const
	{ return sel_GreaterAtomicProposition; }
    explicit impl_tAtomicProposition_GreaterAtomicProposition(tTerm, tTerm);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tAtomicProposition rewrite( rview );
    impl_tTerm* tTerm_1;
    impl_tTerm* tTerm_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tAtomicProposition_NotEqualsAtomicProposition:public impl_tAtomicProposition{
public:
    enum_operators prod_sel() const
	{ return sel_NotEqualsAtomicProposition; }
    explicit impl_tAtomicProposition_NotEqualsAtomicProposition(tTerm, tTerm);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tAtomicProposition rewrite( rview );
    impl_tTerm* tTerm_1;
    impl_tTerm* tTerm_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tAtomicProposition_EqualsAtomicProposition:public impl_tAtomicProposition{
public:
    enum_operators prod_sel() const
	{ return sel_EqualsAtomicProposition; }
    explicit impl_tAtomicProposition_EqualsAtomicProposition(tTerm, tTerm);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tAtomicProposition rewrite( rview );
    impl_tTerm* tTerm_1;
    impl_tTerm* tTerm_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tTerm: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tTerm rewrite(rview) =0;
};
class impl_tTerm_ProductList:public impl_tTerm{
public:
    enum_operators prod_sel() const
	{ return sel_ProductList; }
    explicit impl_tTerm_ProductList(tProduct_list);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tTerm rewrite( rview );
    impl_tProduct_list* tProduct_list_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tTerm_Product:public impl_tTerm{
public:
    enum_operators prod_sel() const
	{ return sel_Product; }
    explicit impl_tTerm_Product(integer, tTerm);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tTerm rewrite( rview );
    impl_integer* integer_1;
    impl_tTerm* tTerm_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tTerm_Difference:public impl_tTerm{
public:
    enum_operators prod_sel() const
	{ return sel_Difference; }
    explicit impl_tTerm_Difference(tTerm, tTerm);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tTerm rewrite( rview );
    impl_tTerm* tTerm_1;
    impl_tTerm* tTerm_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tTerm_Sum:public impl_tTerm{
public:
    enum_operators prod_sel() const
	{ return sel_Sum; }
    explicit impl_tTerm_Sum(tTerm, tTerm);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tTerm rewrite( rview );
    impl_tTerm* tTerm_1;
    impl_tTerm* tTerm_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tTerm_Number:public impl_tTerm{
public:
    enum_operators prod_sel() const
	{ return sel_Number; }
    explicit impl_tTerm_Number(integer);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tTerm rewrite( rview );
    impl_integer* integer_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tTerm_Node:public impl_tTerm{
public:
    enum_operators prod_sel() const
	{ return sel_Node; }
    explicit impl_tTerm_Node(integer);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tTerm rewrite( rview );
    impl_integer* integer_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tProduct_list: public impl_abstract_list{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    enum_operators prod_sel() const{
	return is_nil() ? sel_NiltProduct_list: sel_ConstProduct_list;
    }
    explicit impl_tProduct_list(tTerm = 0, tProduct_list = 0);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);
    friend tProduct_list concat(c_tProduct_list, c_tProduct_list);
    tProduct_list reverse() const;
    tProduct_list rewrite(rview);
    tTerm last() const;
    tProduct_list append(tTerm);
    tProduct_list map(tTerm (*)(tTerm));
    tProduct_list filter( bool (*)(tTerm));
    tProduct_list merge( tProduct_list, tTerm (*)(tTerm, tTerm));
    tTerm reduce( tTerm, tTerm (*)(tTerm, tTerm));
    bool is_nil() const;
    tTerm tTerm_1;
    tProduct_list tProduct_list_1;
private:
    impl_tProduct_list* nil_rewrite(rview);
    impl_tProduct_list* cons_rewrite(rview);
    void nil_do_unparse(printer_functor, uview);
    void do_unparse(printer_functor, uview);
};
class impl_tBuechiAutomata: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    BuechiAutomata_p automata;
    tBuechiAutomata rewrite(rview) =0;
};
class impl_tBuechiAutomata_BuechiNull:public impl_tBuechiAutomata{
public:
    enum_operators prod_sel() const
	{ return sel_BuechiNull; }
    explicit impl_tBuechiAutomata_BuechiNull();

    tBuechiAutomata rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_tBuechiAutomata_BuechiAutomaton:public impl_tBuechiAutomata{
public:
    enum_operators prod_sel() const
	{ return sel_BuechiAutomaton; }
    explicit impl_tBuechiAutomata_BuechiAutomaton(tBuechiRules, tAcceptingSet);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tBuechiAutomata rewrite( rview );
    impl_tBuechiRules* tBuechiRules_1;
    impl_tAcceptingSet* tAcceptingSet_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tBuechiRules: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tBuechiRules rewrite(rview) =0;
};
class impl_tBuechiRules_BuechiRules:public impl_tBuechiRules{
public:
    enum_operators prod_sel() const
	{ return sel_BuechiRules; }
    explicit impl_tBuechiRules_BuechiRules(tBuechiRules, tBuechiRules);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tBuechiRules rewrite( rview );
    impl_tBuechiRules* tBuechiRules_1;
    impl_tBuechiRules* tBuechiRules_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tBuechiRules_ExpandedBuechiRule:public impl_tBuechiRules{
public:
    enum_operators prod_sel() const
	{ return sel_ExpandedBuechiRule; }
    explicit impl_tBuechiRules_ExpandedBuechiRule(integer, tFormula, integer);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tBuechiRules rewrite( rview );
    impl_integer* integer_1;
    impl_tFormula* tFormula_1;
    impl_integer* integer_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tBuechiRules_BuechiRule:public impl_tBuechiRules{
public:
    enum_operators prod_sel() const
	{ return sel_BuechiRule; }
    explicit impl_tBuechiRules_BuechiRule(integer, tTransitionRules);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tBuechiRules rewrite( rview );
    impl_integer* integer_1;
    impl_tTransitionRules* tTransitionRules_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tBuechiRules_EmptyBuechiRules:public impl_tBuechiRules{
public:
    enum_operators prod_sel() const
	{ return sel_EmptyBuechiRules; }
    explicit impl_tBuechiRules_EmptyBuechiRules();

    tBuechiRules rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_tTransitionRules: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tTransitionRules rewrite(rview) =0;
};
class impl_tTransitionRules_TransitionRules:public impl_tTransitionRules{
public:
    enum_operators prod_sel() const
	{ return sel_TransitionRules; }
    explicit impl_tTransitionRules_TransitionRules(tTransitionRules, tTransitionRules);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tTransitionRules rewrite( rview );
    impl_tTransitionRules* tTransitionRules_1;
    impl_tTransitionRules* tTransitionRules_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tTransitionRules_TransitionRule:public impl_tTransitionRules{
public:
    enum_operators prod_sel() const
	{ return sel_TransitionRule; }
    explicit impl_tTransitionRules_TransitionRule(tFormula, integer);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tTransitionRules rewrite( rview );
    impl_tFormula* tFormula_1;
    impl_integer* integer_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tTransitionRules_EmptyTransitionRules:public impl_tTransitionRules{
public:
    enum_operators prod_sel() const
	{ return sel_EmptyTransitionRules; }
    explicit impl_tTransitionRules_EmptyTransitionRules();

    tTransitionRules rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};
class impl_tAcceptingSet: public impl_abstract_phylum{
public:
    static const enum_phyla phylum_sel_;
    void fprintdot( FILE*, const char*, const char*, const char*, bool, bool, bool ) const;
    tAcceptingSet rewrite(rview) =0;
};
class impl_tAcceptingSet_AcceptingSet:public impl_tAcceptingSet{
public:
    enum_operators prod_sel() const
	{ return sel_AcceptingSet; }
    explicit impl_tAcceptingSet_AcceptingSet(tAcceptingSet, tAcceptingSet);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tAcceptingSet rewrite( rview );
    impl_tAcceptingSet* tAcceptingSet_1;
    impl_tAcceptingSet* tAcceptingSet_2;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tAcceptingSet_AcceptingState:public impl_tAcceptingSet{
public:
    enum_operators prod_sel() const
	{ return sel_AcceptingState; }
    explicit impl_tAcceptingSet_AcceptingState(integer);
    abstract_phylum subphylum(int) const;
    void set_subphylum(int, abstract_phylum);

    tAcceptingSet rewrite( rview );
    impl_integer* integer_1;
private:
    void do_unparse(printer_functor, uview);
};
class impl_tAcceptingSet_EmptyAcceptingSet:public impl_tAcceptingSet{
public:
    enum_operators prod_sel() const
	{ return sel_EmptyAcceptingSet; }
    explicit impl_tAcceptingSet_EmptyAcceptingSet();

    tAcceptingSet rewrite( rview );
private:
    void do_unparse(printer_functor, uview);
};

//} // namespace Phylum


extern bool kc_storageclass_still_uniq[];

typedef struct {
    int created;
    int existing_not_found;
    int free_called[2];
    int freed[2];
} KC_OPERATOR_STATISTICS;

#ifdef KC_STATISTICS
# define print_operator_statistics(kc_f) do_print_operator_statistics(kc_f)
void	do_print_operator_statistics(FILE*);
#else
# define print_operator_statistics(kc_f)
#endif

typedef class hashtable_struct_t* hashtable_t;
void	ht_static (kc_storageclass_t);
void	ht_dynamic (kc_storageclass_t);
void	ht_inc_level (kc_storageclass_t);
void	ht_dec_level (kc_storageclass_t);
void	ht_free_level (kc_storageclass_t);
hashtable_t	ht_create_simple ();
hashtable_t	ht_assign (hashtable_t, kc_storageclass_t, bool still_unique=false);
hashtable_t	ht_assigned (kc_storageclass_t);
void	ht_clear (hashtable_t);
void	ht_delete (hashtable_t);
const char *phylumname_or_error ( enum_phyla );
const char *kc_operatorname_or_error ( enum_operators );


void fprintdotprologue ( FILE* );
void fprintdotepilogue ( FILE* );

} // namespace kc
#endif // KC_TYPES_HEADER
