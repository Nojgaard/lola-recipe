/* translation of file(s)
	"Frontend/Parser/formula_abstract.k"
	"Frontend/Parser/formula_rewrite.k"
	"Frontend/Parser/formula_unparse.k"
 */
/* generated by:
 *  @(#)$Author: Kimwitu++ version 2.3.13 (C) 1998-2008 Humboldt-Universitaet zu Berlin $
 */
#define KC_REWRITE

#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>
#include "ast-system-k.h"
#include "ast-system-rk.h"


namespace kc {
base_rview_class base_rview;
goodbye_doublearrows_class goodbye_doublearrows;
goodbye_singlearrows_class goodbye_singlearrows;
goodbye_xor_class goodbye_xor;
goodbye_fireable_class goodbye_fireable;
goodbye_initial_class goodbye_initial;
sides_class sides;
productlists_class productlists;
leq_class leq;
tautology_class tautology;
singletemporal_class singletemporal;
simpleneg_class simpleneg;
booleanlists_class booleanlists;
ctloperators_class ctloperators;
rbuechi_class rbuechi;

impl_rviews rviews[] = {
    {"base_rview",&base_rview},
    {"goodbye_doublearrows",&goodbye_doublearrows},
    {"goodbye_singlearrows",&goodbye_singlearrows},
    {"goodbye_xor",&goodbye_xor},
    {"goodbye_fireable",&goodbye_fireable},
    {"goodbye_initial",&goodbye_initial},
    {"sides",&sides},
    {"productlists",&productlists},
    {"leq",&leq},
    {"tautology",&tautology},
    {"singletemporal",&singletemporal},
    {"simpleneg",&simpleneg},
    {"booleanlists",&booleanlists},
    {"ctloperators",&ctloperators},
    {"rbuechi",&rbuechi},
    {0,0}
};

} // namespace kc
namespace kc { }
using namespace kc;
/* included stuff */
#line 24 "Frontend/Parser/formula_rewrite.k"
#include <Frontend/Parser/ast-system-rk.h>
#include <CoverGraph/CoverGraph.h>
#include <Net/Marking.h>
#include <Net/Net.h>

/*
Uncomment the next line to define a debug function that traces all matches in
the rewriting process.
*/
//#define KC_TRACE_REWRITE_RESULT(VIEW,FILE,LINE,NODE) { RT::rep->status("rewrite %s:%d", FILE, LINE); }

/*!
Count the rule applications
*/
size_t rule_applications = 0;
#define KC_TRACE_REWRITE_MATCH(VIEW,FILE,LINE,NODE) { ++rule_applications; }

integer plus( integer a, integer b ) {
    // +-----+-----+-----+-----+
    // |   + |   y |  oo | -oo |
    // +-----+-----+-----+-----+
    // |   x | x+y |  oo | -oo |
    // |  oo |  oo |  oo | n.d.|
    // | -oo | -oo | n.d.| -oo |
    // +-----+-----+-----+-----+

    // exclude undefinied behavior
    if(  (a->value == -OMEGA and b->value == OMEGA) ||
	    (a->value == OMEGA and b->value == -OMEGA))
    {
	RT::rep->status("error in formula: invalid addition of oo or appearance of oo on both sides of a comparison");
	RT::rep->abort(ERROR_SYNTAX);
    }

    if (a->value == OMEGA or b->value == OMEGA)
    {
	return mkinteger(OMEGA);
    }

    if (a->value == -OMEGA or b->value == -OMEGA)
    {
	return mkinteger(-OMEGA);
    }

    return mkinteger( a->value + b->value );
}

integer minus( integer a, integer b ) {
    // +-----+-----+-----+-----+
    // |   - |   y |  oo | -oo |
    // +-----+-----+-----+-----+
    // |   x | x-y | -oo |  oo |
    // |  oo |  oo | n.d.|  oo |
    // | -oo | -oo | -oo | n.d.|
    // +-----+-----+-----+-----+

    // exclude undefinied behavior
    if(  (a->value == OMEGA and b->value == OMEGA) ||
	    (a->value == -OMEGA and b->value == -OMEGA))
    {
	RT::rep->status("error in formula: invalid subtraction of oo or appearance of oo on both sides of a comparison");
	RT::rep->abort(ERROR_SYNTAX);
    }

    if (a->value == OMEGA or b->value == -OMEGA)
    {
	return mkinteger(OMEGA);
    }

    if (a->value == -OMEGA or b->value == OMEGA)
    {
	return mkinteger(-OMEGA);
    }

    return mkinteger( a->value - b->value );
}

integer mult( integer a, integer b ) {
    // exclude OMEGAS for now
    if(a->value == OMEGA || b->value == OMEGA || a->value == -OMEGA || b->value == -OMEGA)
    {
	RT::rep->status("error in formula: invalid multiplication with oo");
	RT::rep->abort(ERROR_SYNTAX);
    }

    return mkinteger( a->value * b->value );
}

/*!
This function unfolds the FIREABLE() predicate to a conjunction that contains,
for each preplace, a term from the arc weight.

\param x  the id of a transition
\return  a statpredicate that is true iff the given transition is fireable
*/
tStatePredicate FIREABLE_unfolder(const integer x)
{
    // start with TRUE and conjunct an atomic proposition for each preplace
    // (the TRUE predicate will be removed in later rewritings)
    tStatePredicate result = AtomicProposition(True());

    // iterate preset
    for (arrayindex_t p = 0; p < Net::CardArcs[TR][PRE][x->value]; ++p)
    {
	result = Conjunction(
	    result,
	    AtomicProposition(
		GreaterEqualAtomicProposition(
		    Node(mkinteger(Net::Arc[TR][PRE][x->value][p])),
		    Number(mkinteger(Net::Mult[TR][PRE][x->value][p]))
		)
	    )
	);
    }

    return result;
}

/*!
This function unfolds the INITIAL() predicate to a conjunction that contains
for each place a term from its initial marking.

\return  a statpredicate that is exactly true in the initial marking
*/
tStatePredicate INITIAL_unfolder()
{
    // start with TRUE and conjunct an atomic proposition for each place
    // (the TRUE predicate will be removed in later rewritings)
    tStatePredicate result = AtomicProposition(True());

    // iterate places
    for (arrayindex_t p = 0; p < Net::Card[PL]; ++p)
    {
	result = Conjunction(
	    result,
	    AtomicProposition(
		EqualsAtomicProposition(
		    Node(mkinteger(p)),
		    Number(mkinteger(Marking::Initial[p]))
		)
	    )
	);
    }

    return result;
}


#line  208 "ast-system-rk.cc"
/* end included stuff */


namespace kc {

#ifndef KC_TRACE_PROVIDED
#define KC_TRACE_PROVIDED(COND,FILE,LINE,NODE) COND
#endif
#ifndef KC_TRACE_REWRITE_MATCH
#define KC_TRACE_REWRITE_MATCH(VIEW,FILE,LINE,NODE)
#endif
#ifndef KC_TRACE_REWRITE_RESULT
#define KC_TRACE_REWRITE_RESULT(VIEW,FILE,LINE,NODE)
#endif

tFormula impl_tFormula_StatePredicateFormula::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case singletemporal_enum: {
	    singletemporal_class& kc_current_view=static_cast<singletemporal_class&>(kc_current_view_base);
#line 743 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 743, this);
#line 743 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 743 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(y);

#line  238 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",743,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 751 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 751, this);
#line 751 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 751 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(y);

#line  250 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",751,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 755 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 755, this);
#line 755 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 755 "Frontend/Parser/formula_rewrite.k"
		tFormula kc_result = StatePredicateFormula(Negation(y));

#line  262 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",755,kc_result);
		return (const_cast<const impl_tFormula*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tFormula_StatePredicateFormula* kc_result= StatePredicateFormula(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_DisjunctionList::rewrite(rview kc_current_view_base)
{
    tDisjunction_list l_tDisjunction_list_1 =
	tDisjunction_list_1->rewrite(kc_current_view_base);
    if ((l_tDisjunction_list_1 == tDisjunction_list_1))
	return this;
    else {
	impl_tStatePredicate_DisjunctionList* kc_result= DisjunctionList(l_tDisjunction_list_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_ConjunctionList::rewrite(rview kc_current_view_base)
{
    tConjunction_list l_tConjunction_list_1 =
	tConjunction_list_1->rewrite(kc_current_view_base);
    if ((l_tConjunction_list_1 == tConjunction_list_1))
	return this;
    else {
	impl_tStatePredicate_ConjunctionList* kc_result= ConjunctionList(l_tConjunction_list_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_EX::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_EX* kc_result= EX(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_AX::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_AX* kc_result= AX(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_EG::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_EG* kc_result= EG(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_AG::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_AG* kc_result= AG(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_EF::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_EF* kc_result= EF(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_AF::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_AF* kc_result= AF(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_ER::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    tStatePredicate l_tStatePredicate_2 =
	tStatePredicate_2->rewrite(kc_current_view_base);
    if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tStatePredicate_2 == tStatePredicate_2))
	return this;
    else {
	impl_tStatePredicate_ER* kc_result= ER(l_tStatePredicate_1, l_tStatePredicate_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_AR::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    tStatePredicate l_tStatePredicate_2 =
	tStatePredicate_2->rewrite(kc_current_view_base);
    if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tStatePredicate_2 == tStatePredicate_2))
	return this;
    else {
	impl_tStatePredicate_AR* kc_result= AR(l_tStatePredicate_1, l_tStatePredicate_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_EU::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    tStatePredicate l_tStatePredicate_2 =
	tStatePredicate_2->rewrite(kc_current_view_base);
    if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tStatePredicate_2 == tStatePredicate_2))
	return this;
    else {
	impl_tStatePredicate_EU* kc_result= EU(l_tStatePredicate_1, l_tStatePredicate_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_AU::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    tStatePredicate l_tStatePredicate_2 =
	tStatePredicate_2->rewrite(kc_current_view_base);
    if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tStatePredicate_2 == tStatePredicate_2))
	return this;
    else {
	impl_tStatePredicate_AU* kc_result= AU(l_tStatePredicate_1, l_tStatePredicate_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_Release::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    tStatePredicate l_tStatePredicate_2 =
	tStatePredicate_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case tautology_enum: {
	    tautology_class& kc_current_view=static_cast<tautology_class&>(kc_current_view_base);
#line 461 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 461, this);
#line 461 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 461 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  461 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",461,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 470 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 470, this);
#line 470 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 470 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Always(x);

#line  473 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",470,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 491 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 491, this);
#line 491 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 491 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  485 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",491,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 494 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 494, this);
#line 494 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 494 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Always(x);

#line  497 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",494,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 458 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 458, this);
#line 458 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 458 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = y;

#line  509 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",458,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 473 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 473, this);
#line 473 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 473 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = y;

#line  521 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",473,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tStatePredicate_2 == tStatePredicate_2))
	return this;
    else {
	impl_tStatePredicate_Release* kc_result= Release(l_tStatePredicate_1, l_tStatePredicate_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_Until::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    tStatePredicate l_tStatePredicate_2 =
	tStatePredicate_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case tautology_enum: {
	    tautology_class& kc_current_view=static_cast<tautology_class&>(kc_current_view_base);
#line 455 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 455, this);
#line 455 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 455 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Eventually(x);

#line  556 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",455,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 467 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 467, this);
#line 467 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 467 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  568 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",467,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 485 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 485, this);
#line 485 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 485 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  580 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",485,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 488 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 488, this);
#line 488 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 488 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Eventually(x);

#line  592 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",488,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 654 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_NextState) && (l_tStatePredicate_2->prod_sel() == sel_NextState)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 654, this);
#line 654 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 654 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_2)->tStatePredicate_1;
#line 654 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = NextState(Until(x, y));

#line  606 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",654,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 452 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 452, this);
#line 452 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 452 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = y;

#line  618 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",452,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 464 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 464, this);
#line 464 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 464 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = y;

#line  630 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",464,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 657 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_2->prod_sel() == sel_Until) && (phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_2)->tStatePredicate_1->eq(l_tStatePredicate_1))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 657, this);
#line 657 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 657 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_2;
#line 657 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  644 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",657,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tStatePredicate_2 == tStatePredicate_2))
	return this;
    else {
	impl_tStatePredicate_Until* kc_result= Until(l_tStatePredicate_1, l_tStatePredicate_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_NextState::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case tautology_enum: {
	    tautology_class& kc_current_view=static_cast<tautology_class&>(kc_current_view_base);
#line 434 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 434, this);
#line 434 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 434 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  677 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",434,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 437 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 437, this);
#line 437 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 437 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  689 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",437,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_NextState* kc_result= NextState(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_Eventually::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case tautology_enum: {
	    tautology_class& kc_current_view=static_cast<tautology_class&>(kc_current_view_base);
#line 422 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 422, this);
#line 422 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 422 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  722 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",422,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 425 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 425, this);
#line 425 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 425 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  734 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",425,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 479 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 479, this);
#line 479 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 479 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  746 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",479,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 633 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 633, this);
#line 633 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_1;
#line 633 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  758 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",633,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 618 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 618, this);
#line 618 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_1;
#line 618 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  770 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",618,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_Eventually* kc_result= Eventually(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_Always::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case tautology_enum: {
	    tautology_class& kc_current_view=static_cast<tautology_class&>(kc_current_view_base);
#line 428 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 428, this);
#line 428 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 428 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  803 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",428,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 431 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 431, this);
#line 431 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 431 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  815 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",431,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 482 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 482, this);
#line 482 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 482 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  827 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",482,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 636 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 636, this);
#line 636 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_1;
#line 636 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  839 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",636,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_Always* kc_result= Always(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_ExPath::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case ctloperators_enum: {
	    ctloperators_class& kc_current_view=static_cast<ctloperators_class&>(kc_current_view_base);
#line 806 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 806, this);
#line 806 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 806 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = EU(AtomicProposition(True()), x);

#line  872 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",806,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 808 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_NextState)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 808, this);
#line 808 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 808 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = EX(x);

#line  884 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",808,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 811 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 811, this);
#line 811 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 811 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Negation(AU(AtomicProposition(True()), Negation(x)));

#line  896 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",811,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 813 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Until)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 813, this);
#line 813 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 813 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 813 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = EU(x, y);

#line  910 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",813,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 816 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Release)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 816, this);
#line 816 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Release*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 816 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Release*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 816 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Negation(AU(Negation(x), Negation(y)));

#line  924 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",816,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case tautology_enum: {
	    tautology_class& kc_current_view=static_cast<tautology_class&>(kc_current_view_base);
#line 651 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 651, this);
#line 651 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 651 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  940 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",651,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 645 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 645, this);
#line 645 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 645 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  952 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",645,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 440 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 440, this);
#line 440 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 440 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  964 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",440,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 443 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 443, this);
#line 443 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 443 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  976 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",443,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 500 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 500, this);
#line 500 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 500 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  988 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",500,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 506 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 506, this);
#line 506 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 506 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1000 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",506,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 627 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AllPath)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 627, this);
#line 627 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_1;
#line 627 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1012 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",627,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 630 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_ExPath)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 630, this);
#line 630 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_1;
#line 630 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1024 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",630,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 682 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Disjunction)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 682, this);
#line 682 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 682 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 682 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Disjunction(ExPath(x), ExPath(y));

#line  1038 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",682,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_ExPath* kc_result= ExPath(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_AllPath::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case ctloperators_enum: {
	    ctloperators_class& kc_current_view=static_cast<ctloperators_class&>(kc_current_view_base);
#line 819 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 819, this);
#line 819 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 819 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AU(AtomicProposition(True()), x);

#line  1071 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",819,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 821 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_NextState)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 821, this);
#line 821 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 821 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AX(x);

#line  1083 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",821,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 824 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 824, this);
#line 824 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 824 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Negation(EU(AtomicProposition(True()), Negation(x)));

#line  1095 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",824,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 826 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Until)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 826, this);
#line 826 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 826 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 826 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AU(x, y);

#line  1109 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",826,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 829 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Release)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 829, this);
#line 829 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Release*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 829 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Release*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 829 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Negation(EU(Negation(x), Negation(y)));

#line  1123 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",829,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case tautology_enum: {
	    tautology_class& kc_current_view=static_cast<tautology_class&>(kc_current_view_base);
#line 648 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 648, this);
#line 648 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 648 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1139 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",648,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 639 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 639, this);
#line 639 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 639 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1151 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",639,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 642 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 642, this);
#line 642 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 642 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1163 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",642,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 446 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 446, this);
#line 446 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 446 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1175 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",446,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 449 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 449, this);
#line 449 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 449 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1187 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",449,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 497 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 497, this);
#line 497 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 497 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1199 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",497,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 503 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 503, this);
#line 503 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 503 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1211 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",503,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 621 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AllPath)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 621, this);
#line 621 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_1;
#line 621 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1223 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",621,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 624 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_ExPath)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 624, this);
#line 624 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_1;
#line 624 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1235 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",624,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 685 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Conjunction)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 685, this);
#line 685 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 685 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 685 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Conjunction(AllPath(x), AllPath(y));

#line  1249 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",685,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_AllPath* kc_result= AllPath(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_Equivalence::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    tStatePredicate l_tStatePredicate_2 =
	tStatePredicate_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case goodbye_doublearrows_enum: {
	    goodbye_doublearrows_class& kc_current_view=static_cast<goodbye_doublearrows_class&>(kc_current_view_base);
#line 192 "Frontend/Parser/formula_rewrite.k"
	    { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 192, this);
#line 192 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 192 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 193 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Conjunction(Disjunction(x, Negation(y)), Disjunction(Negation(x), y));

#line  1286 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",193,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    }
	}
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tStatePredicate_2 == tStatePredicate_2))
	return this;
    else {
	impl_tStatePredicate_Equivalence* kc_result= Equivalence(l_tStatePredicate_1, l_tStatePredicate_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_Implication::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    tStatePredicate l_tStatePredicate_2 =
	tStatePredicate_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case goodbye_singlearrows_enum: {
	    goodbye_singlearrows_class& kc_current_view=static_cast<goodbye_singlearrows_class&>(kc_current_view_base);
#line 198 "Frontend/Parser/formula_rewrite.k"
	    { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 198, this);
#line 198 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 198 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 198 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Disjunction(Negation(x), y);

#line  1321 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",198,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    }
	}
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tStatePredicate_2 == tStatePredicate_2))
	return this;
    else {
	impl_tStatePredicate_Implication* kc_result= Implication(l_tStatePredicate_1, l_tStatePredicate_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_ExclusiveDisjunction::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    tStatePredicate l_tStatePredicate_2 =
	tStatePredicate_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case goodbye_xor_enum: {
	    goodbye_xor_class& kc_current_view=static_cast<goodbye_xor_class&>(kc_current_view_base);
#line 203 "Frontend/Parser/formula_rewrite.k"
	    { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 203, this);
#line 203 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 203 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 203 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Disjunction(Conjunction(x, Negation(y)), Conjunction(Negation(x), y));

#line  1356 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",203,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    }
	}
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tStatePredicate_2 == tStatePredicate_2))
	return this;
    else {
	impl_tStatePredicate_ExclusiveDisjunction* kc_result= ExclusiveDisjunction(l_tStatePredicate_1, l_tStatePredicate_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_Disjunction::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    tStatePredicate l_tStatePredicate_2 =
	tStatePredicate_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case booleanlists_enum: {
	    booleanlists_class& kc_current_view=static_cast<booleanlists_class&>(kc_current_view_base);
#line 791 "Frontend/Parser/formula_rewrite.k"
	    { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 791, this);
#line 791 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 791 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 791 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = DisjunctionList(ConstDisjunction_list(x, ConstDisjunction_list(y, NiltDisjunction_list())));

#line  1391 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",791,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    }
	}
	case tautology_enum: {
	    tautology_class& kc_current_view=static_cast<tautology_class&>(kc_current_view_base);
#line 527 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock) && (l_tStatePredicate_2->prod_sel() == sel_Disjunction) && (phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 527, this);
#line 527 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(True());

#line  1404 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",527,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 528 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock) && (l_tStatePredicate_2->prod_sel() == sel_Disjunction) && (phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 528, this);
#line 528 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(True());

#line  1414 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",528,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 529 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock) && (l_tStatePredicate_2->prod_sel() == sel_Disjunction) && (phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 529, this);
#line 529 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 529 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1426 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",529,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 530 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock) && (l_tStatePredicate_2->prod_sel() == sel_Disjunction) && (phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 530, this);
#line 530 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 530 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1438 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",530,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 517 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock) && (l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 517, this);
#line 517 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(True());

#line  1448 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",517,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 518 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock) && (l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 518, this);
#line 518 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(True());

#line  1458 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",518,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 519 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock) && (l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 519, this);
#line 519 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 519 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1470 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",519,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 520 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock) && (l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 520, this);
#line 520 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 520 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1482 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",520,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 697 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (l_tStatePredicate_2->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 697, this);
#line 697 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 697 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate b = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_2)->tStatePredicate_1)->tStatePredicate_1;
#line 697 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = ExPath(Eventually(Disjunction(a, b)));

#line  1496 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",697,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 703 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_NextState) && (l_tStatePredicate_2->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_NextState)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 703, this);
#line 703 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 703 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate b = phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_2)->tStatePredicate_1)->tStatePredicate_1;
#line 703 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = ExPath(NextState(Disjunction(a, b)));

#line  1510 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",703,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 414 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 414, this);
#line 414 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_2;
#line 414 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1522 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",414,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 416 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 416, this);
#line 416 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate t = l_tStatePredicate_1;
#line 416 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = t;

#line  1534 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",416,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 668 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Eventually) && (l_tStatePredicate_2->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 668, this);
#line 668 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 668 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_2)->tStatePredicate_1;
#line 668 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Eventually(Disjunction(x, y));

#line  1548 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",668,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 677 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_NextState) && (l_tStatePredicate_2->prod_sel() == sel_NextState)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 677, this);
#line 677 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 677 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_2)->tStatePredicate_1;
#line 677 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = NextState(Disjunction(x, y));

#line  1562 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",677,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 544 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Disjunction)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 544, this);
#line 544 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 544 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 544 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate z = l_tStatePredicate_2;
#line 544 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Disjunction(x, Disjunction(y, z));

#line  1578 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",544,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 413 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 413, this);
#line 413 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_1;
#line 413 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1590 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",413,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 415 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 415, this);
#line 415 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate t = l_tStatePredicate_2;
#line 415 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = t;

#line  1602 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",415,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tStatePredicate_2 == tStatePredicate_2))
	return this;
    else {
	impl_tStatePredicate_Disjunction* kc_result= Disjunction(l_tStatePredicate_1, l_tStatePredicate_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_Conjunction::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    tStatePredicate l_tStatePredicate_2 =
	tStatePredicate_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case booleanlists_enum: {
	    booleanlists_class& kc_current_view=static_cast<booleanlists_class&>(kc_current_view_base);
#line 787 "Frontend/Parser/formula_rewrite.k"
	    { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 787, this);
#line 787 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_1;
#line 787 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = l_tStatePredicate_2;
#line 787 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = ConjunctionList(ConstConjunction_list(x, ConstConjunction_list(y, NiltConjunction_list())));

#line  1639 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",787,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    }
	}
	case tautology_enum: {
	    tautology_class& kc_current_view=static_cast<tautology_class&>(kc_current_view_base);
#line 532 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock) && (l_tStatePredicate_2->prod_sel() == sel_Conjunction) && (phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 532, this);
#line 532 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(False());

#line  1652 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",532,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 533 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock) && (l_tStatePredicate_2->prod_sel() == sel_Conjunction) && (phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 533, this);
#line 533 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(False());

#line  1662 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",533,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 534 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock) && (l_tStatePredicate_2->prod_sel() == sel_Conjunction) && (phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 534, this);
#line 534 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 534 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1674 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",534,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 535 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock) && (l_tStatePredicate_2->prod_sel() == sel_Conjunction) && (phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_2)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 535, this);
#line 535 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 535 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1686 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",535,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 522 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock) && (l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 522, this);
#line 522 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(False());

#line  1696 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",522,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 523 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock) && (l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 523, this);
#line 523 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(False());

#line  1706 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",523,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 524 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock) && (l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 524, this);
#line 524 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 524 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1718 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",524,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 525 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock) && (l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 525, this);
#line 525 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = l_tStatePredicate_2;
#line 525 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  1730 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",525,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 694 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (l_tStatePredicate_2->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 694, this);
#line 694 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 694 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate b = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_2)->tStatePredicate_1)->tStatePredicate_1;
#line 694 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AllPath(Always(Conjunction(a, b)));

#line  1744 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",694,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 700 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_NextState) && (l_tStatePredicate_2->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_2)->tStatePredicate_1->prod_sel() == sel_NextState)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 700, this);
#line 700 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 700 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate b = phylum_cast<const impl_tStatePredicate_NextState*>(phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_2)->tStatePredicate_1)->tStatePredicate_1;
#line 700 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AllPath(NextState(Conjunction(a, b)));

#line  1758 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",700,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 408 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 408, this);
#line 408 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_2;
#line 408 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1770 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",408,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 410 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 410, this);
#line 410 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate f = l_tStatePredicate_1;
#line 410 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = f;

#line  1782 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",410,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 671 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Always) && (l_tStatePredicate_2->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 671, this);
#line 671 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 671 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_2)->tStatePredicate_1;
#line 671 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Always(Conjunction(x, y));

#line  1796 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",671,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 674 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_NextState) && (l_tStatePredicate_2->prod_sel() == sel_NextState)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 674, this);
#line 674 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 674 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_2)->tStatePredicate_1;
#line 674 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = NextState(Conjunction(x, y));

#line  1810 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",674,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 541 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Conjunction)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 541, this);
#line 541 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 541 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 541 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate z = l_tStatePredicate_2;
#line 541 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Conjunction(x, Conjunction(y, z));

#line  1826 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",541,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 407 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 407, this);
#line 407 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate a = l_tStatePredicate_1;
#line 407 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = a;

#line  1838 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",407,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 409 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_2->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_2)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 409, this);
#line 409 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate f = l_tStatePredicate_2;
#line 409 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = f;

#line  1850 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",409,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tStatePredicate_2 == tStatePredicate_2))
	return this;
    else {
	impl_tStatePredicate_Conjunction* kc_result= Conjunction(l_tStatePredicate_1, l_tStatePredicate_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_Negation::rewrite(rview kc_current_view_base)
{
    tStatePredicate l_tStatePredicate_1 =
	tStatePredicate_1->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case simpleneg_enum: {
	    simpleneg_class& kc_current_view=static_cast<simpleneg_class&>(kc_current_view_base);
#line 766 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 766, this);
#line 766 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(False());

#line  1881 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",766,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 769 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 769, this);
#line 769 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(True());

#line  1891 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",769,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 772 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 772, this);
#line 772 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(NoDeadlock());

#line  1901 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",772,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 775 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 775, this);
#line 775 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(Deadlock());

#line  1911 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",775,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 778 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_GreaterAtomicProposition)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 778, this);
#line 778 "Frontend/Parser/formula_rewrite.k"
		const tTerm p = phylum_cast<const impl_tAtomicProposition_GreaterAtomicProposition*>(phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1)->tTerm_1;
#line 778 "Frontend/Parser/formula_rewrite.k"
		const tTerm n = phylum_cast<const impl_tAtomicProposition_GreaterAtomicProposition*>(phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1)->tTerm_2;
#line 778 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(LessEqualAtomicProposition(p, n));

#line  1925 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",778,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 781 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_LessEqualAtomicProposition)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 781, this);
#line 781 "Frontend/Parser/formula_rewrite.k"
		const tTerm p = phylum_cast<const impl_tAtomicProposition_LessEqualAtomicProposition*>(phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1)->tTerm_1;
#line 781 "Frontend/Parser/formula_rewrite.k"
		const tTerm n = phylum_cast<const impl_tAtomicProposition_LessEqualAtomicProposition*>(phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1)->tTerm_2;
#line 781 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(GreaterAtomicProposition(p, n));

#line  1939 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",781,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 760 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Conjunction)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 760, this);
#line 760 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 760 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 760 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Disjunction(Negation(x), Negation(y));

#line  1953 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",760,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 763 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Disjunction)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 763, this);
#line 763 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 763 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 763 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Conjunction(Negation(x), Negation(y));

#line  1967 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",763,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case tautology_enum: {
	    tautology_class& kc_current_view=static_cast<tautology_class&>(kc_current_view_base);
#line 563 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_GreaterAtomicProposition)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 563, this);
#line 563 "Frontend/Parser/formula_rewrite.k"
		const tTerm p = phylum_cast<const impl_tAtomicProposition_GreaterAtomicProposition*>(phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1)->tTerm_1;
#line 563 "Frontend/Parser/formula_rewrite.k"
		const tTerm n = phylum_cast<const impl_tAtomicProposition_GreaterAtomicProposition*>(phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1)->tTerm_2;
#line 563 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(LessEqualAtomicProposition(p, n));

#line  1985 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",563,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 566 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_LessEqualAtomicProposition)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 566, this);
#line 566 "Frontend/Parser/formula_rewrite.k"
		const tTerm p = phylum_cast<const impl_tAtomicProposition_LessEqualAtomicProposition*>(phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1)->tTerm_1;
#line 566 "Frontend/Parser/formula_rewrite.k"
		const tTerm n = phylum_cast<const impl_tAtomicProposition_LessEqualAtomicProposition*>(phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1)->tTerm_2;
#line 566 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(GreaterAtomicProposition(p, n));

#line  1999 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",566,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 569 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_True)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 569, this);
#line 569 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(False());

#line  2009 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",569,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 572 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_False)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 572, this);
#line 572 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(True());

#line  2019 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",572,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 575 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 575, this);
#line 575 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(NoDeadlock());

#line  2029 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",575,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 578 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(l_tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 578, this);
#line 578 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AtomicProposition(Deadlock());

#line  2039 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",578,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 583 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Negation)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 583, this);
#line 583 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Negation*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 583 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = x;

#line  2051 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",583,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 586 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Conjunction)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 586, this);
#line 586 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 586 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Conjunction*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 586 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Disjunction(Negation(x), Negation(y));

#line  2065 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",586,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 589 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Disjunction)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 589, this);
#line 589 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 589 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Disjunction*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 589 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Conjunction(Negation(x), Negation(y));

#line  2079 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",589,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 594 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_AllPath)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 594, this);
#line 594 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_AllPath*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 594 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = ExPath(Negation(x));

#line  2091 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",594,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 597 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_ExPath)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 597, this);
#line 597 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_ExPath*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 597 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = AllPath(Negation(x));

#line  2103 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",597,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 600 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Always)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 600, this);
#line 600 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Always*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 600 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Eventually(Negation(x));

#line  2115 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",600,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 603 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Eventually)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 603, this);
#line 603 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Eventually*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 603 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Always(Negation(x));

#line  2127 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",603,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 606 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_NextState)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 606, this);
#line 606 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_NextState*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 606 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = NextState(Negation(x));

#line  2139 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",606,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 609 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Until)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 609, this);
#line 609 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 609 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Until*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 609 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Release(Negation(x), Negation(y));

#line  2153 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",609,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 612 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_Release)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 612, this);
#line 612 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate x = phylum_cast<const impl_tStatePredicate_Release*>(l_tStatePredicate_1)->tStatePredicate_1;
#line 612 "Frontend/Parser/formula_rewrite.k"
		const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Release*>(l_tStatePredicate_1)->tStatePredicate_2;
#line 612 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Until(Negation(x), Negation(y));

#line  2167 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",612,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tStatePredicate_1 == tStatePredicate_1))
	return this;
    else {
	impl_tStatePredicate_Negation* kc_result= Negation(l_tStatePredicate_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tStatePredicate impl_tStatePredicate_AtomicProposition::rewrite(rview kc_current_view_base)
{
    tAtomicProposition l_tAtomicProposition_1 =
	tAtomicProposition_1->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case leq_enum: {
	    leq_class& kc_current_view=static_cast<leq_class&>(kc_current_view_base);
#line 379 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tAtomicProposition_1->prod_sel() == sel_EqualsAtomicProposition) && (phylum_cast<const impl_tAtomicProposition_EqualsAtomicProposition*>(l_tAtomicProposition_1)->tTerm_2->prod_sel() == sel_Number)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 379, this);
#line 379 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = phylum_cast<const impl_tAtomicProposition_EqualsAtomicProposition*>(l_tAtomicProposition_1)->tTerm_1;
#line 379 "Frontend/Parser/formula_rewrite.k"
		const tTerm n = phylum_cast<const impl_tAtomicProposition_EqualsAtomicProposition*>(l_tAtomicProposition_1)->tTerm_2;
#line 379 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(phylum_cast<const impl_tAtomicProposition_EqualsAtomicProposition*>(l_tAtomicProposition_1)->tTerm_2)->integer_1;
#line 379 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Conjunction(AtomicProposition(LessEqualAtomicProposition(x, n)), AtomicProposition(GreaterAtomicProposition(x, Number(minus(y, mkinteger(1))))));

#line  2204 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",379,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 382 "Frontend/Parser/formula_rewrite.k"
		if ((l_tAtomicProposition_1->prod_sel() == sel_NotEqualsAtomicProposition) && (phylum_cast<const impl_tAtomicProposition_NotEqualsAtomicProposition*>(l_tAtomicProposition_1)->tTerm_2->prod_sel() == sel_Number)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 382, this);
#line 382 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = phylum_cast<const impl_tAtomicProposition_NotEqualsAtomicProposition*>(l_tAtomicProposition_1)->tTerm_1;
#line 382 "Frontend/Parser/formula_rewrite.k"
		const tTerm n = phylum_cast<const impl_tAtomicProposition_NotEqualsAtomicProposition*>(l_tAtomicProposition_1)->tTerm_2;
#line 382 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(phylum_cast<const impl_tAtomicProposition_NotEqualsAtomicProposition*>(l_tAtomicProposition_1)->tTerm_2)->integer_1;
#line 382 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = Disjunction(AtomicProposition(LessEqualAtomicProposition(x, Number(minus(y, mkinteger(1))))), AtomicProposition(GreaterAtomicProposition(x, n)));

#line  2220 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",382,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case goodbye_initial_enum: {
	    goodbye_initial_class& kc_current_view=static_cast<goodbye_initial_class&>(kc_current_view_base);
#line 213 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tAtomicProposition_1->prod_sel() == sel_Initial)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 213, this);
#line 213 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = INITIAL_unfolder();

#line  2234 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",213,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case goodbye_fireable_enum: {
	    goodbye_fireable_class& kc_current_view=static_cast<goodbye_fireable_class&>(kc_current_view_base);
#line 208 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tAtomicProposition_1->prod_sel() == sel_Fireable)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 208, this);
#line 208 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tAtomicProposition_Fireable*>(l_tAtomicProposition_1)->integer_1;
#line 208 "Frontend/Parser/formula_rewrite.k"
		tStatePredicate kc_result = FIREABLE_unfolder(x);

#line  2250 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",208,kc_result);
		return (const_cast<const impl_tStatePredicate*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tAtomicProposition_1 == tAtomicProposition_1))
	return this;
    else {
	impl_tStatePredicate_AtomicProposition* kc_result= AtomicProposition(l_tAtomicProposition_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tConjunction_list impl_tConjunction_list::rewrite(rview kc_current_view_base)
{
    if (is_nil()) {
	return this;
    } else { // not Nil, Cons
	tStatePredicate l_tStatePredicate_1 =
	    tStatePredicate_1->rewrite(kc_current_view_base);
	tConjunction_list l_tConjunction_list_1 =
	    tConjunction_list_1->rewrite(kc_current_view_base);
	switch(kc_current_view_base) {
	    case booleanlists_enum: {
		booleanlists_class& kc_current_view=static_cast<booleanlists_class&>(kc_current_view_base);
#line 788 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_ConjunctionList)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 788, this);
#line 788 "Frontend/Parser/formula_rewrite.k"
		    const tConjunction_list x = phylum_cast<const impl_tStatePredicate_ConjunctionList*>(l_tStatePredicate_1)->tConjunction_list_1;
#line 788 "Frontend/Parser/formula_rewrite.k"
		    const tConjunction_list y = l_tConjunction_list_1;
#line 788 "Frontend/Parser/formula_rewrite.k"
		    tConjunction_list kc_result = concat(x, y);

#line  2290 "ast-system-rk.cc"
		    KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",788,kc_result);
		    return (const_cast<const impl_tConjunction_list*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

		} else
			goto kc_rewrite_default;
	    }
	    kc_rewrite_default:
	    default:;
	}
	if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tConjunction_list_1 == tConjunction_list_1))
	    return this;
	else {
	    impl_tConjunction_list* kc_result= ConstConjunction_list(l_tStatePredicate_1, l_tConjunction_list_1);
	    kc_result->rewrite_members(this);
	    return kc_result;
	}   }
}

tDisjunction_list impl_tDisjunction_list::rewrite(rview kc_current_view_base)
{
    if (is_nil()) {
	return this;
    } else { // not Nil, Cons
	tStatePredicate l_tStatePredicate_1 =
	    tStatePredicate_1->rewrite(kc_current_view_base);
	tDisjunction_list l_tDisjunction_list_1 =
	    tDisjunction_list_1->rewrite(kc_current_view_base);
	switch(kc_current_view_base) {
	    case booleanlists_enum: {
		booleanlists_class& kc_current_view=static_cast<booleanlists_class&>(kc_current_view_base);
#line 792 "Frontend/Parser/formula_rewrite.k"
		if ((l_tStatePredicate_1->prod_sel() == sel_DisjunctionList)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 792, this);
#line 792 "Frontend/Parser/formula_rewrite.k"
		    const tDisjunction_list x = phylum_cast<const impl_tStatePredicate_DisjunctionList*>(l_tStatePredicate_1)->tDisjunction_list_1;
#line 792 "Frontend/Parser/formula_rewrite.k"
		    const tDisjunction_list y = l_tDisjunction_list_1;
#line 792 "Frontend/Parser/formula_rewrite.k"
		    tDisjunction_list kc_result = concat(x, y);

#line  2330 "ast-system-rk.cc"
		    KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",792,kc_result);
		    return (const_cast<const impl_tDisjunction_list*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

		} else
			goto kc_rewrite_default;
	    }
	    kc_rewrite_default:
	    default:;
	}
	if ((l_tStatePredicate_1 == tStatePredicate_1) &&  (l_tDisjunction_list_1 == tDisjunction_list_1))
	    return this;
	else {
	    impl_tDisjunction_list* kc_result= ConstDisjunction_list(l_tStatePredicate_1, l_tDisjunction_list_1);
	    kc_result->rewrite_members(this);
	    return kc_result;
	}   }
}

tAtomicProposition impl_tAtomicProposition_Fireable::rewrite(rview kc_current_view_base)
{
    integer l_integer_1 =
	integer_1->rewrite(kc_current_view_base);
    if ((l_integer_1 == integer_1))
	return this;
    else {
	impl_tAtomicProposition_Fireable* kc_result= Fireable(l_integer_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tAtomicProposition impl_tAtomicProposition_Initial::rewrite(rview kc_current_view_base)
{
    return this;

}

tAtomicProposition impl_tAtomicProposition_Deadlock::rewrite(rview kc_current_view_base)
{
    return this;

}

tAtomicProposition impl_tAtomicProposition_NoDeadlock::rewrite(rview kc_current_view_base)
{
    return this;

}

tAtomicProposition impl_tAtomicProposition_False::rewrite(rview kc_current_view_base)
{
    return this;

}

tAtomicProposition impl_tAtomicProposition_True::rewrite(rview kc_current_view_base)
{
    return this;

}

tAtomicProposition impl_tAtomicProposition_LessEqualAtomicProposition::rewrite(rview kc_current_view_base)
{
    tTerm l_tTerm_1 =
	tTerm_1->rewrite(kc_current_view_base);
    tTerm l_tTerm_2 =
	tTerm_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case sides_enum: {
	    sides_class& kc_current_view=static_cast<sides_class&>(kc_current_view_base);
#line 277 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tTerm_1->prod_sel() == sel_Sum) && (phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_1->prod_sel() == sel_Number) && (l_tTerm_2->prod_sel() == sel_Number)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 277, this);
#line 277 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tTerm_Number*>(phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_1)->integer_1;
#line 277 "Frontend/Parser/formula_rewrite.k"
		const tTerm y = phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_2;
#line 277 "Frontend/Parser/formula_rewrite.k"
		const integer z = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 277 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = LessEqualAtomicProposition(y, Number(minus(z, x)));

#line  2412 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",277,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 341 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Number) && (l_tTerm_2->prod_sel() == sel_Number) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1->value <= phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1->value), "Frontend/Parser/formula_rewrite.k", 341, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 341, this);
#line 341 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1;
#line 341 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 341 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = True();

#line  2426 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",341,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 342 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Number) && (l_tTerm_2->prod_sel() == sel_Number) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1->value > phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1->value), "Frontend/Parser/formula_rewrite.k", 342, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 342, this);
#line 342 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1;
#line 342 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 342 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = False();

#line  2440 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",342,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 286 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Node) && (l_tTerm_2->prod_sel() == sel_Number)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 286, this);
#line 286 "Frontend/Parser/formula_rewrite.k"
		const tTerm n = l_tTerm_1;
#line 286 "Frontend/Parser/formula_rewrite.k"
		const tTerm m = l_tTerm_2;
#line 286 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = LessEqualAtomicProposition(Product(mkinteger(1), n), m);

#line  2454 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",286,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 330 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Number) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1->value == OMEGA), "Frontend/Parser/formula_rewrite.k", 330, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 330, this);
#line 330 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 330 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = True();

#line  2466 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",330,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 254 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Sum)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 254, this);
#line 254 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 254 "Frontend/Parser/formula_rewrite.k"
		const tTerm s = l_tTerm_2;
#line 254 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = LessEqualAtomicProposition(Difference(x, s), Number(mkinteger(0)));

#line  2480 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",254,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 261 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Product)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 261, this);
#line 261 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 261 "Frontend/Parser/formula_rewrite.k"
		const tTerm p = l_tTerm_2;
#line 261 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = LessEqualAtomicProposition(Difference(x, p), Number(mkinteger(0)));

#line  2494 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",261,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 268 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Node)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 268, this);
#line 268 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 268 "Frontend/Parser/formula_rewrite.k"
		const tTerm n = l_tTerm_2;
#line 268 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = LessEqualAtomicProposition(Difference(x, n), Number(mkinteger(0)));

#line  2508 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",268,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tTerm_1 == tTerm_1) &&  (l_tTerm_2 == tTerm_2))
	return this;
    else {
	impl_tAtomicProposition_LessEqualAtomicProposition* kc_result= LessEqualAtomicProposition(l_tTerm_1, l_tTerm_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tAtomicProposition impl_tAtomicProposition_LessAtomicProposition::rewrite(rview kc_current_view_base)
{
    tTerm l_tTerm_1 =
	tTerm_1->rewrite(kc_current_view_base);
    tTerm l_tTerm_2 =
	tTerm_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case leq_enum: {
	    leq_class& kc_current_view=static_cast<leq_class&>(kc_current_view_base);
#line 388 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tTerm_2->prod_sel() == sel_Number)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 388, this);
#line 388 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 388 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 388 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = LessEqualAtomicProposition(x, Number(minus(y, mkinteger(1))));

#line  2545 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",388,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case sides_enum: {
	    sides_class& kc_current_view=static_cast<sides_class&>(kc_current_view_base);
#line 278 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tTerm_1->prod_sel() == sel_Sum) && (phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_1->prod_sel() == sel_Number) && (l_tTerm_2->prod_sel() == sel_Number)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 278, this);
#line 278 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tTerm_Number*>(phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_1)->integer_1;
#line 278 "Frontend/Parser/formula_rewrite.k"
		const tTerm y = phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_2;
#line 278 "Frontend/Parser/formula_rewrite.k"
		const integer z = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 278 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = LessAtomicProposition(y, Number(minus(z, x)));

#line  2565 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",278,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 343 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Number) && (l_tTerm_2->prod_sel() == sel_Number) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1->value < phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1->value), "Frontend/Parser/formula_rewrite.k", 343, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 343, this);
#line 343 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1;
#line 343 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 343 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = True();

#line  2579 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",343,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 344 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Number) && (l_tTerm_2->prod_sel() == sel_Number) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1->value >= phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1->value), "Frontend/Parser/formula_rewrite.k", 344, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 344, this);
#line 344 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1;
#line 344 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 344 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = False();

#line  2593 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",344,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 287 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Node) && (l_tTerm_2->prod_sel() == sel_Number)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 287, this);
#line 287 "Frontend/Parser/formula_rewrite.k"
		const tTerm n = l_tTerm_1;
#line 287 "Frontend/Parser/formula_rewrite.k"
		const tTerm m = l_tTerm_2;
#line 287 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = LessAtomicProposition(Product(mkinteger(1), n), m);

#line  2607 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",287,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 324 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Number) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1->value == OMEGA), "Frontend/Parser/formula_rewrite.k", 324, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 324, this);
#line 324 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 324 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 324 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = LessEqualAtomicProposition(x, Number(mkinteger(FINITE)));

#line  2621 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",324,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 255 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Sum)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 255, this);
#line 255 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 255 "Frontend/Parser/formula_rewrite.k"
		const tTerm s = l_tTerm_2;
#line 255 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = LessAtomicProposition(Difference(x, s), Number(mkinteger(0)));

#line  2635 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",255,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 262 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Product)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 262, this);
#line 262 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 262 "Frontend/Parser/formula_rewrite.k"
		const tTerm p = l_tTerm_2;
#line 262 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = LessAtomicProposition(Difference(x, p), Number(mkinteger(0)));

#line  2649 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",262,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 269 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Node)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 269, this);
#line 269 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 269 "Frontend/Parser/formula_rewrite.k"
		const tTerm n = l_tTerm_2;
#line 269 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = LessAtomicProposition(Difference(x, n), Number(mkinteger(0)));

#line  2663 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",269,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tTerm_1 == tTerm_1) &&  (l_tTerm_2 == tTerm_2))
	return this;
    else {
	impl_tAtomicProposition_LessAtomicProposition* kc_result= LessAtomicProposition(l_tTerm_1, l_tTerm_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tAtomicProposition impl_tAtomicProposition_GreaterEqualAtomicProposition::rewrite(rview kc_current_view_base)
{
    tTerm l_tTerm_1 =
	tTerm_1->rewrite(kc_current_view_base);
    tTerm l_tTerm_2 =
	tTerm_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case leq_enum: {
	    leq_class& kc_current_view=static_cast<leq_class&>(kc_current_view_base);
#line 385 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tTerm_2->prod_sel() == sel_Number)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 385, this);
#line 385 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 385 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 385 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = GreaterAtomicProposition(x, Number(minus(y, mkinteger(1))));

#line  2700 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",385,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case sides_enum: {
	    sides_class& kc_current_view=static_cast<sides_class&>(kc_current_view_base);
#line 279 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tTerm_1->prod_sel() == sel_Sum) && (phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_1->prod_sel() == sel_Number) && (l_tTerm_2->prod_sel() == sel_Number)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 279, this);
#line 279 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tTerm_Number*>(phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_1)->integer_1;
#line 279 "Frontend/Parser/formula_rewrite.k"
		const tTerm y = phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_2;
#line 279 "Frontend/Parser/formula_rewrite.k"
		const integer z = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 279 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = GreaterEqualAtomicProposition(y, Number(minus(z, x)));

#line  2720 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",279,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 345 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Number) && (l_tTerm_2->prod_sel() == sel_Number) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1->value >= phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1->value), "Frontend/Parser/formula_rewrite.k", 345, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 345, this);
#line 345 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1;
#line 345 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 345 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = True();

#line  2734 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",345,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 346 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Number) && (l_tTerm_2->prod_sel() == sel_Number) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1->value < phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1->value), "Frontend/Parser/formula_rewrite.k", 346, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 346, this);
#line 346 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1;
#line 346 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 346 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = False();

#line  2748 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",346,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 288 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Node) && (l_tTerm_2->prod_sel() == sel_Number)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 288, this);
#line 288 "Frontend/Parser/formula_rewrite.k"
		const tTerm n = l_tTerm_1;
#line 288 "Frontend/Parser/formula_rewrite.k"
		const tTerm m = l_tTerm_2;
#line 288 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = GreaterEqualAtomicProposition(Product(mkinteger(1), n), m);

#line  2762 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",288,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 333 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Number) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1->value == OMEGA), "Frontend/Parser/formula_rewrite.k", 333, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 333, this);
#line 333 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 333 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 333 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = LessEqualAtomicProposition(Product(mkinteger(-1), x), Number(minus(mkinteger(0), y)));

#line  2776 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",333,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 256 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Sum)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 256, this);
#line 256 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 256 "Frontend/Parser/formula_rewrite.k"
		const tTerm s = l_tTerm_2;
#line 256 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = GreaterEqualAtomicProposition(Difference(x, s), Number(mkinteger(0)));

#line  2790 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",256,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 263 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Product)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 263, this);
#line 263 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 263 "Frontend/Parser/formula_rewrite.k"
		const tTerm p = l_tTerm_2;
#line 263 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = GreaterEqualAtomicProposition(Difference(x, p), Number(mkinteger(0)));

#line  2804 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",263,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 270 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Node)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 270, this);
#line 270 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 270 "Frontend/Parser/formula_rewrite.k"
		const tTerm n = l_tTerm_2;
#line 270 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = GreaterEqualAtomicProposition(Difference(x, n), Number(mkinteger(0)));

#line  2818 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",270,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tTerm_1 == tTerm_1) &&  (l_tTerm_2 == tTerm_2))
	return this;
    else {
	impl_tAtomicProposition_GreaterEqualAtomicProposition* kc_result= GreaterEqualAtomicProposition(l_tTerm_1, l_tTerm_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tAtomicProposition impl_tAtomicProposition_GreaterAtomicProposition::rewrite(rview kc_current_view_base)
{
    tTerm l_tTerm_1 =
	tTerm_1->rewrite(kc_current_view_base);
    tTerm l_tTerm_2 =
	tTerm_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case sides_enum: {
	    sides_class& kc_current_view=static_cast<sides_class&>(kc_current_view_base);
#line 280 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tTerm_1->prod_sel() == sel_Sum) && (phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_1->prod_sel() == sel_Number) && (l_tTerm_2->prod_sel() == sel_Number)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 280, this);
#line 280 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tTerm_Number*>(phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_1)->integer_1;
#line 280 "Frontend/Parser/formula_rewrite.k"
		const tTerm y = phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_2;
#line 280 "Frontend/Parser/formula_rewrite.k"
		const integer z = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 280 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = GreaterAtomicProposition(y, Number(minus(z, x)));

#line  2857 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",280,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 347 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Number) && (l_tTerm_2->prod_sel() == sel_Number) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1->value > phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1->value), "Frontend/Parser/formula_rewrite.k", 347, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 347, this);
#line 347 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1;
#line 347 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 347 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = True();

#line  2871 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",347,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 348 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Number) && (l_tTerm_2->prod_sel() == sel_Number) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1->value <= phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1->value), "Frontend/Parser/formula_rewrite.k", 348, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 348, this);
#line 348 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1;
#line 348 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 348 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = False();

#line  2885 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",348,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 289 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Node) && (l_tTerm_2->prod_sel() == sel_Number)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 289, this);
#line 289 "Frontend/Parser/formula_rewrite.k"
		const tTerm n = l_tTerm_1;
#line 289 "Frontend/Parser/formula_rewrite.k"
		const tTerm m = l_tTerm_2;
#line 289 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = GreaterAtomicProposition(Product(mkinteger(1), n), m);

#line  2899 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",289,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 327 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Number) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1->value == OMEGA), "Frontend/Parser/formula_rewrite.k", 327, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 327, this);
#line 327 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 327 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = False();

#line  2911 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",327,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 257 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Sum)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 257, this);
#line 257 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 257 "Frontend/Parser/formula_rewrite.k"
		const tTerm s = l_tTerm_2;
#line 257 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = GreaterAtomicProposition(Difference(x, s), Number(mkinteger(0)));

#line  2925 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",257,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 264 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Product)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 264, this);
#line 264 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 264 "Frontend/Parser/formula_rewrite.k"
		const tTerm p = l_tTerm_2;
#line 264 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = GreaterAtomicProposition(Difference(x, p), Number(mkinteger(0)));

#line  2939 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",264,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 271 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Node)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 271, this);
#line 271 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 271 "Frontend/Parser/formula_rewrite.k"
		const tTerm n = l_tTerm_2;
#line 271 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = GreaterAtomicProposition(Difference(x, n), Number(mkinteger(0)));

#line  2953 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",271,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tTerm_1 == tTerm_1) &&  (l_tTerm_2 == tTerm_2))
	return this;
    else {
	impl_tAtomicProposition_GreaterAtomicProposition* kc_result= GreaterAtomicProposition(l_tTerm_1, l_tTerm_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tAtomicProposition impl_tAtomicProposition_NotEqualsAtomicProposition::rewrite(rview kc_current_view_base)
{
    tTerm l_tTerm_1 =
	tTerm_1->rewrite(kc_current_view_base);
    tTerm l_tTerm_2 =
	tTerm_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case sides_enum: {
	    sides_class& kc_current_view=static_cast<sides_class&>(kc_current_view_base);
#line 282 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tTerm_1->prod_sel() == sel_Sum) && (phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_1->prod_sel() == sel_Number) && (l_tTerm_2->prod_sel() == sel_Number)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 282, this);
#line 282 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tTerm_Number*>(phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_1)->integer_1;
#line 282 "Frontend/Parser/formula_rewrite.k"
		const tTerm y = phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_2;
#line 282 "Frontend/Parser/formula_rewrite.k"
		const integer z = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 282 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = NotEqualsAtomicProposition(y, Number(minus(z, x)));

#line  2992 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",282,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 351 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Number) && (l_tTerm_2->prod_sel() == sel_Number) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1->value != phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1->value), "Frontend/Parser/formula_rewrite.k", 351, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 351, this);
#line 351 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1;
#line 351 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 351 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = True();

#line  3006 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",351,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 352 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Number) && (l_tTerm_2->prod_sel() == sel_Number) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1->value == phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1->value), "Frontend/Parser/formula_rewrite.k", 352, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 352, this);
#line 352 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1;
#line 352 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 352 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = False();

#line  3020 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",352,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 291 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Node) && (l_tTerm_2->prod_sel() == sel_Number)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 291, this);
#line 291 "Frontend/Parser/formula_rewrite.k"
		const tTerm n = l_tTerm_1;
#line 291 "Frontend/Parser/formula_rewrite.k"
		const tTerm m = l_tTerm_2;
#line 291 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = NotEqualsAtomicProposition(Product(mkinteger(1), n), m);

#line  3034 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",291,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 338 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Number) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1->value == OMEGA), "Frontend/Parser/formula_rewrite.k", 338, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 338, this);
#line 338 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 338 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 338 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = LessEqualAtomicProposition(x, Number(mkinteger(FINITE)));

#line  3048 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",338,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 259 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Sum)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 259, this);
#line 259 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 259 "Frontend/Parser/formula_rewrite.k"
		const tTerm s = l_tTerm_2;
#line 259 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = NotEqualsAtomicProposition(Difference(x, s), Number(mkinteger(0)));

#line  3062 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",259,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 266 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Product)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 266, this);
#line 266 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 266 "Frontend/Parser/formula_rewrite.k"
		const tTerm p = l_tTerm_2;
#line 266 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = NotEqualsAtomicProposition(Difference(x, p), Number(mkinteger(0)));

#line  3076 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",266,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 273 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Node)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 273, this);
#line 273 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 273 "Frontend/Parser/formula_rewrite.k"
		const tTerm n = l_tTerm_2;
#line 273 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = NotEqualsAtomicProposition(Difference(x, n), Number(mkinteger(0)));

#line  3090 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",273,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tTerm_1 == tTerm_1) &&  (l_tTerm_2 == tTerm_2))
	return this;
    else {
	impl_tAtomicProposition_NotEqualsAtomicProposition* kc_result= NotEqualsAtomicProposition(l_tTerm_1, l_tTerm_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tAtomicProposition impl_tAtomicProposition_EqualsAtomicProposition::rewrite(rview kc_current_view_base)
{
    tTerm l_tTerm_1 =
	tTerm_1->rewrite(kc_current_view_base);
    tTerm l_tTerm_2 =
	tTerm_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case sides_enum: {
	    sides_class& kc_current_view=static_cast<sides_class&>(kc_current_view_base);
#line 281 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tTerm_1->prod_sel() == sel_Sum) && (phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_1->prod_sel() == sel_Number) && (l_tTerm_2->prod_sel() == sel_Number)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 281, this);
#line 281 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tTerm_Number*>(phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_1)->integer_1;
#line 281 "Frontend/Parser/formula_rewrite.k"
		const tTerm y = phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_2;
#line 281 "Frontend/Parser/formula_rewrite.k"
		const integer z = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 281 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = EqualsAtomicProposition(y, Number(minus(z, x)));

#line  3129 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",281,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 349 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Number) && (l_tTerm_2->prod_sel() == sel_Number) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1->value == phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1->value), "Frontend/Parser/formula_rewrite.k", 349, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 349, this);
#line 349 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1;
#line 349 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 349 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = True();

#line  3143 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",349,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 350 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Number) && (l_tTerm_2->prod_sel() == sel_Number) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1->value != phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1->value), "Frontend/Parser/formula_rewrite.k", 350, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 350, this);
#line 350 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1;
#line 350 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 350 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = False();

#line  3157 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",350,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 290 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Node) && (l_tTerm_2->prod_sel() == sel_Number)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 290, this);
#line 290 "Frontend/Parser/formula_rewrite.k"
		const tTerm n = l_tTerm_1;
#line 290 "Frontend/Parser/formula_rewrite.k"
		const tTerm m = l_tTerm_2;
#line 290 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = EqualsAtomicProposition(Product(mkinteger(1), n), m);

#line  3171 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",290,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 336 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Number) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1->value == OMEGA), "Frontend/Parser/formula_rewrite.k", 336, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 336, this);
#line 336 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 336 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 336 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = LessEqualAtomicProposition(Product(mkinteger(-1), x), Number(minus(mkinteger(0), y)));

#line  3185 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",336,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 258 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Sum)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 258, this);
#line 258 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 258 "Frontend/Parser/formula_rewrite.k"
		const tTerm s = l_tTerm_2;
#line 258 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = EqualsAtomicProposition(Difference(x, s), Number(mkinteger(0)));

#line  3199 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",258,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 265 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Product)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 265, this);
#line 265 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 265 "Frontend/Parser/formula_rewrite.k"
		const tTerm p = l_tTerm_2;
#line 265 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = EqualsAtomicProposition(Difference(x, p), Number(mkinteger(0)));

#line  3213 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",265,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 272 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Node)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 272, this);
#line 272 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 272 "Frontend/Parser/formula_rewrite.k"
		const tTerm n = l_tTerm_2;
#line 272 "Frontend/Parser/formula_rewrite.k"
		tAtomicProposition kc_result = EqualsAtomicProposition(Difference(x, n), Number(mkinteger(0)));

#line  3227 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",272,kc_result);
		return (const_cast<const impl_tAtomicProposition*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tTerm_1 == tTerm_1) &&  (l_tTerm_2 == tTerm_2))
	return this;
    else {
	impl_tAtomicProposition_EqualsAtomicProposition* kc_result= EqualsAtomicProposition(l_tTerm_1, l_tTerm_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tTerm impl_tTerm_ProductList::rewrite(rview kc_current_view_base)
{
    tProduct_list l_tProduct_list_1 =
	tProduct_list_1->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case productlists_enum: {
	    productlists_class& kc_current_view=static_cast<productlists_class&>(kc_current_view_base);
#line 371 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tProduct_list_1->prod_sel() == sel_NiltProduct_list)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 371, this);
#line 371 "Frontend/Parser/formula_rewrite.k"
		tTerm kc_result = Number(mkinteger(0));

#line  3258 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",371,kc_result);
		return (const_cast<const impl_tTerm*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tProduct_list_1 == tProduct_list_1))
	return this;
    else {
	impl_tTerm_ProductList* kc_result= ProductList(l_tProduct_list_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tTerm impl_tTerm_Product::rewrite(rview kc_current_view_base)
{
    integer l_integer_1 =
	integer_1->rewrite(kc_current_view_base);
    tTerm l_tTerm_1 =
	tTerm_1->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case productlists_enum: {
	    productlists_class& kc_current_view=static_cast<productlists_class&>(kc_current_view_base);
#line 369 "Frontend/Parser/formula_rewrite.k"
	    if ((KC_TRACE_PROVIDED((l_integer_1->value == 0), "Frontend/Parser/formula_rewrite.k", 369, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 369, this);
#line 369 "Frontend/Parser/formula_rewrite.k"
		const integer x = l_integer_1;
#line 369 "Frontend/Parser/formula_rewrite.k"
		tTerm kc_result = Number(mkinteger(0));

#line  3293 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",369,kc_result);
		return (const_cast<const impl_tTerm*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	case sides_enum: {
	    sides_class& kc_current_view=static_cast<sides_class&>(kc_current_view_base);
#line 312 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tTerm_1->prod_sel() == sel_Sum) && (phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_1->prod_sel() == sel_Number)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 312, this);
#line 312 "Frontend/Parser/formula_rewrite.k"
		const integer x = l_integer_1;
#line 312 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_1)->integer_1;
#line 312 "Frontend/Parser/formula_rewrite.k"
		const tTerm z = phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_2;
#line 312 "Frontend/Parser/formula_rewrite.k"
		tTerm kc_result = Sum(Number(mult(x, y)), Product(x, z));

#line  3313 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",312,kc_result);
		return (const_cast<const impl_tTerm*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 249 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Sum) && (KC_TRACE_PROVIDED((l_integer_1->value == 1), "Frontend/Parser/formula_rewrite.k", 249, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 249, this);
#line 249 "Frontend/Parser/formula_rewrite.k"
		const integer x = l_integer_1;
#line 249 "Frontend/Parser/formula_rewrite.k"
		const tTerm y = l_tTerm_1;
#line 249 "Frontend/Parser/formula_rewrite.k"
		tTerm kc_result = y;

#line  3327 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",249,kc_result);
		return (const_cast<const impl_tTerm*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 250 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Number)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 250, this);
#line 250 "Frontend/Parser/formula_rewrite.k"
		const integer x = l_integer_1;
#line 250 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1;
#line 250 "Frontend/Parser/formula_rewrite.k"
		tTerm kc_result = Number(mult(x, y));

#line  3341 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",250,kc_result);
		return (const_cast<const impl_tTerm*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 311 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Product)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 311, this);
#line 311 "Frontend/Parser/formula_rewrite.k"
		const integer x = l_integer_1;
#line 311 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Product*>(l_tTerm_1)->integer_1;
#line 311 "Frontend/Parser/formula_rewrite.k"
		const tTerm z = phylum_cast<const impl_tTerm_Product*>(l_tTerm_1)->tTerm_1;
#line 311 "Frontend/Parser/formula_rewrite.k"
		tTerm kc_result = Product(mult(x, y), z);

#line  3357 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",311,kc_result);
		return (const_cast<const impl_tTerm*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 313 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Sum)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 313, this);
#line 313 "Frontend/Parser/formula_rewrite.k"
		const integer x = l_integer_1;
#line 313 "Frontend/Parser/formula_rewrite.k"
		const tTerm y = phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_1;
#line 313 "Frontend/Parser/formula_rewrite.k"
		const tTerm z = phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_2;
#line 313 "Frontend/Parser/formula_rewrite.k"
		tTerm kc_result = Sum(Product(x, y), Product(x, z));

#line  3373 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",313,kc_result);
		return (const_cast<const impl_tTerm*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 248 "Frontend/Parser/formula_rewrite.k"
		if ((KC_TRACE_PROVIDED((l_integer_1->value == 0), "Frontend/Parser/formula_rewrite.k", 248, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 248, this);
#line 248 "Frontend/Parser/formula_rewrite.k"
		const integer x = l_integer_1;
#line 248 "Frontend/Parser/formula_rewrite.k"
		tTerm kc_result = Number(mkinteger(0));

#line  3385 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",248,kc_result);
		return (const_cast<const impl_tTerm*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_integer_1 == integer_1) &&  (l_tTerm_1 == tTerm_1))
	return this;
    else {
	impl_tTerm_Product* kc_result= Product(l_integer_1, l_tTerm_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tTerm impl_tTerm_Difference::rewrite(rview kc_current_view_base)
{
    tTerm l_tTerm_1 =
	tTerm_1->rewrite(kc_current_view_base);
    tTerm l_tTerm_2 =
	tTerm_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case sides_enum: {
	    sides_class& kc_current_view=static_cast<sides_class&>(kc_current_view_base);
#line 298 "Frontend/Parser/formula_rewrite.k"
	    { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 298, this);
#line 298 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 298 "Frontend/Parser/formula_rewrite.k"
		const tTerm y = l_tTerm_2;
#line 298 "Frontend/Parser/formula_rewrite.k"
		tTerm kc_result = Sum(x, Product(mkinteger(-1), y));

#line  3422 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",298,kc_result);
		return (const_cast<const impl_tTerm*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    }
	}
	default:;
    }
    if ((l_tTerm_1 == tTerm_1) &&  (l_tTerm_2 == tTerm_2))
	return this;
    else {
	impl_tTerm_Difference* kc_result= Difference(l_tTerm_1, l_tTerm_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tTerm impl_tTerm_Sum::rewrite(rview kc_current_view_base)
{
    tTerm l_tTerm_1 =
	tTerm_1->rewrite(kc_current_view_base);
    tTerm l_tTerm_2 =
	tTerm_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case productlists_enum: {
	    productlists_class& kc_current_view=static_cast<productlists_class&>(kc_current_view_base);
#line 357 "Frontend/Parser/formula_rewrite.k"
	    { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 357, this);
#line 357 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 357 "Frontend/Parser/formula_rewrite.k"
		const tTerm y = l_tTerm_2;
#line 357 "Frontend/Parser/formula_rewrite.k"
		tTerm kc_result = ProductList(ConstProduct_list(x, ConstProduct_list(y, NiltProduct_list())));

#line  3457 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",357,kc_result);
		return (const_cast<const impl_tTerm*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    }
	}
	case sides_enum: {
	    sides_class& kc_current_view=static_cast<sides_class&>(kc_current_view_base);
#line 246 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tTerm_1->prod_sel() == sel_Number) && (l_tTerm_2->prod_sel() == sel_Sum) && (phylum_cast<const impl_tTerm_Sum*>(l_tTerm_2)->tTerm_1->prod_sel() == sel_Number)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 246, this);
#line 246 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1;
#line 246 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(phylum_cast<const impl_tTerm_Sum*>(l_tTerm_2)->tTerm_1)->integer_1;
#line 246 "Frontend/Parser/formula_rewrite.k"
		const tTerm z = phylum_cast<const impl_tTerm_Sum*>(l_tTerm_2)->tTerm_2;
#line 246 "Frontend/Parser/formula_rewrite.k"
		tTerm kc_result = Sum(Number(plus(x, y)), z);

#line  3476 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",246,kc_result);
		return (const_cast<const impl_tTerm*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 245 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Number) && (l_tTerm_2->prod_sel() == sel_Number)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 245, this);
#line 245 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1;
#line 245 "Frontend/Parser/formula_rewrite.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(l_tTerm_2)->integer_1;
#line 245 "Frontend/Parser/formula_rewrite.k"
		tTerm kc_result = Number(plus(x, y));

#line  3490 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",245,kc_result);
		return (const_cast<const impl_tTerm*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 247 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Number) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1->value == 0), "Frontend/Parser/formula_rewrite.k", 247, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 247, this);
#line 247 "Frontend/Parser/formula_rewrite.k"
		const integer x = phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1;
#line 247 "Frontend/Parser/formula_rewrite.k"
		const tTerm y = l_tTerm_2;
#line 247 "Frontend/Parser/formula_rewrite.k"
		tTerm kc_result = y;

#line  3504 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",247,kc_result);
		return (const_cast<const impl_tTerm*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 293 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Node)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 293, this);
#line 293 "Frontend/Parser/formula_rewrite.k"
		const tTerm n = l_tTerm_1;
#line 293 "Frontend/Parser/formula_rewrite.k"
		const tTerm y = l_tTerm_2;
#line 293 "Frontend/Parser/formula_rewrite.k"
		tTerm kc_result = Sum(Product(mkinteger(1), n), y);

#line  3518 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",293,kc_result);
		return (const_cast<const impl_tTerm*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 307 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Sum)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 307, this);
#line 307 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_1;
#line 307 "Frontend/Parser/formula_rewrite.k"
		const tTerm y = phylum_cast<const impl_tTerm_Sum*>(l_tTerm_1)->tTerm_2;
#line 307 "Frontend/Parser/formula_rewrite.k"
		const tTerm z = l_tTerm_2;
#line 307 "Frontend/Parser/formula_rewrite.k"
		tTerm kc_result = Sum(x, Sum(y, z));

#line  3534 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",307,kc_result);
		return (const_cast<const impl_tTerm*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 303 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Sum) && (phylum_cast<const impl_tTerm_Sum*>(l_tTerm_2)->tTerm_1->prod_sel() == sel_Number)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 303, this);
#line 303 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 303 "Frontend/Parser/formula_rewrite.k"
		const tTerm n = phylum_cast<const impl_tTerm_Sum*>(l_tTerm_2)->tTerm_1;
#line 303 "Frontend/Parser/formula_rewrite.k"
		const tTerm z = phylum_cast<const impl_tTerm_Sum*>(l_tTerm_2)->tTerm_2;
#line 303 "Frontend/Parser/formula_rewrite.k"
		tTerm kc_result = Sum(n, Sum(x, z));

#line  3550 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",303,kc_result);
		return (const_cast<const impl_tTerm*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 294 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Node)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 294, this);
#line 294 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 294 "Frontend/Parser/formula_rewrite.k"
		const tTerm n = l_tTerm_2;
#line 294 "Frontend/Parser/formula_rewrite.k"
		tTerm kc_result = Sum(x, Product(mkinteger(1), n));

#line  3564 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",294,kc_result);
		return (const_cast<const impl_tTerm*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 302 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_2->prod_sel() == sel_Number)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 302, this);
#line 302 "Frontend/Parser/formula_rewrite.k"
		const tTerm x = l_tTerm_1;
#line 302 "Frontend/Parser/formula_rewrite.k"
		const tTerm n = l_tTerm_2;
#line 302 "Frontend/Parser/formula_rewrite.k"
		tTerm kc_result = Sum(n, x);

#line  3578 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",302,kc_result);
		return (const_cast<const impl_tTerm*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tTerm_1 == tTerm_1) &&  (l_tTerm_2 == tTerm_2))
	return this;
    else {
	impl_tTerm_Sum* kc_result= Sum(l_tTerm_1, l_tTerm_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tTerm impl_tTerm_Number::rewrite(rview kc_current_view_base)
{
    integer l_integer_1 =
	integer_1->rewrite(kc_current_view_base);
    if ((l_integer_1 == integer_1))
	return this;
    else {
	impl_tTerm_Number* kc_result= Number(l_integer_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tTerm impl_tTerm_Node::rewrite(rview kc_current_view_base)
{
    integer l_integer_1 =
	integer_1->rewrite(kc_current_view_base);
    if ((l_integer_1 == integer_1))
	return this;
    else {
	impl_tTerm_Node* kc_result= Node(l_integer_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tProduct_list impl_tProduct_list::rewrite(rview kc_current_view_base)
{
    if (is_nil()) {
	return this;
    } else { // not Nil, Cons
	tTerm l_tTerm_1 =
	    tTerm_1->rewrite(kc_current_view_base);
	tProduct_list l_tProduct_list_1 =
	    tProduct_list_1->rewrite(kc_current_view_base);
	switch(kc_current_view_base) {
	    case productlists_enum: {
		productlists_class& kc_current_view=static_cast<productlists_class&>(kc_current_view_base);
#line 366 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTerm_1->prod_sel() == sel_Product) && (phylum_cast<const impl_tTerm_Product*>(l_tTerm_1)->tTerm_1->prod_sel() == sel_Node) && (l_tProduct_list_1->prod_sel() == sel_ConstProduct_list) && ((l_tProduct_list_1)->tTerm_1->prod_sel() == sel_Product) && (phylum_cast<const impl_tTerm_Product*>((l_tProduct_list_1)->tTerm_1)->tTerm_1->prod_sel() == sel_Node) && (phylum_cast<const impl_tTerm_Node*>(phylum_cast<const impl_tTerm_Product*>((l_tProduct_list_1)->tTerm_1)->tTerm_1)->integer_1->eq(phylum_cast<const impl_tTerm_Node*>(phylum_cast<const impl_tTerm_Product*>(l_tTerm_1)->tTerm_1)->integer_1))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 366, this);
#line 366 "Frontend/Parser/formula_rewrite.k"
		    const integer x = phylum_cast<const impl_tTerm_Product*>(l_tTerm_1)->integer_1;
#line 366 "Frontend/Parser/formula_rewrite.k"
		    const integer u = phylum_cast<const impl_tTerm_Node*>(phylum_cast<const impl_tTerm_Product*>(l_tTerm_1)->tTerm_1)->integer_1;
#line 366 "Frontend/Parser/formula_rewrite.k"
		    const integer y = phylum_cast<const impl_tTerm_Product*>((l_tProduct_list_1)->tTerm_1)->integer_1;
#line 366 "Frontend/Parser/formula_rewrite.k"
		    const tProduct_list l = (l_tProduct_list_1)->tProduct_list_1;
#line 366 "Frontend/Parser/formula_rewrite.k"
		    tProduct_list kc_result = ConstProduct_list(Product(plus(x, y), Node(u)), l);

#line  3648 "ast-system-rk.cc"
		    KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",366,kc_result);
		    return (const_cast<const impl_tProduct_list*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

		} else
#line 363 "Frontend/Parser/formula_rewrite.k"
		    if ((l_tTerm_1->prod_sel() == sel_Product) && (phylum_cast<const impl_tTerm_Product*>(l_tTerm_1)->tTerm_1->prod_sel() == sel_Node) && (l_tProduct_list_1->prod_sel() == sel_ConstProduct_list) && ((l_tProduct_list_1)->tTerm_1->prod_sel() == sel_Product) && (phylum_cast<const impl_tTerm_Product*>((l_tProduct_list_1)->tTerm_1)->tTerm_1->prod_sel() == sel_Node) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Node*>(phylum_cast<const impl_tTerm_Product*>(l_tTerm_1)->tTerm_1)->integer_1->value > phylum_cast<const impl_tTerm_Node*>(phylum_cast<const impl_tTerm_Product*>((l_tProduct_list_1)->tTerm_1)->tTerm_1)->integer_1->value), "Frontend/Parser/formula_rewrite.k", 363, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 363, this);
#line 363 "Frontend/Parser/formula_rewrite.k"
		    const tTerm p1 = l_tTerm_1;
#line 363 "Frontend/Parser/formula_rewrite.k"
		    const integer pid1 = phylum_cast<const impl_tTerm_Node*>(phylum_cast<const impl_tTerm_Product*>(l_tTerm_1)->tTerm_1)->integer_1;
#line 363 "Frontend/Parser/formula_rewrite.k"
		    const tTerm p2 = (l_tProduct_list_1)->tTerm_1;
#line 363 "Frontend/Parser/formula_rewrite.k"
		    const integer pid2 = phylum_cast<const impl_tTerm_Node*>(phylum_cast<const impl_tTerm_Product*>((l_tProduct_list_1)->tTerm_1)->tTerm_1)->integer_1;
#line 363 "Frontend/Parser/formula_rewrite.k"
		    const tProduct_list l = (l_tProduct_list_1)->tProduct_list_1;
#line 363 "Frontend/Parser/formula_rewrite.k"
		    tProduct_list kc_result = ConstProduct_list(p2, ConstProduct_list(p1, l));

#line  3668 "ast-system-rk.cc"
		    KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",363,kc_result);
		    return (const_cast<const impl_tProduct_list*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

		} else
#line 370 "Frontend/Parser/formula_rewrite.k"
		    if ((l_tTerm_1->prod_sel() == sel_Number) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1->value == 0), "Frontend/Parser/formula_rewrite.k", 370, this))) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 370, this);
#line 370 "Frontend/Parser/formula_rewrite.k"
		    const integer x = phylum_cast<const impl_tTerm_Number*>(l_tTerm_1)->integer_1;
#line 370 "Frontend/Parser/formula_rewrite.k"
		    const tProduct_list y = l_tProduct_list_1;
#line 370 "Frontend/Parser/formula_rewrite.k"
		    tProduct_list kc_result = y;

#line  3682 "ast-system-rk.cc"
		    KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",370,kc_result);
		    return (const_cast<const impl_tProduct_list*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

		} else
#line 360 "Frontend/Parser/formula_rewrite.k"
		    if ((l_tTerm_1->prod_sel() == sel_ProductList)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 360, this);
#line 360 "Frontend/Parser/formula_rewrite.k"
		    const tProduct_list x = phylum_cast<const impl_tTerm_ProductList*>(l_tTerm_1)->tProduct_list_1;
#line 360 "Frontend/Parser/formula_rewrite.k"
		    const tProduct_list y = l_tProduct_list_1;
#line 360 "Frontend/Parser/formula_rewrite.k"
		    tProduct_list kc_result = concat(x, y);

#line  3696 "ast-system-rk.cc"
		    KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",360,kc_result);
		    return (const_cast<const impl_tProduct_list*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

		} else
			goto kc_rewrite_default;
	    }
	    kc_rewrite_default:
	    default:;
	}
	if ((l_tTerm_1 == tTerm_1) &&  (l_tProduct_list_1 == tProduct_list_1))
	    return this;
	else {
	    impl_tProduct_list* kc_result= ConstProduct_list(l_tTerm_1, l_tProduct_list_1);
	    kc_result->rewrite_members(this);
	    return kc_result;
	}   }
}

tBuechiAutomata impl_tBuechiAutomata_BuechiNull::rewrite(rview kc_current_view_base)
{
    return this;

}

tBuechiAutomata impl_tBuechiAutomata_BuechiAutomaton::rewrite(rview kc_current_view_base)
{
    tBuechiRules l_tBuechiRules_1 =
	tBuechiRules_1->rewrite(kc_current_view_base);
    tAcceptingSet l_tAcceptingSet_1 =
	tAcceptingSet_1->rewrite(kc_current_view_base);
    if ((l_tBuechiRules_1 == tBuechiRules_1) &&  (l_tAcceptingSet_1 == tAcceptingSet_1))
	return this;
    else {
	impl_tBuechiAutomata_BuechiAutomaton* kc_result= BuechiAutomaton(l_tBuechiRules_1, l_tAcceptingSet_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tBuechiRules impl_tBuechiRules_BuechiRules::rewrite(rview kc_current_view_base)
{
    tBuechiRules l_tBuechiRules_1 =
	tBuechiRules_1->rewrite(kc_current_view_base);
    tBuechiRules l_tBuechiRules_2 =
	tBuechiRules_2->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case rbuechi_enum: {
	    rbuechi_class& kc_current_view=static_cast<rbuechi_class&>(kc_current_view_base);
#line 839 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tBuechiRules_1->prod_sel() == sel_EmptyBuechiRules)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 839, this);
#line 839 "Frontend/Parser/formula_rewrite.k"
		const tBuechiRules a = l_tBuechiRules_2;
#line 839 "Frontend/Parser/formula_rewrite.k"
		tBuechiRules kc_result = a;

#line  3752 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",839,kc_result);
		return (const_cast<const impl_tBuechiRules*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 838 "Frontend/Parser/formula_rewrite.k"
		if ((l_tBuechiRules_2->prod_sel() == sel_EmptyBuechiRules)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 838, this);
#line 838 "Frontend/Parser/formula_rewrite.k"
		const tBuechiRules a = l_tBuechiRules_1;
#line 838 "Frontend/Parser/formula_rewrite.k"
		tBuechiRules kc_result = a;

#line  3764 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",838,kc_result);
		return (const_cast<const impl_tBuechiRules*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_tBuechiRules_1 == tBuechiRules_1) &&  (l_tBuechiRules_2 == tBuechiRules_2))
	return this;
    else {
	impl_tBuechiRules_BuechiRules* kc_result= BuechiRules(l_tBuechiRules_1, l_tBuechiRules_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tBuechiRules impl_tBuechiRules_ExpandedBuechiRule::rewrite(rview kc_current_view_base)
{
    integer l_integer_1 =
	integer_1->rewrite(kc_current_view_base);
    tFormula l_tFormula_1 =
	tFormula_1->rewrite(kc_current_view_base);
    integer l_integer_2 =
	integer_2->rewrite(kc_current_view_base);
    if ((l_integer_1 == integer_1) &&  (l_tFormula_1 == tFormula_1) &&  (l_integer_2 == integer_2))
	return this;
    else {
	impl_tBuechiRules_ExpandedBuechiRule* kc_result= ExpandedBuechiRule(l_integer_1, l_tFormula_1, l_integer_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tBuechiRules impl_tBuechiRules_BuechiRule::rewrite(rview kc_current_view_base)
{
    integer l_integer_1 =
	integer_1->rewrite(kc_current_view_base);
    tTransitionRules l_tTransitionRules_1 =
	tTransitionRules_1->rewrite(kc_current_view_base);
    switch(kc_current_view_base) {
	case rbuechi_enum: {
	    rbuechi_class& kc_current_view=static_cast<rbuechi_class&>(kc_current_view_base);
#line 835 "Frontend/Parser/formula_rewrite.k"
	    if ((l_tTransitionRules_1->prod_sel() == sel_TransitionRules)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 835, this);
#line 835 "Frontend/Parser/formula_rewrite.k"
		const integer from = l_integer_1;
#line 835 "Frontend/Parser/formula_rewrite.k"
		const tTransitionRules lrules = phylum_cast<const impl_tTransitionRules_TransitionRules*>(l_tTransitionRules_1)->tTransitionRules_1;
#line 835 "Frontend/Parser/formula_rewrite.k"
		const tTransitionRules rrules = phylum_cast<const impl_tTransitionRules_TransitionRules*>(l_tTransitionRules_1)->tTransitionRules_2;
#line 835 "Frontend/Parser/formula_rewrite.k"
		tBuechiRules kc_result = BuechiRules(BuechiRule(from, lrules), BuechiRule(from, rrules));

#line  3820 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",835,kc_result);
		return (const_cast<const impl_tBuechiRules*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 836 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTransitionRules_1->prod_sel() == sel_TransitionRule)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 836, this);
#line 836 "Frontend/Parser/formula_rewrite.k"
		const integer from = l_integer_1;
#line 836 "Frontend/Parser/formula_rewrite.k"
		const tFormula formula = phylum_cast<const impl_tTransitionRules_TransitionRule*>(l_tTransitionRules_1)->tFormula_1;
#line 836 "Frontend/Parser/formula_rewrite.k"
		const integer to = phylum_cast<const impl_tTransitionRules_TransitionRule*>(l_tTransitionRules_1)->integer_1;
#line 836 "Frontend/Parser/formula_rewrite.k"
		tBuechiRules kc_result = ExpandedBuechiRule(from, formula, to);

#line  3836 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",836,kc_result);
		return (const_cast<const impl_tBuechiRules*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
#line 837 "Frontend/Parser/formula_rewrite.k"
		if ((l_tTransitionRules_1->prod_sel() == sel_EmptyTransitionRules)) { KC_TRACE_REWRITE_MATCH(kc_current_view, "Frontend/Parser/formula_rewrite.k", 837, this);
#line 837 "Frontend/Parser/formula_rewrite.k"
		tBuechiRules kc_result = EmptyBuechiRules();

#line  3846 "ast-system-rk.cc"
		KC_TRACE_REWRITE_RESULT(kc_current_view,"Frontend/Parser/formula_rewrite.k",837,kc_result);
		return (const_cast<const impl_tBuechiRules*>(kc_result) == this) ? this : kc_result->rewrite( kc_current_view_base );

	    } else
		    goto kc_rewrite_default;
	}
	kc_rewrite_default:
	default:;
    }
    if ((l_integer_1 == integer_1) &&  (l_tTransitionRules_1 == tTransitionRules_1))
	return this;
    else {
	impl_tBuechiRules_BuechiRule* kc_result= BuechiRule(l_integer_1, l_tTransitionRules_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tBuechiRules impl_tBuechiRules_EmptyBuechiRules::rewrite(rview kc_current_view_base)
{
    return this;

}

tTransitionRules impl_tTransitionRules_TransitionRules::rewrite(rview kc_current_view_base)
{
    tTransitionRules l_tTransitionRules_1 =
	tTransitionRules_1->rewrite(kc_current_view_base);
    tTransitionRules l_tTransitionRules_2 =
	tTransitionRules_2->rewrite(kc_current_view_base);
    if ((l_tTransitionRules_1 == tTransitionRules_1) &&  (l_tTransitionRules_2 == tTransitionRules_2))
	return this;
    else {
	impl_tTransitionRules_TransitionRules* kc_result= TransitionRules(l_tTransitionRules_1, l_tTransitionRules_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tTransitionRules impl_tTransitionRules_TransitionRule::rewrite(rview kc_current_view_base)
{
    tFormula l_tFormula_1 =
	tFormula_1->rewrite(kc_current_view_base);
    integer l_integer_1 =
	integer_1->rewrite(kc_current_view_base);
    if ((l_tFormula_1 == tFormula_1) &&  (l_integer_1 == integer_1))
	return this;
    else {
	impl_tTransitionRules_TransitionRule* kc_result= TransitionRule(l_tFormula_1, l_integer_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tTransitionRules impl_tTransitionRules_EmptyTransitionRules::rewrite(rview kc_current_view_base)
{
    return this;

}

tAcceptingSet impl_tAcceptingSet_AcceptingSet::rewrite(rview kc_current_view_base)
{
    tAcceptingSet l_tAcceptingSet_1 =
	tAcceptingSet_1->rewrite(kc_current_view_base);
    tAcceptingSet l_tAcceptingSet_2 =
	tAcceptingSet_2->rewrite(kc_current_view_base);
    if ((l_tAcceptingSet_1 == tAcceptingSet_1) &&  (l_tAcceptingSet_2 == tAcceptingSet_2))
	return this;
    else {
	impl_tAcceptingSet_AcceptingSet* kc_result= AcceptingSet(l_tAcceptingSet_1, l_tAcceptingSet_2);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tAcceptingSet impl_tAcceptingSet_AcceptingState::rewrite(rview kc_current_view_base)
{
    integer l_integer_1 =
	integer_1->rewrite(kc_current_view_base);
    if ((l_integer_1 == integer_1))
	return this;
    else {
	impl_tAcceptingSet_AcceptingState* kc_result= AcceptingState(l_integer_1);
	kc_result->rewrite_members(this);
	return kc_result;
    }
}

tAcceptingSet impl_tAcceptingSet_EmptyAcceptingSet::rewrite(rview kc_current_view_base)
{
    return this;

}

} // namespace kc
