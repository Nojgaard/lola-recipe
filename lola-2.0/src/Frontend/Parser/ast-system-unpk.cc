/* translation of file(s)
	"Frontend/Parser/formula_abstract.k"
	"Frontend/Parser/formula_rewrite.k"
	"Frontend/Parser/formula_unparse.k"
 */
/* generated by:
 *  @(#)$Author: Kimwitu++ version 2.3.13 (C) 1998-2008 Humboldt-Universitaet zu Berlin $
 */
#define KC_UNPARSE

#include <stdio.h>
#include <string>
#include <stdlib.h>
#include "ast-system-k.h"
#include "ast-system-unpk.h"


namespace kc {
base_uview_class base_uview;
out_class out;
temporal_class temporal;
internal_class internal;
buechi_class buechi;
ctl_class ctl;
ltl_class ltl;

impl_uviews uviews[] = {
    {"base_uview",&base_uview},
    {"out",&out},
    {"temporal",&temporal},
    {"internal",&internal},
    {"buechi",&buechi},
    {"ctl",&ctl},
    {"ltl",&ltl},
    {0,0}
};

} // namespace kc
namespace kc { }
using namespace kc;
/* included stuff */
#line 19 "Frontend/Parser/formula_unparse.k"
// LCOV_EXCL_START
/*!
\brief printer-function for Kimiwtu's output on stdout

To use an unparser in Kimwitu++, a function with this signature needs to be
passed to the unparse() function.

\param[in] s  string to print

\note This function is not "found" by the code coverage detection and is hence
hidden from it.
*/
void myprinter(const char *s, kc::uview)
{
    printf("%s", s);
}
// LCOV_EXCL_STOP

/// result string for stringprinter
std::string unparsed;

// LCOV_EXCL_START
/*!
\brief printer-function for Kimiwtu's output to a string object

To use an unparser in Kimwitu++, a function with this signature needs to be
passed to the unparse() function.

\param[in] s  string to add

\note This function is not "found" by the code coverage detection and is hence
hidden from it.
\post Output is written to string unparsed which can be accessed wherever an
unparser can be used. You need to clear the string after use to avoid keeping
old data.
*/
void stringprinter(const char *s, kc::uview)
{
    unparsed += s;
}
// LCOV_EXCL_STOP

bool *place_in_formula = NULL;
unsigned int places_mentioned = 0;
unsigned int unique_places_mentioned = 0;

#line  90 "ast-system-unpk.cc"
#line 267 "Frontend/Parser/formula_unparse.k"
#include <config.h>
#include <Core/Dimensions.h>
#include <Formula/StatePredicate/AtomicStatePredicate.h>
#include <Formula/StatePredicate/ConjunctionStatePredicate.h>
#include <Formula/StatePredicate/DisjunctionStatePredicate.h>
#include <Formula/StatePredicate/FalsePredicate.h>
#include <Formula/StatePredicate/StatePredicate.h>
#include <Formula/StatePredicate/TruePredicate.h>
#include <Net/Marking.h>
#include <Net/Net.h>

#include <map>
#include <vector>
#include <stack>

// mapping from node ids to factors
std::map<int, int> current;

// mapping from tree node ids to list of intermediate formulas
std::map<int, std::vector<StatePredicate *> > formulas;

// invariant: top is always my parent
std::stack<size_t> id_stack;

// next free id
size_t nextId = 0;

#line  119 "ast-system-unpk.cc"
#line 529 "Frontend/Parser/formula_unparse.k"
std::map<uint32_t, std::vector<std::pair<uint32_t,uint32_t> > > transitions ;
std::set<uint32_t> acceptingset;
std::map<uint32_t, StatePredicate*> predicates;
std::map<uint32_t, uint32_t> states_to_interal;

uint32_t get_state_number(uint32_t state){
    if (states_to_interal.find(state) == states_to_interal.end()){
	// get a new state number
	uint32_t new_state_number = states_to_interal.size();
	states_to_interal[state] = new_state_number;
	return new_state_number;
    }
    return states_to_interal[state];
}

#line  136 "ast-system-unpk.cc"
#line 641 "Frontend/Parser/formula_unparse.k"

#include <Core/Dimensions.h>
#include <Exploration/StatePredicateProperty.h>
#include <Formula/CTL/AUFormula.h>
#include <Formula/CTL/AXFormula.h>
#include <Formula/CTL/AtomicFormula.h>
#include <Formula/CTL/CTLFormula.h>
#include <Formula/CTL/ConjunctionFormula.h>
#include <Formula/CTL/DisjunctionFormula.h>
#include <Formula/CTL/EUFormula.h>
#include <Formula/CTL/EXFormula.h>
#include <Formula/CTL/NotFormula.h>
#include <Net/Net.h>

#include <map>
#include <vector>
#include <stack>

// mapping from node ids to factors
std::map<int, int> ctl_current;

// mapping from tree node ids to list of intermediate formulas
std::map<int, std::vector<CTLFormula_p> > ctl_formulas;

// invariant: top is always my parent
std::stack<size_t> ctl_id_stack;

// next free id
size_t ctl_nextId = 0;

// needs dfs-storage;
size_t ctl_dfs_id = 0;

// needs cached results id
size_t ctl_result_cache_id = 0;

// temporal storage to be able to include the LessEqualStatePredicate into an AtomicFormula
StatePredicateProperty* spp;

#line  177 "ast-system-unpk.cc"
#line 842 "Frontend/Parser/formula_unparse.k"
#include <Core/Runtime.h>
#include <Frontend/Parser/ast-system-rk.h>
#include <vector>

std::vector<LTLTree_p> ltlstack;

#line  185 "ast-system-unpk.cc"
/* end included stuff */


namespace kc {

#ifndef KC_TRACE_PROVIDED
#define KC_TRACE_PROVIDED(COND,FILE,LINE,NODE) COND
#endif

void
impl_abstract_phylum::unparse(printer_function opf, uview uv)
{
    printer_functor_function_wrapper pf(opf);
    do_unparse(pf, uv);
}

// Everything given as a pointer is expected to have an unparse-method (we
// believe it's a phylum), unless there's a specialisation for it

void
unparse(abstract_phylum kc_p, printer_functor kc_printer, uview kc_current_view)
{
    kc_p->unparse(kc_printer, kc_current_view);
}

void
unparse(void *kc_p, printer_functor kc_printer, uview kc_current_view)
{
    // MPi: 20020628 there shouldn't be any left
    assertionFailed("Unparse called for untyped pointer");
    // MPi: cast should be unnecessary, but there are still void*
    reinterpret_cast<impl_abstract_phylum*>(kc_p)->unparse(kc_printer, kc_current_view);
}

void
unparse(int kc_v, printer_functor kc_printer, uview kc_current_view)
{
    kc_char_t kc_string[200];
    kc_print_integer(kc_string, kc_v);
    kc_printer(kc_string, kc_current_view);
}

void
unparse(double kc_v, printer_functor kc_printer, uview kc_current_view)
{
    kc_char_t kc_string[200];
    kc_print_real(kc_string, kc_v);
    kc_printer(kc_string, kc_current_view);
}

void
unparse(kc_char_t *kc_v, printer_functor kc_printer, uview kc_current_view)
{
    kc_printer(kc_v, kc_current_view);
}

void
unparse(kc_string_t kc_v, printer_functor kc_printer, uview kc_current_view)
{
    kc_printer(kc_v.c_str(), kc_current_view);
}

#line  248 "ast-system-unpk.cc"
void
impl_abstract_phylum::default_unparse(printer_functor kc_printer, uview kc_current_view)
{
    register int no_sons = operator_info[prod_sel()].no_sons;
    for (int i=0; i < no_sons; i++)
    subphylum(i)->unparse(kc_printer, kc_current_view);
}

void
impl_casestring__Str::do_unparse(printer_functor kc_printer, uview kc_current_view)
{
    kc::unparse(name, kc_printer, kc_current_view);
}

void
impl_nocasestring_NoCaseStr::do_unparse(printer_functor kc_printer, uview kc_current_view)
{
    kc::unparse(name, kc_printer, kc_current_view);
}

void
impl_integer__Int::do_unparse(printer_functor kc_printer, uview kc_current_view)
{
    kc::unparse(value, kc_printer, kc_current_view);
}

void
impl_real__Real::do_unparse(printer_functor kc_printer, uview kc_current_view)
{
    kc::unparse(value, kc_printer, kc_current_view);
}

void
impl_voidptr__VoidPtr::do_unparse(printer_functor kc_printer, uview kc_current_view)
{
    kc::unparse(pointer, kc_printer, kc_current_view);
}


#line  288 "ast-system-unpk.cc"
void
impl_tFormula_StatePredicateFormula::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case ltl_enum: {
	    ltl_class& kc_current_view=static_cast<ltl_class&>(kc_current_view_base);
	    {
#line 850 "Frontend/Parser/formula_unparse.k"
		const tFormula f = this/**/;
#line 850 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 852 "Frontend/Parser/formula_unparse.k"


		f->ltl_tree = bin_simpler(push_negation(tl_nn(NOT, ltlstack.back(), NULL)));


#line  307 "ast-system-unpk.cc"
	    }
	    break;
	}
	case ctl_enum: {
	    ctl_class& kc_current_view=static_cast<ctl_class&>(kc_current_view_base);
	    {
#line 707 "Frontend/Parser/formula_unparse.k"
		const tFormula f = this/**/;
#line 707 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 707 "Frontend/Parser/formula_unparse.k"

		f->unparse(myprinter, kc::temporal);

		ctl_id_stack.push(ctl_nextId++);

#line  324 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 713 "Frontend/Parser/formula_unparse.k"

		ctl_nextId = ctl_id_stack.top();
		ctl_id_stack.pop();


		assert(ctl_nextId == 0);
		f->ctl_formula = ctl_formulas[0][0];
		f->ctl_formula->payloadsize = ctl_dfs_id*SIZEOF_STATENUMBER_T + (2*ctl_result_cache_id+7)/8;

#line  336 "ast-system-unpk.cc"
	    }
	    break;
	}
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    {
#line 295 "Frontend/Parser/formula_unparse.k"
		const tFormula f = this/**/;
#line 295 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 295 "Frontend/Parser/formula_unparse.k"


		current.clear();
		formulas.clear();
		while (not id_stack.empty())
		id_stack.pop();
		nextId = 0;
		id_stack.push(nextId++);

#line  357 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 305 "Frontend/Parser/formula_unparse.k"

		nextId = id_stack.top();
		id_stack.pop();

		assert(nextId == 0);
		assert(formulas[0].size() == 1);
		f->formula = formulas[0][0];

#line  368 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 171 "Frontend/Parser/formula_unparse.k"
		const tFormula f = this/**/;
#line 171 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 171 "Frontend/Parser/formula_unparse.k"

		{
#line 172 "Frontend/Parser/formula_unparse.k"
		    tStatePredicate kc_selvar_0_1 = phylum_cast<tStatePredicate>(x);
#line 184 "Frontend/Parser/formula_unparse.k"
		    if ((kc_selvar_0_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(kc_selvar_0_1)->tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_ExPath*>(kc_selvar_0_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_ExPath*>(kc_selvar_0_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_ExPath*>(kc_selvar_0_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_ExPath*>(kc_selvar_0_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (KC_TRACE_PROVIDED((not phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_ExPath*>(kc_selvar_0_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_unparse.k", 183, this))) {
#line 184 "Frontend/Parser/formula_unparse.k"
#line 183 "Frontend/Parser/formula_unparse.k"
			const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_ExPath*>(kc_selvar_0_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 184 "Frontend/Parser/formula_unparse.k"
			f->type = FORMULA_EGAGEF; 
#line  392 "ast-system-unpk.cc"
				} else
#line 182 "Frontend/Parser/formula_unparse.k"
			if ((kc_selvar_0_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(kc_selvar_0_1)->tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(kc_selvar_0_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(kc_selvar_0_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (KC_TRACE_PROVIDED((not phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(kc_selvar_0_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_unparse.k", 181, this))) {
#line 182 "Frontend/Parser/formula_unparse.k"
#line 181 "Frontend/Parser/formula_unparse.k"
			const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(kc_selvar_0_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1)->tStatePredicate_1;
#line 182 "Frontend/Parser/formula_unparse.k"
			f->type = FORMULA_LIVENESS; 
#line  401 "ast-system-unpk.cc"
				} else
#line 176 "Frontend/Parser/formula_unparse.k"
			if ((kc_selvar_0_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(kc_selvar_0_1)->tStatePredicate_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(kc_selvar_0_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(kc_selvar_0_1)->tStatePredicate_1)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_NoDeadlock)) {
#line 176 "Frontend/Parser/formula_unparse.k"
#line 176 "Frontend/Parser/formula_unparse.k"
			f->type = FORMULA_NODEADLOCK; 
#line  408 "ast-system-unpk.cc"
				} else
#line 174 "Frontend/Parser/formula_unparse.k"
			if ((kc_selvar_0_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(kc_selvar_0_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(kc_selvar_0_1)->tStatePredicate_1)->tStatePredicate_1->prod_sel() == sel_AtomicProposition) && (phylum_cast<const impl_tStatePredicate_AtomicProposition*>(phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(kc_selvar_0_1)->tStatePredicate_1)->tStatePredicate_1)->tAtomicProposition_1->prod_sel() == sel_Deadlock)) {
#line 174 "Frontend/Parser/formula_unparse.k"
#line 174 "Frontend/Parser/formula_unparse.k"
			f->type = FORMULA_DEADLOCK; 
#line  415 "ast-system-unpk.cc"
				} else
#line 188 "Frontend/Parser/formula_unparse.k"
			if ((kc_selvar_0_1->prod_sel() == sel_Eventually) && (phylum_cast<const impl_tStatePredicate_Eventually*>(kc_selvar_0_1)->tStatePredicate_1->prod_sel() == sel_Always) && (KC_TRACE_PROVIDED((not phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_Eventually*>(kc_selvar_0_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_unparse.k", 187, this))) {
#line 188 "Frontend/Parser/formula_unparse.k"
#line 187 "Frontend/Parser/formula_unparse.k"
			const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_Eventually*>(kc_selvar_0_1)->tStatePredicate_1)->tStatePredicate_1;
#line 188 "Frontend/Parser/formula_unparse.k"
			f->type = FORMULA_STABILIZATION; 
#line  424 "ast-system-unpk.cc"
				} else
#line 186 "Frontend/Parser/formula_unparse.k"
			if ((kc_selvar_0_1->prod_sel() == sel_Always) && (phylum_cast<const impl_tStatePredicate_Always*>(kc_selvar_0_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (KC_TRACE_PROVIDED((not phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_Always*>(kc_selvar_0_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_unparse.k", 185, this))) {
#line 186 "Frontend/Parser/formula_unparse.k"
#line 185 "Frontend/Parser/formula_unparse.k"
			const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_Always*>(kc_selvar_0_1)->tStatePredicate_1)->tStatePredicate_1;
#line 186 "Frontend/Parser/formula_unparse.k"
			f->type = FORMULA_FAIRNESS; 
#line  433 "ast-system-unpk.cc"
				} else
#line 180 "Frontend/Parser/formula_unparse.k"
			if ((kc_selvar_0_1->prod_sel() == sel_AllPath) && (phylum_cast<const impl_tStatePredicate_AllPath*>(kc_selvar_0_1)->tStatePredicate_1->prod_sel() == sel_Always) && (KC_TRACE_PROVIDED((not phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(kc_selvar_0_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_unparse.k", 179, this))) {
#line 180 "Frontend/Parser/formula_unparse.k"
#line 179 "Frontend/Parser/formula_unparse.k"
			const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Always*>(phylum_cast<const impl_tStatePredicate_AllPath*>(kc_selvar_0_1)->tStatePredicate_1)->tStatePredicate_1;
#line 180 "Frontend/Parser/formula_unparse.k"
			f->type = FORMULA_INVARIANT; 
#line  442 "ast-system-unpk.cc"
				} else
#line 178 "Frontend/Parser/formula_unparse.k"
			if ((kc_selvar_0_1->prod_sel() == sel_ExPath) && (phylum_cast<const impl_tStatePredicate_ExPath*>(kc_selvar_0_1)->tStatePredicate_1->prod_sel() == sel_Eventually) && (KC_TRACE_PROVIDED((not phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(kc_selvar_0_1)->tStatePredicate_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_unparse.k", 177, this))) {
#line 178 "Frontend/Parser/formula_unparse.k"
#line 177 "Frontend/Parser/formula_unparse.k"
			const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(phylum_cast<const impl_tStatePredicate_ExPath*>(kc_selvar_0_1)->tStatePredicate_1)->tStatePredicate_1;
#line 178 "Frontend/Parser/formula_unparse.k"
			f->type = FORMULA_REACHABLE; 
#line  451 "ast-system-unpk.cc"
				} else
#line 190 "Frontend/Parser/formula_unparse.k"
			if ((kc_selvar_0_1->prod_sel() == sel_Eventually) && (KC_TRACE_PROVIDED((not phylum_cast<const impl_tStatePredicate_Eventually*>(kc_selvar_0_1)->tStatePredicate_1->containsTemporal), "Frontend/Parser/formula_unparse.k", 189, this))) {
#line 190 "Frontend/Parser/formula_unparse.k"
#line 189 "Frontend/Parser/formula_unparse.k"
			const tStatePredicate y = phylum_cast<const impl_tStatePredicate_Eventually*>(kc_selvar_0_1)->tStatePredicate_1;
#line 190 "Frontend/Parser/formula_unparse.k"
			f->type = FORMULA_EVENTUALLY; 
#line  460 "ast-system-unpk.cc"
				} else
#line 196 "Frontend/Parser/formula_unparse.k"
			if ((KC_TRACE_PROVIDED((x->containsTemporal && x->validCTLStateFormula), "Frontend/Parser/formula_unparse.k", 195, this))) {
#line 196 "Frontend/Parser/formula_unparse.k"
#line 196 "Frontend/Parser/formula_unparse.k"
			f->type = FORMULA_CTL; 
#line  467 "ast-system-unpk.cc"
				} else
#line 194 "Frontend/Parser/formula_unparse.k"
			if ((KC_TRACE_PROVIDED((x->containsTemporal && x->validLTLFormula), "Frontend/Parser/formula_unparse.k", 193, this))) {
#line 194 "Frontend/Parser/formula_unparse.k"
#line 194 "Frontend/Parser/formula_unparse.k"
			f->type = FORMULA_LTL; 
#line  474 "ast-system-unpk.cc"
				} else
#line 192 "Frontend/Parser/formula_unparse.k"
			if ((KC_TRACE_PROVIDED((not x->containsTemporal), "Frontend/Parser/formula_unparse.k", 191, this))) {
#line 192 "Frontend/Parser/formula_unparse.k"
#line 192 "Frontend/Parser/formula_unparse.k"
			f->type = FORMULA_INITIAL; 
#line  481 "ast-system-unpk.cc"
				} else
		    {
#line 198 "Frontend/Parser/formula_unparse.k"
#line 198 "Frontend/Parser/formula_unparse.k"
			f->type = FORMULA_MODELCHECKING; 
#line  487 "ast-system-unpk.cc"
		    }
		}
#line 200 "Frontend/Parser/formula_unparse.k"

#line  492 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 83 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  506 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  519 "ast-system-unpk.cc"
void
impl_tStatePredicate_DisjunctionList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    {
#line 372 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
#line 372 "Frontend/Parser/formula_unparse.k"

		id_stack.push(nextId++);

#line  533 "ast-system-unpk.cc"
		kc::unparse(l, kc_printer, kc_current_view);
#line 376 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t myId = id_stack.top();
		id_stack.pop();

		StatePredicate *f = new DisjunctionStatePredicate(l->length());

		for (int i = 0; i < l->length(); ++i)
		{
		    assert(formulas[myId][i]);
		    ((DisjunctionStatePredicate*)f)->addSub(i, formulas[myId][i]);
		}

		formulas[id_stack.top()].push_back(f);

#line  551 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 114 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(l, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  567 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  580 "ast-system-unpk.cc"
void
impl_tStatePredicate_ConjunctionList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    {
#line 333 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
#line 333 "Frontend/Parser/formula_unparse.k"

		id_stack.push(nextId++);

#line  594 "ast-system-unpk.cc"
		kc::unparse(l, kc_printer, kc_current_view);
#line 337 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t myId = id_stack.top();
		id_stack.pop();

		StatePredicate *f = new ConjunctionStatePredicate(l->length());

		for (int i = 0; i < l->length(); ++i)
		{
		    assert(formulas[myId][i]);
		    ((ConjunctionStatePredicate*)f)->addSub(i, formulas[myId][i]);
		}

		formulas[id_stack.top()].push_back(f);

#line  612 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 110 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(l, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  628 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  641 "ast-system-unpk.cc"
void
impl_tStatePredicate_EX::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case ctl_enum: {
	    ctl_class& kc_current_view=static_cast<ctl_class&>(kc_current_view_base);
	    {
#line 802 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 802 "Frontend/Parser/formula_unparse.k"

		ctl_id_stack.push(ctl_nextId++);

#line  655 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 806 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t myId = ctl_id_stack.top();
		ctl_id_stack.pop();

		assert(ctl_formulas[myId].size() == 1);
		EXFormula* exf = new EXFormula(ctl_formulas[myId][0]);

		ctl_formulas[ctl_id_stack.top()].push_back(exf);

#line  668 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 254 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 254 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 254 "Frontend/Parser/formula_unparse.k"

		f->containsTemporal = true;
		f->validCTLStateFormula = x->validCTLPathFormula;
		f->validCTLPathFormula = false;
		f->validLTLFormula = false;

#line  687 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 106 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("EX("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  703 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  716 "ast-system-unpk.cc"
void
impl_tStatePredicate_AX::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case ctl_enum: {
	    ctl_class& kc_current_view=static_cast<ctl_class&>(kc_current_view_base);
	    {
#line 768 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 768 "Frontend/Parser/formula_unparse.k"

		ctl_id_stack.push(ctl_nextId++);

#line  730 "ast-system-unpk.cc"
		kc::unparse(x, kc_printer, kc_current_view);
#line 772 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t myId = ctl_id_stack.top();
		ctl_id_stack.pop();

		assert(ctl_formulas[myId].size() == 1);
		AXFormula* axf = new AXFormula(ctl_formulas[myId][0]);

		ctl_formulas[ctl_id_stack.top()].push_back(axf);

#line  743 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 254 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 254 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 254 "Frontend/Parser/formula_unparse.k"

		f->containsTemporal = true;
		f->validCTLStateFormula = x->validCTLPathFormula;
		f->validCTLPathFormula = false;
		f->validLTLFormula = false;

#line  762 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 105 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("AX("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  778 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  791 "ast-system-unpk.cc"
void
impl_tStatePredicate_EG::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 254 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 254 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 254 "Frontend/Parser/formula_unparse.k"

		f->containsTemporal = true;
		f->validCTLStateFormula = x->validCTLPathFormula;
		f->validCTLPathFormula = false;
		f->validLTLFormula = false;

#line  811 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 108 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("EG("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  827 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  840 "ast-system-unpk.cc"
void
impl_tStatePredicate_AG::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 254 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 254 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 254 "Frontend/Parser/formula_unparse.k"

		f->containsTemporal = true;
		f->validCTLStateFormula = x->validCTLPathFormula;
		f->validCTLPathFormula = false;
		f->validLTLFormula = false;

#line  860 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 104 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("AG("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  876 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  889 "ast-system-unpk.cc"
void
impl_tStatePredicate_EF::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 254 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 254 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 254 "Frontend/Parser/formula_unparse.k"

		f->containsTemporal = true;
		f->validCTLStateFormula = x->validCTLPathFormula;
		f->validCTLPathFormula = false;
		f->validLTLFormula = false;

#line  909 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 107 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("EF("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  925 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  938 "ast-system-unpk.cc"
void
impl_tStatePredicate_AF::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 254 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 254 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 254 "Frontend/Parser/formula_unparse.k"

		f->containsTemporal = true;
		f->validCTLStateFormula = x->validCTLPathFormula;
		f->validCTLPathFormula = false;
		f->validLTLFormula = false;

#line  958 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 103 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("AF("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  974 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  987 "ast-system-unpk.cc"
void
impl_tStatePredicate_ER::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 247 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 247 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 247 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 247 "Frontend/Parser/formula_unparse.k"

		f->containsTemporal = true;
		f->validCTLStateFormula = x->validCTLStateFormula && y->validCTLStateFormula;
		f->validCTLPathFormula = false;
		f->validLTLFormula = false;

#line  1010 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 101 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 101 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		{ kc_printer(kc_t("E("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" R "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  1030 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  1043 "ast-system-unpk.cc"
void
impl_tStatePredicate_AR::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 247 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 247 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 247 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 247 "Frontend/Parser/formula_unparse.k"

		f->containsTemporal = true;
		f->validCTLStateFormula = x->validCTLStateFormula && y->validCTLStateFormula;
		f->validCTLPathFormula = false;
		f->validLTLFormula = false;

#line  1066 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 100 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 100 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		{ kc_printer(kc_t("A("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" R "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  1086 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  1099 "ast-system-unpk.cc"
void
impl_tStatePredicate_EU::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case ctl_enum: {
	    ctl_class& kc_current_view=static_cast<ctl_class&>(kc_current_view_base);
	    {
#line 817 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this->tStatePredicate_1;
#line 817 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate b = this->tStatePredicate_2;
#line 817 "Frontend/Parser/formula_unparse.k"

		ctl_id_stack.push(ctl_nextId++);
		const size_t myDFSId = ctl_dfs_id++;
		const size_t myCacheId = ctl_result_cache_id++;

#line  1117 "ast-system-unpk.cc"
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(b, kc_printer, kc_current_view);
#line 823 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t myId = ctl_id_stack.top();
		ctl_id_stack.pop();

		assert(ctl_formulas[myId].size() == 2);
		EUFormula* euf = new EUFormula(ctl_formulas[myId][0], ctl_formulas[myId][1]);
		euf->index = 2 * myCacheId;
		euf->dfsindex = myDFSId * SIZEOF_STATENUMBER_T;

		ctl_formulas[ctl_id_stack.top()].push_back(euf);

#line  1133 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 247 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 247 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 247 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 247 "Frontend/Parser/formula_unparse.k"

		f->containsTemporal = true;
		f->validCTLStateFormula = x->validCTLStateFormula && y->validCTLStateFormula;
		f->validCTLPathFormula = false;
		f->validLTLFormula = false;

#line  1155 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 99 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 99 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		{ kc_printer(kc_t("E("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" U "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  1175 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  1188 "ast-system-unpk.cc"
void
impl_tStatePredicate_AU::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case ctl_enum: {
	    ctl_class& kc_current_view=static_cast<ctl_class&>(kc_current_view_base);
	    {
#line 783 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this->tStatePredicate_1;
#line 783 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate b = this->tStatePredicate_2;
#line 783 "Frontend/Parser/formula_unparse.k"

		ctl_id_stack.push(ctl_nextId++);
		const size_t myDFSId = ctl_dfs_id++;
		const size_t myCacheId = ctl_result_cache_id++;

#line  1206 "ast-system-unpk.cc"
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(b, kc_printer, kc_current_view);
#line 789 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t myId = ctl_id_stack.top();
		ctl_id_stack.pop();

		assert(ctl_formulas[myId].size() == 2);
		AUFormula* auf = new AUFormula(ctl_formulas[myId][0], ctl_formulas[myId][1]);
		auf->index = 2 * myCacheId;
		auf->dfsindex = myDFSId * SIZEOF_STATENUMBER_T;

		ctl_formulas[ctl_id_stack.top()].push_back(auf);

#line  1222 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 247 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 247 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 247 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 247 "Frontend/Parser/formula_unparse.k"

		f->containsTemporal = true;
		f->validCTLStateFormula = x->validCTLStateFormula && y->validCTLStateFormula;
		f->validCTLPathFormula = false;
		f->validLTLFormula = false;

#line  1244 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 102 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 102 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		{ kc_printer(kc_t("A("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" U "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  1264 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  1277 "ast-system-unpk.cc"
void
impl_tStatePredicate_Release::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 238 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 238 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 238 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 238 "Frontend/Parser/formula_unparse.k"

		f->containsTemporal = true;
		f->validCTLStateFormula = false;
		f->validCTLPathFormula = (x->validCTLStateFormula && y->validCTLStateFormula);
		f->validLTLFormula = (x->validLTLFormula && y->validLTLFormula);

#line  1300 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 98 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 98 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(phi, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" R "), kc_current_view); }
		kc::unparse(psi, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  1320 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  1333 "ast-system-unpk.cc"
void
impl_tStatePredicate_Until::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case ltl_enum: {
	    ltl_class& kc_current_view=static_cast<ltl_class&>(kc_current_view_base);
	    {
#line 895 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 895 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		kc::unparse(phi, kc_printer, kc_current_view);
		kc::unparse(psi, kc_printer, kc_current_view);
#line 898 "Frontend/Parser/formula_unparse.k"

		LTLTree_p a = ltlstack.back();
		ltlstack.pop_back();
		LTLTree_p b = ltlstack.back();
		ltlstack.pop_back();
		ltlstack.push_back(bin_simpler(tl_nn(U_OPER, a, b)));

#line  1355 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 238 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 238 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 238 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 238 "Frontend/Parser/formula_unparse.k"

		f->containsTemporal = true;
		f->validCTLStateFormula = false;
		f->validCTLPathFormula = (x->validCTLStateFormula && y->validCTLStateFormula);
		f->validLTLFormula = (x->validLTLFormula && y->validLTLFormula);

#line  1377 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 97 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate phi = this->tStatePredicate_1;
#line 97 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate psi = this->tStatePredicate_2;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(phi, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" U "), kc_current_view); }
		kc::unparse(psi, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  1397 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  1410 "ast-system-unpk.cc"
void
impl_tStatePredicate_NextState::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 231 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 231 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 231 "Frontend/Parser/formula_unparse.k"

		f->containsTemporal = true;
		f->validCTLStateFormula = false;
		f->validCTLPathFormula = x->validCTLStateFormula;
		f->validLTLFormula = x->validLTLFormula;

#line  1430 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 96 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("X ("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  1446 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  1459 "ast-system-unpk.cc"
void
impl_tStatePredicate_Eventually::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case ltl_enum: {
	    ltl_class& kc_current_view=static_cast<ltl_class&>(kc_current_view_base);
	    {
#line 879 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 881 "Frontend/Parser/formula_unparse.k"

		LTLTree_p a = ltlstack.back();
		ltlstack.pop_back();
		ltlstack.push_back(bin_simpler(tl_nn(U_OPER, tl_nn(TRUE, NULL, NULL), a)));

#line  1476 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 231 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 231 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 231 "Frontend/Parser/formula_unparse.k"

		f->containsTemporal = true;
		f->validCTLStateFormula = false;
		f->validCTLPathFormula = x->validCTLStateFormula;
		f->validLTLFormula = x->validLTLFormula;

#line  1495 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 95 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("F ("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  1511 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  1524 "ast-system-unpk.cc"
void
impl_tStatePredicate_Always::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case ltl_enum: {
	    ltl_class& kc_current_view=static_cast<ltl_class&>(kc_current_view_base);
	    {
#line 887 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 889 "Frontend/Parser/formula_unparse.k"

		LTLTree_p a = ltlstack.back();
		ltlstack.pop_back();
		ltlstack.push_back(bin_simpler(tl_nn(V_OPER, tl_nn(FALSE, NULL, NULL), a)));

#line  1541 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 231 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 231 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 231 "Frontend/Parser/formula_unparse.k"

		f->containsTemporal = true;
		f->validCTLStateFormula = false;
		f->validCTLPathFormula = x->validCTLStateFormula;
		f->validLTLFormula = x->validLTLFormula;

#line  1560 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 94 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("G ("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  1576 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  1589 "ast-system-unpk.cc"
void
impl_tStatePredicate_ExPath::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 223 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 223 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 223 "Frontend/Parser/formula_unparse.k"

		assert(x->containsTemporal);
		f->containsTemporal = true;
		f->validCTLStateFormula = x->validCTLPathFormula;
		f->validCTLPathFormula = false;
		f->validLTLFormula = false;

#line  1610 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 93 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("E"), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  1625 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  1638 "ast-system-unpk.cc"
void
impl_tStatePredicate_AllPath::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 223 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 223 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 223 "Frontend/Parser/formula_unparse.k"

		assert(x->containsTemporal);
		f->containsTemporal = true;
		f->validCTLStateFormula = x->validCTLPathFormula;
		f->validCTLPathFormula = false;
		f->validLTLFormula = false;

#line  1659 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 92 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("A"), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  1674 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  1687 "ast-system-unpk.cc"
void
impl_tStatePredicate_Equivalence::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case ltl_enum: {
	    ltl_class& kc_current_view=static_cast<ltl_class&>(kc_current_view_base);
	    {
#line 948 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 948 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 951 "Frontend/Parser/formula_unparse.k"

		LTLTree_p a = ltlstack.back();
		ltlstack.pop_back();
		LTLTree_p b = ltlstack.back();
		ltlstack.pop_back();
		ltlstack.push_back(bin_simpler(tl_nn(EQUIV, a, b)));

#line  1709 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 91 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 91 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" <-> "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  1729 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  1742 "ast-system-unpk.cc"
void
impl_tStatePredicate_Implication::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case ltl_enum: {
	    ltl_class& kc_current_view=static_cast<ltl_class&>(kc_current_view_base);
	    {
#line 937 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 937 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 940 "Frontend/Parser/formula_unparse.k"

		LTLTree_p a = ltlstack.back();
		ltlstack.pop_back();
		LTLTree_p b = ltlstack.back();
		ltlstack.pop_back();
		ltlstack.push_back(bin_simpler(tl_nn(IMPLIES, a, b)));

#line  1764 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 90 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 90 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" -> "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  1784 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  1797 "ast-system-unpk.cc"
void
impl_tStatePredicate_ExclusiveDisjunction::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 89 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 89 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" XOR "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  1818 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  1831 "ast-system-unpk.cc"
void
impl_tStatePredicate_Disjunction::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case ltl_enum: {
	    ltl_class& kc_current_view=static_cast<ltl_class&>(kc_current_view_base);
	    {
#line 926 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 926 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 929 "Frontend/Parser/formula_unparse.k"

		LTLTree_p a = ltlstack.back();
		ltlstack.pop_back();
		LTLTree_p b = ltlstack.back();
		ltlstack.pop_back();
		ltlstack.push_back(bin_simpler(tl_nn(OR, a, b)));

#line  1853 "ast-system-unpk.cc"
	    }
	    break;
	}
	case ctl_enum: {
	    ctl_class& kc_current_view=static_cast<ctl_class&>(kc_current_view_base);
	    if ((KC_TRACE_PROVIDED((not this/**/->containsTemporal), "Frontend/Parser/formula_unparse.k", 684, this))) {
#line 684 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 685 "Frontend/Parser/formula_unparse.k"





		{
#line 690 "Frontend/Parser/formula_unparse.k"
		    tFormula kc_selvar_0_1 = phylum_cast<tFormula>(StatePredicateFormula(f));
#line 697 "Frontend/Parser/formula_unparse.k"
		    if ((kc_selvar_0_1->prod_sel() == sel_StatePredicateFormula)) {
#line 697 "Frontend/Parser/formula_unparse.k"
#line 696 "Frontend/Parser/formula_unparse.k"
			const tFormula x = kc_selvar_0_1;
#line 697 "Frontend/Parser/formula_unparse.k"


			x->unparse(myprinter, kc::internal);
			AtomicFormula* af = new AtomicFormula();
			af->inner = new StatePredicateProperty(x->formula);
			ctl_formulas[ctl_id_stack.top()].push_back(af);

#line  1884 "ast-system-unpk.cc"
		    } else
			kc_no_default_in_with( "", __LINE__, __FILE__ );
		}
#line 705 "Frontend/Parser/formula_unparse.k"

#line  1890 "ast-system-unpk.cc"
	    } else
		if ((KC_TRACE_PROVIDED((this/**/->containsTemporal), "Frontend/Parser/formula_unparse.k", 753, this))) {
#line 753 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 753 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this->tStatePredicate_1;
#line 753 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate b = this->tStatePredicate_2;
#line 753 "Frontend/Parser/formula_unparse.k"

		ctl_id_stack.push(ctl_nextId++);

#line  1903 "ast-system-unpk.cc"
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(b, kc_printer, kc_current_view);
#line 757 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t myId = ctl_id_stack.top();
		ctl_id_stack.pop();

		DisjunctionFormula *df = new DisjunctionFormula(ctl_formulas[myId]);
		ctl_formulas[ctl_id_stack.top()].push_back(df);

#line  1915 "ast-system-unpk.cc"
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    {
#line 353 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this->tStatePredicate_1;
#line 353 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate b = this->tStatePredicate_2;
#line 353 "Frontend/Parser/formula_unparse.k"

		id_stack.push(nextId++);

#line  1931 "ast-system-unpk.cc"
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(b, kc_printer, kc_current_view);
#line 357 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t  myId = id_stack.top();
		id_stack.pop();

		StatePredicate *f = new DisjunctionStatePredicate(formulas[myId].size());
		for (size_t i = 0; i < formulas[myId].size(); ++i)
		{
		    assert(formulas[myId][i]);
		    ((DisjunctionStatePredicate*)f)->addSub(i, formulas[myId][i]);
		}

		formulas[id_stack.top()].push_back(f);

#line  1949 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 216 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 216 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 216 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 216 "Frontend/Parser/formula_unparse.k"

		f->containsTemporal = (x->containsTemporal || y->containsTemporal);
		f->validCTLStateFormula = (x->validCTLStateFormula && y->validCTLStateFormula);
		f->validCTLPathFormula = false;
		f->validLTLFormula = (x->validLTLFormula && y->validLTLFormula);

#line  1971 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 88 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 88 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" OR "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  1991 "ast-system-unpk.cc"
	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  2005 "ast-system-unpk.cc"
void
impl_tStatePredicate_Conjunction::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case ltl_enum: {
	    ltl_class& kc_current_view=static_cast<ltl_class&>(kc_current_view_base);
	    {
#line 915 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 915 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 918 "Frontend/Parser/formula_unparse.k"

		LTLTree_p a = ltlstack.back();
		ltlstack.pop_back();
		LTLTree_p b = ltlstack.back();
		ltlstack.pop_back();
		ltlstack.push_back(bin_simpler(tl_nn(AND, a, b)));

#line  2027 "ast-system-unpk.cc"
	    }
	    break;
	}
	case ctl_enum: {
	    ctl_class& kc_current_view=static_cast<ctl_class&>(kc_current_view_base);
	    if ((KC_TRACE_PROVIDED((not this/**/->containsTemporal), "Frontend/Parser/formula_unparse.k", 683, this))) {
#line 683 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 685 "Frontend/Parser/formula_unparse.k"





		{
#line 690 "Frontend/Parser/formula_unparse.k"
		    tFormula kc_selvar_0_1 = phylum_cast<tFormula>(StatePredicateFormula(f));
#line 697 "Frontend/Parser/formula_unparse.k"
		    if ((kc_selvar_0_1->prod_sel() == sel_StatePredicateFormula)) {
#line 697 "Frontend/Parser/formula_unparse.k"
#line 696 "Frontend/Parser/formula_unparse.k"
			const tFormula x = kc_selvar_0_1;
#line 697 "Frontend/Parser/formula_unparse.k"


			x->unparse(myprinter, kc::internal);
			AtomicFormula* af = new AtomicFormula();
			af->inner = new StatePredicateProperty(x->formula);
			ctl_formulas[ctl_id_stack.top()].push_back(af);

#line  2058 "ast-system-unpk.cc"
		    } else
			kc_no_default_in_with( "", __LINE__, __FILE__ );
		}
#line 705 "Frontend/Parser/formula_unparse.k"

#line  2064 "ast-system-unpk.cc"
	    } else
		if ((KC_TRACE_PROVIDED((this/**/->containsTemporal), "Frontend/Parser/formula_unparse.k", 740, this))) {
#line 740 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 740 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this->tStatePredicate_1;
#line 740 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate b = this->tStatePredicate_2;
#line 740 "Frontend/Parser/formula_unparse.k"

		ctl_id_stack.push(ctl_nextId++);

#line  2077 "ast-system-unpk.cc"
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(b, kc_printer, kc_current_view);
#line 744 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t myId = ctl_id_stack.top();
		ctl_id_stack.pop();

		ConjunctionFormula *cf = new ConjunctionFormula(ctl_formulas[myId]);
		ctl_formulas[ctl_id_stack.top()].push_back(cf);

#line  2089 "ast-system-unpk.cc"
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    {
#line 314 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this->tStatePredicate_1;
#line 314 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate b = this->tStatePredicate_2;
#line 314 "Frontend/Parser/formula_unparse.k"

		id_stack.push(nextId++);

#line  2105 "ast-system-unpk.cc"
		kc::unparse(a, kc_printer, kc_current_view);
		kc::unparse(b, kc_printer, kc_current_view);
#line 318 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t myId = id_stack.top();
		id_stack.pop();

		StatePredicate *f = new ConjunctionStatePredicate(formulas[myId].size());
		for (size_t i = 0; i < formulas[myId].size(); ++i)
		{
		    assert(formulas[myId][i]);
		    ((ConjunctionStatePredicate*)f)->addSub(i, formulas[myId][i]);
		}

		formulas[id_stack.top()].push_back(f);

#line  2123 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 216 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 216 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 216 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		kc::unparse(x, kc_printer, kc_current_view);
		kc::unparse(y, kc_printer, kc_current_view);
#line 216 "Frontend/Parser/formula_unparse.k"

		f->containsTemporal = (x->containsTemporal || y->containsTemporal);
		f->validCTLStateFormula = (x->validCTLStateFormula && y->validCTLStateFormula);
		f->validCTLPathFormula = false;
		f->validLTLFormula = (x->validLTLFormula && y->validLTLFormula);

#line  2145 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 87 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
#line 87 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate y = this->tStatePredicate_2;
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" AND "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  2165 "ast-system-unpk.cc"
	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  2179 "ast-system-unpk.cc"
void
impl_tStatePredicate_Negation::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case ltl_enum: {
	    ltl_class& kc_current_view=static_cast<ltl_class&>(kc_current_view_base);
	    {
#line 907 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 909 "Frontend/Parser/formula_unparse.k"

		LTLTree_p a = ltlstack.back();
		ltlstack.pop_back();
		ltlstack.push_back(bin_simpler(tl_nn(NOT, a, NULL)));

#line  2196 "ast-system-unpk.cc"
	    }
	    break;
	}
	case ctl_enum: {
	    ctl_class& kc_current_view=static_cast<ctl_class&>(kc_current_view_base);
	    {
#line 726 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate a = this->tStatePredicate_1;
#line 726 "Frontend/Parser/formula_unparse.k"

		ctl_id_stack.push(ctl_nextId++);

#line  2209 "ast-system-unpk.cc"
		kc::unparse(a, kc_printer, kc_current_view);
#line 730 "Frontend/Parser/formula_unparse.k"


		const arrayindex_t myId = ctl_id_stack.top();
		ctl_id_stack.pop();

		assert(ctl_formulas[myId].size() == 1);
		NotFormula *nf = new NotFormula(ctl_formulas[myId][0]);
		ctl_formulas[ctl_id_stack.top()].push_back(nf);

#line  2221 "ast-system-unpk.cc"
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 209 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 209 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 209 "Frontend/Parser/formula_unparse.k"

		f->containsTemporal = x->containsTemporal;
		f->validCTLStateFormula = x->validCTLStateFormula;
		f->validCTLPathFormula = false;
		f->validLTLFormula = x->validLTLFormula;

#line  2240 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 86 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate x = this->tStatePredicate_1;
		{ kc_printer(kc_t("!("), kc_current_view); }
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  2256 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  2269 "ast-system-unpk.cc"
void
impl_tStatePredicate_AtomicProposition::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case ltl_enum: {
	    ltl_class& kc_current_view=static_cast<ltl_class&>(kc_current_view_base);
	    {
#line 858 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = this->tAtomicProposition_1;
#line 859 "Frontend/Parser/formula_unparse.k"


		kc::tFormula internalFormula = StatePredicateFormula(AtomicProposition(x));
		internalFormula->unparse(myprinter, kc::internal);
		StatePredicate* result = internalFormula->formula;


		int num;
		char_p sym = produce_next_string(&num);

		predicateMap[num] = (AtomicStatePredicate*)result;
		LTLTree_p newTree = tl_nn(PREDICATE, NULL, NULL);
		newTree->sym = tl_lookup(sym);
		newTree = bin_simpler(newTree);

		assert(newTree->sym);
		ltlstack.push_back(newTree);

#line  2298 "ast-system-unpk.cc"
	    }
	    break;
	}
	case ctl_enum: {
	    ctl_class& kc_current_view=static_cast<ctl_class&>(kc_current_view_base);
	    if ((KC_TRACE_PROVIDED((not this/**/->containsTemporal), "Frontend/Parser/formula_unparse.k", 685, this))) {
#line 685 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 685 "Frontend/Parser/formula_unparse.k"





		{
#line 690 "Frontend/Parser/formula_unparse.k"
		    tFormula kc_selvar_0_1 = phylum_cast<tFormula>(StatePredicateFormula(f));
#line 697 "Frontend/Parser/formula_unparse.k"
		    if ((kc_selvar_0_1->prod_sel() == sel_StatePredicateFormula)) {
#line 697 "Frontend/Parser/formula_unparse.k"
#line 696 "Frontend/Parser/formula_unparse.k"
			const tFormula x = kc_selvar_0_1;
#line 697 "Frontend/Parser/formula_unparse.k"


			x->unparse(myprinter, kc::internal);
			AtomicFormula* af = new AtomicFormula();
			af->inner = new StatePredicateProperty(x->formula);
			ctl_formulas[ctl_id_stack.top()].push_back(af);

#line  2329 "ast-system-unpk.cc"
		    } else
			kc_no_default_in_with( "", __LINE__, __FILE__ );
		}
#line 705 "Frontend/Parser/formula_unparse.k"

#line  2335 "ast-system-unpk.cc"
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    {
#line 392 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition a = this->tAtomicProposition_1;
		kc::unparse(a, kc_printer, kc_current_view);
	    }
	    break;
	}
	case temporal_enum: {
	    temporal_class& kc_current_view=static_cast<temporal_class&>(kc_current_view_base);
	    {
#line 202 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate f = this/**/;
#line 202 "Frontend/Parser/formula_unparse.k"

		f->containsTemporal = false;
		f->validCTLPathFormula = false;
		f->validCTLStateFormula = true;
		f->validLTLFormula = true;

#line  2361 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 85 "Frontend/Parser/formula_unparse.k"
		const tAtomicProposition x = this->tAtomicProposition_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  2375 "ast-system-unpk.cc"
	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}

void
impl_tConjunction_list::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    if ((this->tConjunction_list_1->prod_sel() == sel_NiltConjunction_list)) {
#line 111 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
		kc::unparse(h, kc_printer, kc_current_view);
	    } else
	    {
#line 112 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 112 "Frontend/Parser/formula_unparse.k"
		const tConjunction_list l = this->tConjunction_list_1;
		kc::unparse(h, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" AND "), kc_current_view); }
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  2414 "ast-system-unpk.cc"
	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		for (tConjunction_list iterator_ = this; iterator_->tConjunction_list_1 != 0; iterator_ = iterator_->tConjunction_list_1)
		    iterator_->tStatePredicate_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_tConjunction_list::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  2433 "ast-system-unpk.cc"
	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}

void
impl_tDisjunction_list::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    if ((this->tDisjunction_list_1->prod_sel() == sel_NiltDisjunction_list)) {
#line 115 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
		kc::unparse(h, kc_printer, kc_current_view);
	    } else
	    {
#line 116 "Frontend/Parser/formula_unparse.k"
		const tStatePredicate h = this->tStatePredicate_1;
#line 116 "Frontend/Parser/formula_unparse.k"
		const tDisjunction_list l = this->tDisjunction_list_1;
		kc::unparse(h, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" OR "), kc_current_view); }
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  2471 "ast-system-unpk.cc"
	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		for (tDisjunction_list iterator_ = this; iterator_->tDisjunction_list_1 != 0; iterator_ = iterator_->tDisjunction_list_1)
		    iterator_->tStatePredicate_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_tDisjunction_list::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  2490 "ast-system-unpk.cc"
	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  2503 "ast-system-unpk.cc"
void
impl_tAtomicProposition_Fireable::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 130 "Frontend/Parser/formula_unparse.k"
		const integer x = this->integer_1;
		{ kc_printer(kc_t("FIREABLE("), kc_current_view); }
#line 130 "Frontend/Parser/formula_unparse.k"
		kc_printer(kc_t(Net::Name[TR][x->value]), kc_current_view); 
#line  2516 "ast-system-unpk.cc"
			{ kc_printer(kc_t(")"), kc_current_view); }
	    }
	    break;
	}

#line  2522 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  2535 "ast-system-unpk.cc"
void
impl_tAtomicProposition_Initial::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("INITIAL"), kc_current_view); }
	    }
	    break;
	}

#line  2548 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  2560 "ast-system-unpk.cc"
void
impl_tAtomicProposition_Deadlock::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    {
#line 496 "Frontend/Parser/formula_unparse.k"

		StatePredicate *f = new DeadlockPredicate(true);

		formulas[id_stack.top()].push_back(f);    

#line  2574 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("DEADLOCK"), kc_current_view); }
	    }
	    break;
	}

#line  2586 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  2598 "ast-system-unpk.cc"
void
impl_tAtomicProposition_NoDeadlock::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    {
#line 502 "Frontend/Parser/formula_unparse.k"

		StatePredicate *f = new DeadlockPredicate(false);

		formulas[id_stack.top()].push_back(f);    

#line  2612 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("! DEADLOCK"), kc_current_view); }
	    }
	    break;
	}

#line  2624 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  2636 "ast-system-unpk.cc"
void
impl_tAtomicProposition_False::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    {
#line 490 "Frontend/Parser/formula_unparse.k"

		StatePredicate *f = new FalsePredicate();

		formulas[id_stack.top()].push_back(f);    

#line  2650 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("FALSE"), kc_current_view); }
	    }
	    break;
	}

#line  2662 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  2674 "ast-system-unpk.cc"
void
impl_tAtomicProposition_True::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    {
#line 484 "Frontend/Parser/formula_unparse.k"

		StatePredicate *f = new TruePredicate();

		formulas[id_stack.top()].push_back(f);    

#line  2688 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
		{ kc_printer(kc_t("TRUE"), kc_current_view); }
	    }
	    break;
	}

#line  2700 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  2712 "ast-system-unpk.cc"
void
impl_tAtomicProposition_LessEqualAtomicProposition::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    if ((this->tTerm_2->prod_sel() == sel_Number)) {
#line 394 "Frontend/Parser/formula_unparse.k"
		const tTerm x = this->tTerm_1;
#line 394 "Frontend/Parser/formula_unparse.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(this->tTerm_2)->integer_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 394 "Frontend/Parser/formula_unparse.k"

		arrayindex_t factors_positive = 0;
		arrayindex_t factors_negative = 0;


		for (std::map<int, int>::const_iterator it = current.begin(); it != current.end(); ++it)
		{
		    if (it->second > 0)
		    {
			factors_positive++;
		    }
		    else if (it->second < 0)
		    {
			factors_negative++;
		    }
		}


		StatePredicate *f = new AtomicStatePredicate(factors_positive, factors_negative, y->value);
		arrayindex_t position_pos = 0;
		arrayindex_t position_neg = 0;


		for (std::map<int, int>::const_iterator it = current.begin(); it != current.end(); ++it)
		{
		    if (it->second > 0)
		    {
			((AtomicStatePredicate*)f)->addPos(position_pos++, it->first, it->second);
		    }
		    else if (it->second < 0)
		    {
			((AtomicStatePredicate*)f)->addNeg(position_neg++, it->first, -it->second);
		    }
		}


		((AtomicStatePredicate*)f)->reduceFactors();


		current.clear();


		formulas[id_stack.top()].push_back(f);

#line  2770 "ast-system-unpk.cc"
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 124 "Frontend/Parser/formula_unparse.k"
		const tTerm x = this->tTerm_1;
#line 124 "Frontend/Parser/formula_unparse.k"
		const tTerm y = this->tTerm_2;
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" <= "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  2789 "ast-system-unpk.cc"
	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  2803 "ast-system-unpk.cc"
void
impl_tAtomicProposition_LessAtomicProposition::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 123 "Frontend/Parser/formula_unparse.k"
		const tTerm x = this->tTerm_1;
#line 123 "Frontend/Parser/formula_unparse.k"
		const tTerm y = this->tTerm_2;
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" < "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  2822 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  2835 "ast-system-unpk.cc"
void
impl_tAtomicProposition_GreaterEqualAtomicProposition::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 122 "Frontend/Parser/formula_unparse.k"
		const tTerm x = this->tTerm_1;
#line 122 "Frontend/Parser/formula_unparse.k"
		const tTerm y = this->tTerm_2;
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" >= "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  2854 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  2867 "ast-system-unpk.cc"
void
impl_tAtomicProposition_GreaterAtomicProposition::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    if ((this->tTerm_2->prod_sel() == sel_Number)) {
#line 439 "Frontend/Parser/formula_unparse.k"
		const tTerm x = this->tTerm_1;
#line 439 "Frontend/Parser/formula_unparse.k"
		const integer y = phylum_cast<const impl_tTerm_Number*>(this->tTerm_2)->integer_1;
		kc::unparse(x, kc_printer, kc_current_view);
#line 439 "Frontend/Parser/formula_unparse.k"

		arrayindex_t factors_positive = 0;
		arrayindex_t factors_negative = 0;


		for (std::map<int, int>::const_iterator it = current.begin(); it != current.end(); ++it)
		{
		    if (it->second > 0)
		    {
			factors_positive++;
		    }
		    else if (it->second < 0)
		    {
			factors_negative++;
		    }
		}


		StatePredicate *f = new AtomicStatePredicate(factors_negative, factors_positive, (- y->value) -1);
		arrayindex_t position_pos = 0;
		arrayindex_t position_neg = 0;


		for (std::map<int, int>::const_iterator it = current.begin(); it != current.end(); ++it)
		{
		    if (it->second < 0) 
		    {
			((AtomicStatePredicate*)f)->addPos(position_pos++, it->first, -it->second);
		    }
		    else if (it->second > 0) 
		    {
			((AtomicStatePredicate*)f)->addNeg(position_neg++, it->first, it->second);
		    }
		}


		((AtomicStatePredicate*)f)->reduceFactors();


		current.clear();


		formulas[id_stack.top()].push_back(f);

#line  2925 "ast-system-unpk.cc"
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 121 "Frontend/Parser/formula_unparse.k"
		const tTerm x = this->tTerm_1;
#line 121 "Frontend/Parser/formula_unparse.k"
		const tTerm y = this->tTerm_2;
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" > "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  2944 "ast-system-unpk.cc"
	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  2958 "ast-system-unpk.cc"
void
impl_tAtomicProposition_NotEqualsAtomicProposition::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 120 "Frontend/Parser/formula_unparse.k"
		const tTerm x = this->tTerm_1;
#line 120 "Frontend/Parser/formula_unparse.k"
		const tTerm y = this->tTerm_2;
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" != "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  2977 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  2990 "ast-system-unpk.cc"
void
impl_tAtomicProposition_EqualsAtomicProposition::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 119 "Frontend/Parser/formula_unparse.k"
		const tTerm x = this->tTerm_1;
#line 119 "Frontend/Parser/formula_unparse.k"
		const tTerm y = this->tTerm_2;
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" = "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  3009 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  3022 "ast-system-unpk.cc"
void
impl_tTerm_ProductList::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  3028 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  3041 "ast-system-unpk.cc"
void
impl_tTerm_Product::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    if ((this->tTerm_1->prod_sel() == sel_Node)) {
#line 508 "Frontend/Parser/formula_unparse.k"
		const integer x = this->integer_1;
#line 508 "Frontend/Parser/formula_unparse.k"
		const integer p = phylum_cast<const impl_tTerm_Node*>(this->tTerm_1)->integer_1;
#line 508 "Frontend/Parser/formula_unparse.k"

		current[p->value] += x->value;


		if (place_in_formula[p->value] == false)
		{
		    unique_places_mentioned++;
		    place_in_formula[p->value] = true;
		}
		places_mentioned++;

#line  3065 "ast-system-unpk.cc"
	    } else
		    goto kc_unparsing_default;
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    if ((KC_TRACE_PROVIDED((this->integer_1->value == 1), "Frontend/Parser/formula_unparse.k", 140, this))) {
#line 140 "Frontend/Parser/formula_unparse.k"
		const integer x = this->integer_1;
#line 140 "Frontend/Parser/formula_unparse.k"
		const tTerm y = this->tTerm_1;
		kc::unparse(y, kc_printer, kc_current_view);
	    } else
		if ((KC_TRACE_PROVIDED((this->integer_1->value == -1), "Frontend/Parser/formula_unparse.k", 141, this))) {
#line 141 "Frontend/Parser/formula_unparse.k"
		const integer x = this->integer_1;
#line 141 "Frontend/Parser/formula_unparse.k"
		const tTerm y = this->tTerm_1;
		{ kc_printer(kc_t("-"), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
	    } else
	    {
#line 142 "Frontend/Parser/formula_unparse.k"
		const integer x = this->integer_1;
#line 142 "Frontend/Parser/formula_unparse.k"
		const tTerm y = this->tTerm_1;
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t("*"), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  3099 "ast-system-unpk.cc"
	default:
	kc_unparsing_default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  3113 "ast-system-unpk.cc"
void
impl_tTerm_Difference::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 139 "Frontend/Parser/formula_unparse.k"
		const tTerm x = this->tTerm_1;
#line 139 "Frontend/Parser/formula_unparse.k"
		const tTerm y = this->tTerm_2;
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" - "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  3132 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  3145 "ast-system-unpk.cc"
void
impl_tTerm_Sum::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 138 "Frontend/Parser/formula_unparse.k"
		const tTerm x = this->tTerm_1;
#line 138 "Frontend/Parser/formula_unparse.k"
		const tTerm y = this->tTerm_2;
		kc::unparse(x, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" + "), kc_current_view); }
		kc::unparse(y, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  3164 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  3177 "ast-system-unpk.cc"
void
impl_tTerm_Number::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case internal_enum: {
	    internal_class& kc_current_view=static_cast<internal_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    if ((KC_TRACE_PROVIDED((this->integer_1->value == -FINITE), "Frontend/Parser/formula_unparse.k", 133, this))) {
#line 133 "Frontend/Parser/formula_unparse.k"
		const integer x = this->integer_1;
		{ kc_printer(kc_t("-finite"), kc_current_view); }
	    } else
		if ((KC_TRACE_PROVIDED((this->integer_1->value == FINITE), "Frontend/Parser/formula_unparse.k", 134, this))) {
#line 134 "Frontend/Parser/formula_unparse.k"
		const integer x = this->integer_1;
		{ kc_printer(kc_t("finite"), kc_current_view); }
	    } else
		if ((KC_TRACE_PROVIDED((this->integer_1->value == -OMEGA), "Frontend/Parser/formula_unparse.k", 135, this))) {
#line 135 "Frontend/Parser/formula_unparse.k"
		const integer x = this->integer_1;
		{ kc_printer(kc_t("-oo"), kc_current_view); }
	    } else
		if ((KC_TRACE_PROVIDED((this->integer_1->value == OMEGA), "Frontend/Parser/formula_unparse.k", 136, this))) {
#line 136 "Frontend/Parser/formula_unparse.k"
		const integer x = this->integer_1;
		{ kc_printer(kc_t("oo"), kc_current_view); }
	    } else
	    {
#line 137 "Frontend/Parser/formula_unparse.k"
		const integer x = this->integer_1;
		kc::unparse(x, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  3218 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  3231 "ast-system-unpk.cc"
void
impl_tTerm_Node::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 132 "Frontend/Parser/formula_unparse.k"
		const integer x = this->integer_1;
#line 132 "Frontend/Parser/formula_unparse.k"
		kc_printer(kc_t(Net::Name[PL][x->value]), kc_current_view); 
#line  3243 "ast-system-unpk.cc"
	    }
	    break;
	}

#line  3248 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}

void
impl_tProduct_list::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    if(is_nil())
	nil_do_unparse(kc_printer, kc_current_view_base);
    else
	switch(kc_current_view_base) {
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    if ((this->tTerm_1->prod_sel() == sel_Product) && (KC_TRACE_PROVIDED((phylum_cast<const impl_tTerm_Product*>(this->tTerm_1)->integer_1->value < 0), "Frontend/Parser/formula_unparse.k", 144, this))) {
#line 144 "Frontend/Parser/formula_unparse.k"
		const tTerm h = this->tTerm_1;
#line 144 "Frontend/Parser/formula_unparse.k"
		const integer x = phylum_cast<const impl_tTerm_Product*>(this->tTerm_1)->integer_1;
#line 144 "Frontend/Parser/formula_unparse.k"
		const tProduct_list l = this->tProduct_list_1;
		kc::unparse(h, kc_printer, kc_current_view);
		kc::unparse(l, kc_printer, kc_current_view);
	    } else
		if ((this->tProduct_list_1->prod_sel() == sel_NiltProduct_list)) {
#line 143 "Frontend/Parser/formula_unparse.k"
		const tTerm h = this->tTerm_1;
		kc::unparse(h, kc_printer, kc_current_view);
	    } else
	    {
#line 145 "Frontend/Parser/formula_unparse.k"
		const tTerm h = this->tTerm_1;
#line 145 "Frontend/Parser/formula_unparse.k"
		const tProduct_list l = this->tProduct_list_1;
		kc::unparse(h, kc_printer, kc_current_view);
		{ kc_printer(kc_t(" + "), kc_current_view); }
		kc::unparse(l, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  3296 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		for (tProduct_list iterator_ = this; iterator_->tProduct_list_1 != 0; iterator_ = iterator_->tProduct_list_1)
		    iterator_->tTerm_1->unparse(kc_printer, kc_current_view);
	    }
	    break;
	}
    }
}

void
impl_tProduct_list::nil_do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {

#line  3314 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  3326 "ast-system-unpk.cc"
void
impl_tBuechiAutomata_BuechiNull::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case buechi_enum: {
	    buechi_class& kc_current_view=static_cast<buechi_class&>(kc_current_view_base);
	    {
#line 546 "Frontend/Parser/formula_unparse.k"
		const tBuechiAutomata b = this/**/;
#line 546 "Frontend/Parser/formula_unparse.k"
		RT::rep->message("NULL BUECHI"); b->automata = 0; 
#line  3338 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

#line  3349 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  3361 "ast-system-unpk.cc"
void
impl_tBuechiAutomata_BuechiAutomaton::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case buechi_enum: {
	    buechi_class& kc_current_view=static_cast<buechi_class&>(kc_current_view_base);
	    {
#line 547 "Frontend/Parser/formula_unparse.k"
		const tBuechiAutomata b = this/**/;
#line 547 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules trans = this->tBuechiRules_1;
#line 547 "Frontend/Parser/formula_unparse.k"
		const tAcceptingSet accept = this->tAcceptingSet_1;
		kc::unparse(trans, kc_printer, kc_current_view);
		kc::unparse(accept, kc_printer, kc_current_view);
#line 550 "Frontend/Parser/formula_unparse.k"




		uint32_t number_of_states = states_to_interal.size();


		b->automata = new BuechiAutomata();
		b->automata->cardStates = number_of_states;



		b->automata->cardAtomicPropositions = predicates.size();
		b->automata->atomicPropositions = new StatePredicateProperty*[predicates.size()]();
		b->automata->atomicPropotions_backlist = new arrayindex_t[predicates.size()]();
		for (uint32_t i = 0; i < predicates.size(); i++)
		b->automata->atomicPropositions[i] = new StatePredicateProperty(predicates[i]);	




		b->automata->cardTransitions = new uint32_t[number_of_states]();
		b->automata->transitions = new uint32_t**[number_of_states]();
		b->automata->cardEnabled = new arrayindex_t[number_of_states]();
		for (uint32_t i = 0; i < number_of_states; i++){
		    b->automata->cardTransitions[i] = transitions[i].size();
		    b->automata->transitions[i] = new uint32_t*[transitions[i].size()]();
		    for (uint32_t j = 0; j < transitions[i].size(); j++){

			b->automata->transitions[i][j] = new uint32_t[2]();
			b->automata->transitions[i][j][0] = transitions[i][j].first;
			b->automata->transitions[i][j][1] = transitions[i][j].second;
			b->automata->atomicPropotions_backlist[transitions[i][j].first] = i;
		    }
		}



		b->automata->isStateAccepting = new bool[number_of_states]();
		for (__typeof__(acceptingset.begin()) i = acceptingset.begin(); i != acceptingset.end(); i++)
		b->automata->isStateAccepting[*i] = true;

#line  3420 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 148 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules trans = this->tBuechiRules_1;
#line 148 "Frontend/Parser/formula_unparse.k"
		const tAcceptingSet accept = this->tAcceptingSet_1;
		kc::unparse(trans, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\n"), kc_current_view); }
		kc::unparse(accept, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  3438 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  3451 "ast-system-unpk.cc"
void
impl_tBuechiRules_BuechiRules::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case buechi_enum: {
	    buechi_class& kc_current_view=static_cast<buechi_class&>(kc_current_view_base);
	    {
#line 618 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules lrules = this->tBuechiRules_1;
#line 618 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules rrules = this->tBuechiRules_2;
		kc::unparse(lrules, kc_printer, kc_current_view);
		kc::unparse(rrules, kc_printer, kc_current_view);
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 154 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules a = this->tBuechiRules_1;
#line 154 "Frontend/Parser/formula_unparse.k"
		const tBuechiRules b = this->tBuechiRules_2;
		kc::unparse(a, kc_printer, kc_current_view);
		{ kc_printer(kc_t("&"), kc_current_view); }
		kc::unparse(b, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  3482 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  3495 "ast-system-unpk.cc"
void
impl_tBuechiRules_ExpandedBuechiRule::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case buechi_enum: {
	    buechi_class& kc_current_view=static_cast<buechi_class&>(kc_current_view_base);
	    {
#line 595 "Frontend/Parser/formula_unparse.k"
		const integer from = this->integer_1;
#line 595 "Frontend/Parser/formula_unparse.k"
		const tFormula formula = this->tFormula_1;
#line 595 "Frontend/Parser/formula_unparse.k"
		const integer to = this->integer_2;
#line 596 "Frontend/Parser/formula_unparse.k"


		formula->unparse(myprinter, kc::internal);
		StatePredicate* result = formula->formula;






		uint32_t formula_number = (uint32_t)(predicates.size());
		predicates[formula_number] = result;

		uint32_t from_number = get_state_number(from->value);
		uint32_t to_number = get_state_number(to->value);

		transitions[from_number].push_back(std::make_pair(formula_number, to_number));

#line  3528 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 153 "Frontend/Parser/formula_unparse.k"
		const integer from = this->integer_1;
#line 153 "Frontend/Parser/formula_unparse.k"
		const tFormula formula = this->tFormula_1;
#line 153 "Frontend/Parser/formula_unparse.k"
		const integer to = this->integer_2;
		kc::unparse(from, kc_printer, kc_current_view);
		{ kc_printer(kc_t("("), kc_current_view); }
		kc::unparse(formula, kc_printer, kc_current_view);
		{ kc_printer(kc_t(") -> "), kc_current_view); }
		kc::unparse(to, kc_printer, kc_current_view);
		{ kc_printer(kc_t("\n"), kc_current_view); }
	    }
	    break;
	}

#line  3551 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  3564 "ast-system-unpk.cc"
void
impl_tBuechiRules_BuechiRule::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 152 "Frontend/Parser/formula_unparse.k"
		const integer i = this->integer_1;
#line 152 "Frontend/Parser/formula_unparse.k"
		const tTransitionRules t = this->tTransitionRules_1;
		{ kc_printer(kc_t("STATE"), kc_current_view); }
		kc::unparse(i, kc_printer, kc_current_view);
		kc::unparse(t, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  3583 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  3596 "ast-system-unpk.cc"
void
impl_tBuechiRules_EmptyBuechiRules::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case buechi_enum: {
	    buechi_class& kc_current_view=static_cast<buechi_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

#line  3614 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  3626 "ast-system-unpk.cc"
void
impl_tTransitionRules_TransitionRules::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 158 "Frontend/Parser/formula_unparse.k"
		const tTransitionRules a = this->tTransitionRules_1;
#line 158 "Frontend/Parser/formula_unparse.k"
		const tTransitionRules b = this->tTransitionRules_2;
		kc::unparse(a, kc_printer, kc_current_view);
		{ kc_printer(kc_t("&"), kc_current_view); }
		kc::unparse(b, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  3645 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  3658 "ast-system-unpk.cc"
void
impl_tTransitionRules_TransitionRule::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
#line 157 "Frontend/Parser/formula_unparse.k"
		const tFormula formu = this->tFormula_1;
#line 157 "Frontend/Parser/formula_unparse.k"
		const integer i = this->integer_1;
		kc::unparse(formu, kc_printer, kc_current_view);
		{ kc_printer(kc_t("->"), kc_current_view); }
		kc::unparse(i, kc_printer, kc_current_view);
	    }
	    break;
	}

#line  3677 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  3690 "ast-system-unpk.cc"
void
impl_tTransitionRules_EmptyTransitionRules::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

#line  3702 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


#line  3714 "ast-system-unpk.cc"
void
impl_tAcceptingSet_AcceptingSet::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case buechi_enum: {
	    buechi_class& kc_current_view=static_cast<buechi_class&>(kc_current_view_base);
	    {
#line 629 "Frontend/Parser/formula_unparse.k"
		const tAcceptingSet set1 = this->tAcceptingSet_1;
#line 629 "Frontend/Parser/formula_unparse.k"
		const tAcceptingSet set2 = this->tAcceptingSet_2;
		kc::unparse(set1, kc_printer, kc_current_view);
		kc::unparse(set2, kc_printer, kc_current_view);
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

#line  3738 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  3751 "ast-system-unpk.cc"
void
impl_tAcceptingSet_AcceptingState::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case buechi_enum: {
	    buechi_class& kc_current_view=static_cast<buechi_class&>(kc_current_view_base);
	    {
#line 623 "Frontend/Parser/formula_unparse.k"
		const integer state = this->integer_1;
#line 624 "Frontend/Parser/formula_unparse.k"

		acceptingset.insert(get_state_number(state->value));

#line  3765 "ast-system-unpk.cc"
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

#line  3776 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
		default_unparse(kc_printer, kc_current_view );
	    }
	    break;
	}
    }
}


#line  3789 "ast-system-unpk.cc"
void
impl_tAcceptingSet_EmptyAcceptingSet::do_unparse(printer_functor kc_printer, uview kc_current_view_base)
{
    switch(kc_current_view_base) {
	case buechi_enum: {
	    buechi_class& kc_current_view=static_cast<buechi_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}
	case out_enum: {
	    out_class& kc_current_view=static_cast<out_class&>(kc_current_view_base);
	    {
	    }
	    break;
	}

#line  3807 "ast-system-unpk.cc"
	default:
	case base_uview_enum: {
	    uview kc_current_view=kc_current_view_base;
	    {
	    }
	    break;
	}
    }
}


} // namespace kc
